{"version":3,"file":"main.k5Venp8x.js","sources":["../../src/components/ResourceManager.js","../../src/components/TimerManager.js","../../src/components/EventManager.js","../../src/components/StateManager.js","../../src/components/ReactiveManager.js","../../src/components/NeuronGridManager.js","../../src/components/utils/logger.js","../../src/components/initManagers.js","../../src/components/utils/TimerManager.js","../../src/components/utils/initSystemManagers.js","../../src/components/core/NeuronEngine.js","../../src/components/core/NeuronAdapter.js","../../src/components/core/index.js","../../src/components/core/patchExistingCode.js","../../src/components/core/initializeSystem.js","../../src/components/core/integrator.js","../../src/components/neuron.js","../../src/components/InputManager.js","../../src/components/OptimizedSoundManager.js","../../src/components/effects/NeuronEffect.js","../../src/components/effects/ConnectionEffect.js","../../src/components/effects/EffectsManager.js","../../src/components/FluidBackgroundEffect.js","../../src/components/OptimizedParticleSystem.js","../../src/config/soundPresets.js","../../src/components/EventSystem.js","../../src/components/AppInitializer.js","../../src/main.js","../../src/components/SceneManager.js","../../src/components/effects/initEffectsSystem.js","../../src/components/UIManager.js","../../src/components/ConnectionManager.js","../../src/components/WorkerManager.js","../../src/components/HarmonicSystem.js"],"sourcesContent":["/**\n * ResourceManager - Manages THREE.js resources and handles proper disposal\n * \n * Provides:\n * - Centralized tracking of THREE.js resources\n * - Automatic disposal of materials, geometries, textures\n * - Resource pooling to prevent recreating objects\n */\nimport * as THREE from 'three';\n\nexport class ResourceManager {\n  constructor() {\n    // Track all resources by type and owner\n    this.resources = {\n      geometries: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      objects: new Map(),\n      meshes: new Map(),\n      shaders: new Map(),\n      renderers: new Map()\n    };\n    \n    // Object pools for reuse\n    this.pools = {\n      geometries: new Map(),\n      materials: new Map(),\n      meshes: new Map()\n    };\n    \n    // Resource ownership\n    this.ownership = new Map();\n  }\n  \n  /**\n   * Register a THREE.js resource for tracking\n   * @param {string} type - Resource type (geometry, material, etc.)\n   * @param {Object} resource - The THREE.js resource object\n   * @param {string} ownerId - ID of component that owns this resource\n   * @param {string} [resourceId] - Optional unique ID for this resource\n   * @returns {string} Resource ID for reference\n   */\n  registerResource(type, resource, ownerId, resourceId = null) {\n    // Check if the type is valid\n    if (!this.resources[type]) {\n      // Skip warning, only log errors\n      return null;\n    }\n    \n    // Generate resource ID if not provided\n    const id = resourceId || `${type}_${ownerId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Store the resource\n    this.resources[type].set(id, resource);\n    \n    // Track ownership\n    if (!this.ownership.has(ownerId)) {\n      this.ownership.set(ownerId, new Map());\n    }\n    \n    if (!this.ownership.get(ownerId).has(type)) {\n      this.ownership.get(ownerId).set(type, new Set());\n    }\n    \n    this.ownership.get(ownerId).get(type).add(id);\n    \n    return id;\n  }\n  \n  /**\n   * Get a resource by ID\n   * @param {string} type - Resource type\n   * @param {string} id - Resource ID\n   * @returns {Object} The resource\n   */\n  getResource(type, id) {\n    if (!this.resources[type]) return null;\n    return this.resources[type].get(id);\n  }\n  \n  /**\n   * Dispose of a specific resource\n   * @param {string} type - Resource type\n   * @param {string} id - Resource ID\n   * @param {boolean} addToPool - Whether to add to pool instead of disposing\n   * @returns {boolean} Success\n   */\n  disposeResource(type, id, addToPool = false) {\n    if (!this.resources[type] || !this.resources[type].has(id)) {\n      return false;\n    }\n    \n    const resource = this.resources[type].get(id);\n    \n    // Add to pool instead of disposing if requested and supported\n    if (addToPool && this.pools[type]) {\n      // Get resource key (depends on type)\n      let key;\n      if (type === 'geometries' && resource.type) {\n        key = resource.type;\n      } else if (type === 'materials' && resource.type) {\n        key = `${resource.type}_${resource.color ? resource.color.getHex() : 0}`;\n      } else {\n        // Generic fallback\n        key = type;\n      }\n      \n      // Add to pool\n      if (!this.pools[type].has(key)) {\n        this.pools[type].set(key, []);\n      }\n      \n      // Reset properties to clean state before pooling\n      this._resetResourceForPooling(type, resource);\n      \n      // Add to pool\n      this.pools[type].get(key).push(resource);\n    } else {\n      // Dispose properly based on type\n      this._disposeByType(type, resource);\n    }\n    \n    // Remove from tracking\n    this.resources[type].delete(id);\n    \n    // Update ownership tracking\n    for (const [ownerId, typeMap] of this.ownership.entries()) {\n      if (typeMap.has(type)) {\n        const resourceSet = typeMap.get(type);\n        if (resourceSet.has(id)) {\n          resourceSet.delete(id);\n          \n          // Clean up if empty\n          if (resourceSet.size === 0) {\n            typeMap.delete(type);\n            if (typeMap.size === 0) {\n              this.ownership.delete(ownerId);\n            }\n          }\n          break;\n        }\n      }\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Get a resource from the pool or create new\n   * @param {string} type - Resource type\n   * @param {string} key - Pool key\n   * @param {Function} createFn - Function to create new resource if none in pool\n   * @param {string} ownerId - Component ID\n   * @returns {Object} Resource and its ID\n   */\n  getPooledResource(type, key, createFn, ownerId) {\n    let resource;\n    \n    // Try to get from pool\n    if (this.pools[type] && this.pools[type].has(key) && this.pools[type].get(key).length > 0) {\n      resource = this.pools[type].get(key).pop();\n    } else {\n      // Create new if not in pool\n      resource = createFn();\n    }\n    \n    // Register the resource\n    const resourceId = this.registerResource(type, resource, ownerId);\n    \n    return { resource, resourceId };\n  }\n  \n  /**\n   * Clean up all resources for a component\n   * @param {string} ownerId - Component ID\n   * @param {boolean} addToPool - Whether to pool resources instead of disposing\n   */\n  cleanupOwner(ownerId, addToPool = false) {\n    if (!this.ownership.has(ownerId)) return;\n    \n    const typeMap = this.ownership.get(ownerId);\n    \n    // For each resource type owned by this component\n    typeMap.forEach((resourceIds, type) => {\n      // Create a copy of the set to avoid modification during iteration\n      const idsToRemove = [...resourceIds];\n      \n      // Dispose each resource\n      idsToRemove.forEach(id => {\n        this.disposeResource(type, id, addToPool);\n      });\n    });\n    \n    // Remove the owner from tracking\n    this.ownership.delete(ownerId);\n  }\n  \n  /**\n   * Create a THREE.js geometry with automatic tracking\n   * @param {string} ownerId - Component ID\n   * @param {string} geometryType - Type of geometry to create\n   * @param {Array} params - Parameters for the geometry constructor\n   * @param {boolean} usePooling - Whether to check pool first\n   * @returns {Object} The geometry and its tracking ID\n   */\n  createGeometry(ownerId, geometryType, params = [], usePooling = true) {\n    // Try to get from pool if requested\n    if (usePooling) {\n      return this.getPooledResource(\n        'geometries',\n        geometryType,\n        () => {\n          // Create the appropriate geometry type\n          switch (geometryType) {\n            case 'BoxGeometry':\n              return new THREE.BoxGeometry(...params);\n            case 'SphereGeometry':\n              return new THREE.SphereGeometry(...params);\n            case 'PlaneGeometry':\n              return new THREE.PlaneGeometry(...params);\n            case 'CircleGeometry':\n              return new THREE.CircleGeometry(...params);\n            case 'CylinderGeometry':\n              return new THREE.CylinderGeometry(...params);\n            case 'BufferGeometry':\n              return new THREE.BufferGeometry();\n            default:\n              return new THREE.BufferGeometry();\n          }\n        },\n        ownerId\n      );\n    }\n    \n    // Create directly if pooling not requested\n    let geometry;\n    switch (geometryType) {\n      case 'BoxGeometry':\n        geometry = new THREE.BoxGeometry(...params);\n        break;\n      case 'SphereGeometry':\n        geometry = new THREE.SphereGeometry(...params);\n        break;\n      case 'PlaneGeometry':\n        geometry = new THREE.PlaneGeometry(...params);\n        break;\n      case 'CircleGeometry':\n        geometry = new THREE.CircleGeometry(...params);\n        break;\n      case 'CylinderGeometry':\n        geometry = new THREE.CylinderGeometry(...params);\n        break;\n      case 'BufferGeometry':\n        geometry = new THREE.BufferGeometry();\n        break;\n      default:\n        return { resource: new THREE.BufferGeometry(), resourceId: null };\n    }\n    \n    // Register and return\n    const resourceId = this.registerResource('geometries', geometry, ownerId);\n    return { resource: geometry, resourceId };\n  }\n  \n  /**\n   * Create a THREE.js material with automatic tracking\n   * @param {string} ownerId - Component ID\n   * @param {string} materialType - Type of material\n   * @param {Object} params - Parameters for the material\n   * @param {boolean} usePooling - Whether to check pool first\n   * @returns {Object} The material and its tracking ID\n   */\n  createMaterial(ownerId, materialType, params = {}, usePooling = true) {\n    // Generate a pool key based on material type and color\n    const color = params.color !== undefined ? \n      (typeof params.color === 'number' ? params.color : new THREE.Color(params.color).getHex()) : \n      0;\n    \n    const poolKey = `${materialType}_${color}`;\n    \n    // Try to get from pool if requested\n    if (usePooling) {\n      return this.getPooledResource(\n        'materials',\n        poolKey,\n        () => {\n          // Create the appropriate material type\n          switch (materialType) {\n            case 'MeshBasicMaterial':\n              return new THREE.MeshBasicMaterial(params);\n            case 'MeshStandardMaterial':\n              return new THREE.MeshStandardMaterial(params);\n            case 'MeshPhongMaterial':\n              return new THREE.MeshPhongMaterial(params);\n            case 'MeshLambertMaterial':\n              return new THREE.MeshLambertMaterial(params);\n            case 'LineBasicMaterial':\n              return new THREE.LineBasicMaterial(params);\n            default:\n              return new THREE.MeshBasicMaterial(params);\n          }\n        },\n        ownerId\n      );\n    }\n    \n    // Create directly if pooling not requested\n    let material;\n    switch (materialType) {\n      case 'MeshBasicMaterial':\n        material = new THREE.MeshBasicMaterial(params);\n        break;\n      case 'MeshStandardMaterial':\n        material = new THREE.MeshStandardMaterial(params);\n        break;\n      case 'MeshPhongMaterial':\n        material = new THREE.MeshPhongMaterial(params);\n        break;\n      case 'MeshLambertMaterial':\n        material = new THREE.MeshLambertMaterial(params);\n        break;\n      case 'LineBasicMaterial':\n        material = new THREE.LineBasicMaterial(params);\n        break;\n      default:\n        return { resource: new THREE.MeshBasicMaterial(params), resourceId: null };\n    }\n    \n    // Register and return\n    const resourceId = this.registerResource('materials', material, ownerId);\n    return { resource: material, resourceId };\n  }\n  \n  /**\n   * Properly dispose resource based on its type\n   * @private\n   */\n  _disposeByType(type, resource) {\n    if (!resource) return;\n    \n    switch (type) {\n      case 'geometries':\n        if (resource.dispose) resource.dispose();\n        break;\n        \n      case 'materials':\n        if (resource.dispose) resource.dispose();\n        \n        // Also dispose any textures owned by this material\n        for (const prop in resource) {\n          const value = resource[prop];\n          if (value && value.isTexture) {\n            value.dispose();\n          }\n        }\n        break;\n        \n      case 'textures':\n        if (resource.dispose) resource.dispose();\n        break;\n        \n      case 'objects':\n        // For generic objects, remove from parent\n        if (resource.parent) {\n          resource.parent.remove(resource);\n        }\n        \n        // Dispose any geometries or materials\n        if (resource.geometry && resource.geometry.dispose) {\n          resource.geometry.dispose();\n        }\n        \n        if (resource.material) {\n          // Handle array of materials\n          if (Array.isArray(resource.material)) {\n            resource.material.forEach(material => {\n              if (material && material.dispose) material.dispose();\n            });\n          } else if (resource.material.dispose) {\n            resource.material.dispose();\n          }\n        }\n        break;\n        \n      case 'meshes':\n        // For meshes, handle it the same as objects\n        if (resource.parent) {\n          resource.parent.remove(resource);\n        }\n        \n        if (resource.geometry && resource.geometry.dispose) {\n          resource.geometry.dispose();\n        }\n        \n        if (resource.material) {\n          // Handle array of materials\n          if (Array.isArray(resource.material)) {\n            resource.material.forEach(material => {\n              if (material && material.dispose) material.dispose();\n            });\n          } else if (resource.material.dispose) {\n            resource.material.dispose();\n          }\n        }\n        break;\n        \n      case 'renderers':\n        if (resource.dispose) resource.dispose();\n        break;\n        \n      case 'shaders':\n        // Shaders might not have their own dispose method\n        // but may need special handling\n        break;\n        \n      default:\n        // For unknown types, try to call dispose if available\n        if (resource.dispose) resource.dispose();\n    }\n  }\n  \n  /**\n   * Reset a resource for pooling\n   * @private\n   */\n  _resetResourceForPooling(type, resource) {\n    switch (type) {\n      case 'geometries':\n        // For geometries, nothing special needed as they're generally immutable\n        break;\n        \n      case 'materials':\n        // Reset material properties to default values\n        if (resource.opacity !== undefined) resource.opacity = 1;\n        if (resource.transparent !== undefined) resource.transparent = false;\n        if (resource.depthTest !== undefined) resource.depthTest = true;\n        if (resource.needsUpdate !== undefined) resource.needsUpdate = true;\n        break;\n        \n      case 'meshes':\n        // Reset transformation\n        if (resource.position) resource.position.set(0, 0, 0);\n        if (resource.rotation) resource.rotation.set(0, 0, 0);\n        if (resource.scale) resource.scale.set(1, 1, 1);\n        if (resource.visible !== undefined) resource.visible = true;\n        break;\n    }\n  }\n  \n  /**\n   * Clean up all resources - call when shutting down\n   * @param {boolean} addToPool - Whether to pool resources instead of disposing\n   */\n  cleanup(addToPool = false) {\n    // Clean up resources by type\n    Object.keys(this.resources).forEach(type => {\n      // Convert to array to avoid modification during iteration\n      const resourceIds = Array.from(this.resources[type].keys());\n      \n      // Dispose each resource\n      resourceIds.forEach(id => {\n        this.disposeResource(type, id, addToPool);\n      });\n      \n      // Clear the map\n      this.resources[type].clear();\n    });\n    \n    // Clear ownership tracking\n    this.ownership.clear();\n    \n    // If not adding to pool, clear the pools\n    if (!addToPool) {\n      Object.keys(this.pools).forEach(type => {\n        this.pools[type].forEach(resources => {\n          resources.forEach(resource => {\n            this._disposeByType(type, resource);\n          });\n        });\n        this.pools[type].clear();\n      });\n    }\n  }\n}\n\n// Create singleton instance\nexport const resourceManager = new ResourceManager(); ","/**\n * TimerManager - Centralized timer management to prevent memory leaks and inefficient timer usage\n * \n * Provides:\n * - Centralized setTimeout and setInterval management\n * - Automatic cleanup of timers when components are destroyed\n * - Throttling and debouncing utilities\n * - RAF (requestAnimationFrame) management\n */\n\nexport class TimerManager {\n  constructor() {\n    // Store timers by group ID\n    this.timeouts = new Map();\n    this.intervals = new Map();\n    this.animationFrames = new Map();\n    this.debounceTimers = new Map();\n    this.throttleData = new Map();\n    \n    // For tracking which component owns which timer\n    this.groupOwnership = new Map();\n  }\n  \n  /**\n   * Create a setTimeout that is automatically tracked\n   * @param {string} groupId - ID to group related timers (usually component name)\n   * @param {Function} callback - Function to execute\n   * @param {number} delay - Delay in milliseconds\n   * @param {string} [timerId] - Optional ID for this specific timer\n   * @returns {string} Timer ID for reference\n   */\n  setTimeout(groupId, callback, delay, timerId = null) {\n    // Generate timer ID if not provided\n    const id = timerId || `timeout_${groupId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Create the timeout\n    const timeoutId = setTimeout(() => {\n      // Execute callback\n      callback();\n      // Remove from tracking when done\n      this.clearTimeout(groupId, id);\n    }, delay);\n    \n    // Store in the map\n    if (!this.timeouts.has(groupId)) {\n      this.timeouts.set(groupId, new Map());\n    }\n    this.timeouts.get(groupId).set(id, timeoutId);\n    \n    // Track ownership\n    this._trackOwnership(groupId);\n    \n    return id;\n  }\n  \n  /**\n   * Clear a specific timeout\n   * @param {string} groupId - Group ID\n   * @param {string} timerId - Timer ID\n   */\n  clearTimeout(groupId, timerId) {\n    if (this.timeouts.has(groupId) && this.timeouts.get(groupId).has(timerId)) {\n      clearTimeout(this.timeouts.get(groupId).get(timerId));\n      this.timeouts.get(groupId).delete(timerId);\n      \n      // Clean up the group if empty\n      if (this.timeouts.get(groupId).size === 0) {\n        this.timeouts.delete(groupId);\n      }\n    }\n  }\n  \n  /**\n   * Create a setInterval that is automatically tracked\n   * @param {string} groupId - ID to group related timers\n   * @param {Function} callback - Function to execute\n   * @param {number} delay - Interval in milliseconds\n   * @param {string} [timerId] - Optional ID for this specific timer\n   * @returns {string} Timer ID for reference\n   */\n  setInterval(groupId, callback, delay, timerId = null) {\n    // Generate timer ID if not provided\n    const id = timerId || `interval_${groupId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Create the interval\n    const intervalId = setInterval(callback, delay);\n    \n    // Store in the map\n    if (!this.intervals.has(groupId)) {\n      this.intervals.set(groupId, new Map());\n    }\n    this.intervals.get(groupId).set(id, intervalId);\n    \n    // Track ownership\n    this._trackOwnership(groupId);\n    \n    return id;\n  }\n  \n  /**\n   * Clear a specific interval\n   * @param {string} groupId - Group ID\n   * @param {string} timerId - Timer ID\n   */\n  clearInterval(groupId, timerId) {\n    if (this.intervals.has(groupId) && this.intervals.get(groupId).has(timerId)) {\n      clearInterval(this.intervals.get(groupId).get(timerId));\n      this.intervals.get(groupId).delete(timerId);\n      \n      // Clean up the group if empty\n      if (this.intervals.get(groupId).size === 0) {\n        this.intervals.delete(groupId);\n      }\n    }\n  }\n  \n  /**\n   * Create a requestAnimationFrame that is automatically tracked\n   * @param {string} groupId - ID to group related timers\n   * @param {Function} callback - Animation frame callback\n   * @param {string} [timerId] - Optional ID for this specific timer\n   * @returns {string} Timer ID for reference\n   */\n  requestAnimationFrame(groupId, callback, timerId = null) {\n    // Generate timer ID if not provided\n    const id = timerId || `raf_${groupId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Set up recursive RAF call that maintains tracking\n    const rafCallback = (timestamp) => {\n      // If the timer is still being tracked\n      if (this.animationFrames.has(groupId) && this.animationFrames.get(groupId).has(id)) {\n        // Execute the callback\n        const result = callback(timestamp);\n        \n        // Continue the animation loop unless callback returned false\n        if (result !== false) {\n          const rafId = requestAnimationFrame(rafCallback);\n          this.animationFrames.get(groupId).set(id, rafId);\n        } else {\n          // Animation loop was explicitly stopped by callback\n          this.animationFrames.get(groupId).delete(id);\n          \n          // Clean up the group if empty\n          if (this.animationFrames.get(groupId).size === 0) {\n            this.animationFrames.delete(groupId);\n          }\n        }\n      }\n    };\n    \n    // Start the animation loop\n    const rafId = requestAnimationFrame(rafCallback);\n    \n    // Store in the map\n    if (!this.animationFrames.has(groupId)) {\n      this.animationFrames.set(groupId, new Map());\n    }\n    this.animationFrames.get(groupId).set(id, rafId);\n    \n    // Track ownership\n    this._trackOwnership(groupId);\n    \n    return id;\n  }\n  \n  /**\n   * Cancel a requestAnimationFrame\n   * @param {string} groupId - Group ID\n   * @param {string} timerId - Timer ID\n   */\n  cancelAnimationFrame(groupId, timerId) {\n    if (this.animationFrames.has(groupId) && this.animationFrames.get(groupId).has(timerId)) {\n      cancelAnimationFrame(this.animationFrames.get(groupId).get(timerId));\n      this.animationFrames.get(groupId).delete(timerId);\n      \n      // Clean up the group if empty\n      if (this.animationFrames.get(groupId).size === 0) {\n        this.animationFrames.delete(groupId);\n      }\n    }\n  }\n  \n  /**\n   * Debounce a function call\n   * @param {string} groupId - Group ID\n   * @param {string} functionId - Function identifier\n   * @param {Function} callback - Function to debounce\n   * @param {number} delay - Debounce delay in milliseconds\n   */\n  debounce(groupId, functionId, callback, delay) {\n    // Clear existing timer if any\n    this._clearDebounceTimer(groupId, functionId);\n    \n    // Create new debounce timer\n    const timerId = this.setTimeout(groupId, callback, delay, `debounce_${functionId}`);\n    \n    // Store for tracking\n    if (!this.debounceTimers.has(groupId)) {\n      this.debounceTimers.set(groupId, new Map());\n    }\n    this.debounceTimers.get(groupId).set(functionId, timerId);\n    \n    // Track ownership\n    this._trackOwnership(groupId);\n  }\n  \n  /**\n   * Throttle a function call\n   * @param {string} groupId - Group ID\n   * @param {string} functionId - Function identifier\n   * @param {Function} callback - Function to throttle\n   * @param {number} limit - Throttle limit in milliseconds\n   * @returns {boolean} Whether the function was executed\n   */\n  throttle(groupId, functionId, callback, limit) {\n    // Track ownership\n    this._trackOwnership(groupId);\n    \n    // Initialize throttle data for this group if needed\n    if (!this.throttleData.has(groupId)) {\n      this.throttleData.set(groupId, new Map());\n    }\n    \n    const now = Date.now();\n    \n    // Get last execution time\n    const throttleInfo = this.throttleData.get(groupId).get(functionId);\n    const lastExecution = throttleInfo ? throttleInfo.lastExecution : 0;\n    \n    // Check if we can execute\n    if (!lastExecution || now - lastExecution >= limit) {\n      // Execute callback\n      callback();\n      \n      // Update last execution time\n      this.throttleData.get(groupId).set(functionId, { \n        lastExecution: now\n      });\n      \n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Clear all timers for a specific group\n   * @param {string} groupId - Group ID to clear\n   */\n  clearGroup(groupId) {\n    // Clear all timeouts for this group\n    if (this.timeouts.has(groupId)) {\n      const timeouts = this.timeouts.get(groupId);\n      timeouts.forEach(timeoutId => clearTimeout(timeoutId));\n      this.timeouts.delete(groupId);\n    }\n    \n    // Clear all intervals for this group\n    if (this.intervals.has(groupId)) {\n      const intervals = this.intervals.get(groupId);\n      intervals.forEach(intervalId => clearInterval(intervalId));\n      this.intervals.delete(groupId);\n    }\n    \n    // Clear all animation frames for this group\n    if (this.animationFrames.has(groupId)) {\n      const frames = this.animationFrames.get(groupId);\n      frames.forEach(frameId => cancelAnimationFrame(frameId));\n      this.animationFrames.delete(groupId);\n    }\n    \n    // Clear debounce timers\n    if (this.debounceTimers.has(groupId)) {\n      this.debounceTimers.delete(groupId);\n    }\n    \n    // Clear throttle data\n    if (this.throttleData.has(groupId)) {\n      this.throttleData.delete(groupId);\n    }\n    \n    // Remove from ownership tracking\n    this.groupOwnership.delete(groupId);\n  }\n  \n  /**\n   * Helper to clear a debounce timer\n   * @private\n   */\n  _clearDebounceTimer(groupId, functionId) {\n    if (this.debounceTimers.has(groupId) && \n        this.debounceTimers.get(groupId).has(functionId)) {\n      const timerId = this.debounceTimers.get(groupId).get(functionId);\n      this.clearTimeout(groupId, timerId);\n      this.debounceTimers.get(groupId).delete(functionId);\n      \n      // Clean up if empty\n      if (this.debounceTimers.get(groupId).size === 0) {\n        this.debounceTimers.delete(groupId);\n      }\n    }\n  }\n  \n  /**\n   * Track which components own which timer groups\n   * @private\n   */\n  _trackOwnership(groupId) {\n    // Just ensure the group is in the ownership map\n    if (!this.groupOwnership.has(groupId)) {\n      this.groupOwnership.set(groupId, true);\n    }\n  }\n  \n  /**\n   * Register a component with the timer manager\n   * @param {string} componentId - Unique component ID\n   * @param {Object} component - Component instance\n   */\n  registerComponent(componentId, component) {\n    // This could be expanded to add additional functionality\n    this._trackOwnership(componentId);\n  }\n  \n  /**\n   * Clean up all timers\n   */\n  cleanup() {\n    // Clear all groups\n    this.groupOwnership.forEach((_, groupId) => {\n      this.clearGroup(groupId);\n    });\n    \n    // Reset all maps\n    this.timeouts.clear();\n    this.intervals.clear();\n    this.animationFrames.clear();\n    this.debounceTimers.clear();\n    this.throttleData.clear();\n    this.groupOwnership.clear();\n  }\n}\n\n// Create singleton instance\nexport const timerManager = new TimerManager(); ","/**\n * EventManager - Centralized event handling system\n * \n * Provides:\n * - Automatic tracking of event listeners\n * - Proper cleanup to prevent memory leaks\n * - Throttling and debouncing for event handlers\n * - Event delegation for efficient DOM event handling\n */\nimport { timerManager } from './TimerManager.js';\n\nexport class EventManager {\n  constructor() {\n    this.listeners = new Map();\n    this.delegatedListeners = new Map();\n    this.componentListeners = new Map();\n    \n    // Bind methods that are used as callbacks\n    this._handleDelegatedEvent = this._handleDelegatedEvent.bind(this);\n  }\n  \n  /**\n   * Add an event listener with automatic tracking\n   * @param {EventTarget} target - DOM element or other event target\n   * @param {string} eventType - Event type (e.g., 'click')\n   * @param {Function} handler - Event handler function\n   * @param {Object} options - addEventListener options\n   * @param {string} componentId - ID of the component that owns this listener\n   * @returns {Object} Reference object for removing the listener\n   */\n  addEventListener(target, eventType, handler, options = {}, componentId = 'global') {\n    if (!target || !target.addEventListener) {\n      // Skip warning, only log errors\n      return null;\n    }\n    \n    // Create the bound handler that will be used\n    const boundHandler = handler.bind(target);\n    \n    // Add the event listener\n    target.addEventListener(eventType, boundHandler, options);\n    \n    // Store for tracking\n    const listenerRef = { target, eventType, originalHandler: handler, boundHandler, options };\n    \n    // Initialize maps if needed\n    if (!this.listeners.has(componentId)) {\n      this.listeners.set(componentId, []);\n    }\n    \n    // Store the listener reference\n    this.listeners.get(componentId).push(listenerRef);\n    \n    // Also track by component for easy cleanup\n    if (!this.componentListeners.has(componentId)) {\n      this.componentListeners.set(componentId, new Set());\n    }\n    this.componentListeners.get(componentId).add(listenerRef);\n    \n    // Return reference for manual removal if needed\n    return listenerRef;\n  }\n  \n  /**\n   * Remove a specific event listener\n   * @param {Object} listenerRef - Reference returned by addEventListener\n   * @param {string} componentId - Component ID\n   */\n  removeEventListener(listenerRef, componentId = 'global') {\n    if (!listenerRef || !listenerRef.target) return;\n    \n    // Remove the actual event listener\n    listenerRef.target.removeEventListener(\n      listenerRef.eventType,\n      listenerRef.boundHandler,\n      listenerRef.options\n    );\n    \n    // Remove from component listeners\n    if (componentId && this.componentListeners.has(componentId)) {\n      this.componentListeners.get(componentId).delete(listenerRef);\n      \n      // Clean up if empty\n      if (this.componentListeners.get(componentId).size === 0) {\n        this.componentListeners.delete(componentId);\n      }\n    }\n    \n    // Remove from main listeners tracking\n    if (this.listeners.has(componentId)) {\n      const index = this.listeners.get(componentId).indexOf(listenerRef);\n      if (index !== -1) {\n        this.listeners.get(componentId).splice(index, 1);\n      }\n      \n      // Clean up if empty\n      if (this.listeners.get(componentId).length === 0) {\n        this.listeners.delete(componentId);\n      }\n    }\n  }\n  \n  /**\n   * Add a throttled event listener\n   * @param {EventTarget} target - DOM element\n   * @param {string} eventType - Event type\n   * @param {Function} handler - Event handler\n   * @param {number} limit - Throttle limit in ms\n   * @param {Object} options - addEventListener options\n   * @param {string} componentId - Component ID\n   * @returns {Object} Listener reference\n   */\n  addThrottledEventListener(target, eventType, handler, limit, options = {}, componentId = 'global') {\n    // Create unique ID for this handler\n    const handlerId = `${componentId}_${eventType}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Create throttled handler\n    const throttledHandler = (event) => {\n      timerManager.throttle(componentId, handlerId, () => {\n        handler.call(target, event);\n      }, limit);\n    };\n    \n    // Add event listener with throttled handler\n    return this.addEventListener(target, eventType, throttledHandler, options, componentId);\n  }\n  \n  /**\n   * Add a debounced event listener\n   * @param {EventTarget} target - DOM element\n   * @param {string} eventType - Event type\n   * @param {Function} handler - Event handler\n   * @param {number} delay - Debounce delay in ms\n   * @param {Object} options - addEventListener options\n   * @param {string} componentId - Component ID\n   * @returns {Object} Listener reference\n   */\n  addDebouncedEventListener(target, eventType, handler, delay, options = {}, componentId = 'global') {\n    // Create unique ID for this handler\n    const handlerId = `${componentId}_${eventType}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Create debounced handler\n    const debouncedHandler = (event) => {\n      // Store event data for use in the debounced callback\n      const eventData = {\n        type: event.type,\n        target: event.target,\n        currentTarget: event.currentTarget,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        // Any other properties you typically need\n      };\n      \n      timerManager.debounce(componentId, handlerId, () => {\n        // Call the handler with the stored event data\n        handler.call(target, { ...event, eventData });\n      }, delay);\n    };\n    \n    // Add event listener with debounced handler\n    return this.addEventListener(target, eventType, debouncedHandler, options, componentId);\n  }\n  \n  /**\n   * Set up event delegation for efficiently handling events on multiple elements\n   * @param {EventTarget} container - Container element\n   * @param {string} eventType - Event type\n   * @param {string} selector - CSS selector for target elements\n   * @param {Function} handler - Event handler\n   * @param {string} componentId - Component ID\n   * @returns {Object} Delegation reference\n   */\n  delegate(container, eventType, selector, handler, componentId = 'global') {\n    // Initialize delegation maps if needed\n    if (!this.delegatedListeners.has(eventType)) {\n      this.delegatedListeners.set(eventType, new Map());\n      \n      // Set up the global handler for this event type\n      document.addEventListener(eventType, (event) => {\n        this._handleDelegatedEvent(eventType, event);\n      });\n    }\n    \n    // Generate a unique ID for this delegation\n    const delegationId = `${componentId}_${selector}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Store the delegation\n    this.delegatedListeners.get(eventType).set(delegationId, {\n      container, \n      selector, \n      handler, \n      componentId\n    });\n    \n    // Return reference for removal\n    return { eventType, delegationId };\n  }\n  \n  /**\n   * Internal handler for delegated events\n   * @private\n   */\n  _handleDelegatedEvent(eventType, event) {\n    if (!this.delegatedListeners.has(eventType)) return;\n    \n    this.delegatedListeners.get(eventType).forEach((delegation, delegationId) => {\n      const { container, selector, handler } = delegation;\n      \n      // Check if the event target matches the selector and is within the container\n      if (event.target.matches(selector) && container.contains(event.target)) {\n        handler.call(container, event);\n      }\n    });\n  }\n  \n  /**\n   * Remove a delegated event handler\n   * @param {Object} delegationRef - Reference returned by delegate\n   */\n  undelegate(delegationRef) {\n    if (!delegationRef || !delegationRef.eventType || !delegationRef.delegationId) return;\n    \n    if (this.delegatedListeners.has(delegationRef.eventType)) {\n      this.delegatedListeners.get(delegationRef.eventType).delete(delegationRef.delegationId);\n      \n      // Clean up if no more delegations for this event type\n      if (this.delegatedListeners.get(delegationRef.eventType).size === 0) {\n        document.removeEventListener(delegationRef.eventType, (event) => {\n          this._handleDelegatedEvent(delegationRef.eventType, event);\n        });\n        this.delegatedListeners.delete(delegationRef.eventType);\n      }\n    }\n  }\n  \n  /**\n   * Register a component with the event manager\n   * @param {string} componentId - Component ID\n   * @param {Object} component - Component instance\n   */\n  registerComponent(componentId, component) {\n    // This is mainly for tracking purposes\n    if (!this.componentListeners.has(componentId)) {\n      this.componentListeners.set(componentId, new Set());\n    }\n  }\n  \n  /**\n   * Clean up all event listeners for a component\n   * @param {string} componentId - Component ID\n   */\n  cleanupComponent(componentId) {\n    // Remove all event listeners for this component\n    if (this.componentListeners.has(componentId)) {\n      const listeners = this.componentListeners.get(componentId);\n      listeners.forEach(listenerRef => {\n        if (listenerRef.target) {\n          listenerRef.target.removeEventListener(\n            listenerRef.eventType, \n            listenerRef.boundHandler,\n            listenerRef.options\n          );\n        }\n      });\n      \n      this.componentListeners.delete(componentId);\n    }\n    \n    // Remove from main listeners tracking\n    if (this.listeners.has(componentId)) {\n      this.listeners.delete(componentId);\n    }\n    \n    // Clean up delegations\n    this.delegatedListeners.forEach((delegations, eventType) => {\n      // Create array of delegationIds to remove\n      const toRemove = [];\n      delegations.forEach((delegation, delegationId) => {\n        if (delegation.componentId === componentId) {\n          toRemove.push({ eventType, delegationId });\n        }\n      });\n      \n      // Remove the identified delegations\n      toRemove.forEach(ref => this.undelegate(ref));\n    });\n  }\n  \n  /**\n   * Clean up all event listeners\n   */\n  cleanup() {\n    // Clean up all normal event listeners\n    this.listeners.forEach((listeners, componentId) => {\n      listeners.forEach(listenerRef => {\n        if (listenerRef.target) {\n          listenerRef.target.removeEventListener(\n            listenerRef.eventType, \n            listenerRef.boundHandler,\n            listenerRef.options\n          );\n        }\n      });\n    });\n    \n    // Clean up all delegated listeners\n    this.delegatedListeners.forEach((delegations, eventType) => {\n      // Remove the global handler for this event type\n      document.removeEventListener(eventType, (event) => {\n        this._handleDelegatedEvent(eventType, event);\n      });\n    });\n    \n    // Clear all tracking\n    this.listeners.clear();\n    this.delegatedListeners.clear();\n    this.componentListeners.clear();\n  }\n}\n\n// Create singleton instance\nexport const eventManager = new EventManager(); ","/**\n * StateManager - Handles application state and component communication\n * \n * This class replaces the global window properties with a proper state management system\n * that uses pub/sub pattern for component communication\n */\nexport class StateManager {\n  constructor() {\n    this.state = {};\n    this.listeners = {};\n    this.components = {};\n  }\n  \n  /**\n   * Set a state value and notify subscribers\n   * @param {string} key - The state key\n   * @param {any} value - The new value\n   */\n  setState(key, value) {\n    this.state[key] = value;\n    if (this.listeners[key]) {\n      this.listeners[key].forEach(callback => callback(value));\n    }\n  }\n  \n  /**\n   * Get a state value\n   * @param {string} key - The state key \n   * @returns {any} The state value\n   */\n  getState(key) {\n    return this.state[key];\n  }\n  \n  /**\n   * Subscribe to state changes\n   * @param {string} key - The state key to watch\n   * @param {Function} callback - Function to call when state changes\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(key, callback) {\n    if (!this.listeners[key]) this.listeners[key] = [];\n    this.listeners[key].push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.listeners[key] = this.listeners[key].filter(cb => cb !== callback);\n    };\n  }\n  \n  /**\n   * Register a component for lookup by other components\n   * @param {string} name - Component name\n   * @param {object} component - Component instance\n   */\n  registerComponent(name, component) {\n    this.components[name] = component;\n  }\n  \n  /**\n   * Get a registered component\n   * @param {string} name - Component name\n   * @returns {object} Component instance\n   */\n  getComponent(name) {\n    return this.components[name];\n  }\n  \n  /**\n   * Call a method on a registered component\n   * @param {string} componentName - Component name\n   * @param {string} methodName - Method name\n   * @param {...any} args - Arguments to pass\n   * @returns {any} Method return value\n   */\n  callComponentMethod(componentName, methodName, ...args) {\n    const component = this.getComponent(componentName);\n    if (!component) return null;\n    \n    if (typeof component[methodName] === 'function') {\n      return component[methodName](...args);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Dispatch an event to the system\n   * @param {string} eventName - Event name\n   * @param {object} data - Event data\n   */\n  dispatchEvent(eventName, data = {}) {\n    const key = `event:${eventName}`;\n    this.setState(key, data);\n  }\n  \n  /**\n   * Subscribe to an event\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    return this.subscribe(`event:${eventName}`, callback);\n  }\n}\n\n// Create a single instance to be imported by all components\nexport const stateManager = new StateManager(); ","/**\n * ReactiveManager - Handles reactive updates to replace polling mechanisms\n * \n * This class provides event-driven alternatives to setInterval polling\n */\nimport { stateManager } from './StateManager.js';\n\nexport class ReactiveManager {\n  constructor() {\n    this.observers = {};\n    this.activeTimers = {};\n    this.mutationObservers = {};\n    this.resizeObservers = {};\n    this.canvasNeedsUpdate = false;\n    this.animationFrameRequested = false;\n    \n    // Bind methods to preserve 'this' context\n    this.requestRender = this.requestRender.bind(this);\n    this.markCanvasForUpdate = this.markCanvasForUpdate.bind(this);\n  }\n  \n  /**\n   * Initialize reactive updates\n   */\n  initialize() {\n    // Initialize canvas rendering loop\n    this.startRenderLoop();\n    \n    // Setup responsive layout observers\n    this.setupResponsiveObservers();\n    \n    // Setup DOM change detection \n    this.setupDomObservers();\n  }\n  \n  /**\n   * Set up responsive layout observers\n   */\n  setupResponsiveObservers() {\n    // Mobile view updates via ResizeObserver instead of polling\n    const bodyResizeObserver = new ResizeObserver(entries => {\n      const isMobile = window.innerWidth < 1024;\n      \n      // Dispatch an event when layout changes\n      if (stateManager.getState('isMobile') !== isMobile) {\n        stateManager.setState('isMobile', isMobile);\n        stateManager.dispatchEvent('layoutChanged', { isMobile });\n      }\n      \n      // Update mobile UI if needed\n      if (isMobile) {\n        const uiManager = stateManager.getComponent('uiManager');\n        if (uiManager && typeof uiManager.updateSynthPanelMobileView === 'function') {\n          uiManager.updateSynthPanelMobileView();\n        }\n      }\n    });\n    \n    // Observe the body for size changes\n    bodyResizeObserver.observe(document.body);\n    this.resizeObservers.body = bodyResizeObserver;\n  }\n  \n  /**\n   * Creates a ResizeObserver to watch an element and call a callback when it resizes\n   * @param {Element} element - The DOM element to observe\n   * @param {string} id - Unique identifier for this observer\n   * @param {Function} callback - Function to call when resize occurs\n   * @returns {ResizeObserver} The created observer instance\n   */\n  observeResize(element, id, callback) {\n    // Check if element is valid\n    if (!element || !(element instanceof Element)) {\n      // Only logging errors, not warnings\n      return null;\n    }\n    \n    // Clean up any existing observer with the same ID\n    if (this.resizeObservers[id]) {\n      this.resizeObservers[id].disconnect();\n    }\n    \n    // Create a new ResizeObserver\n    try {\n      const observer = new ResizeObserver(entries => {\n        // Call the provided callback with the entries\n        callback(entries);\n      });\n      \n      // Start observing the element\n      observer.observe(element);\n      \n      // Store for cleanup\n      this.resizeObservers[id] = observer;\n      \n      return observer;\n    } catch (error) {\n      console.error('Error creating ResizeObserver:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Set up DOM mutation observers\n   */\n  setupDomObservers() {\n    // Watch for neuron grid changes\n    const gridContainer = document.getElementById('neuron-grid-container');\n    if (gridContainer) {\n      const gridObserver = new MutationObserver(mutations => {\n        stateManager.dispatchEvent('neuronGridChanged');\n      });\n      \n      gridObserver.observe(gridContainer, { \n        childList: true,\n        subtree: true,\n        attributes: true\n      });\n      \n      this.mutationObservers.grid = gridObserver;\n    }\n    \n    // Watch for preset selection changes\n    const presetContainer = document.querySelector('.preset-container');\n    if (presetContainer) {\n      const presetObserver = new MutationObserver(mutations => {\n        stateManager.dispatchEvent('presetChanged');\n      });\n      \n      presetObserver.observe(presetContainer, {\n        childList: true,\n        subtree: true,\n        attributes: true\n      });\n      \n      this.mutationObservers.presets = presetObserver;\n    }\n  }\n  \n  /**\n   * Start the render loop for canvas updates\n   */\n  startRenderLoop() {\n    // Define the update canvas function with proper binding\n    this.renderFunction = () => {\n      this.animationFrameRequested = false;\n      \n      if (this.canvasNeedsUpdate) {\n        // Find all canvases that need updates\n        const waveformCanvas = document.getElementById('waveform-canvas');\n        if (waveformCanvas) {\n          const renderEnvelope = stateManager.getComponent('soundManager')?.renderEnvelope;\n          if (typeof renderEnvelope === 'function') {\n            renderEnvelope(waveformCanvas);\n          }\n        }\n        \n        // Reset the flag\n        this.canvasNeedsUpdate = false;\n      }\n    };\n    \n    // Ensure the render function is properly bound to this instance\n    this.boundRenderFunction = this.renderFunction.bind(this);\n  }\n  \n  /**\n   * Request a render in the next animation frame\n   */\n  requestRender() {\n    if (!this.animationFrameRequested) {\n      this.animationFrameRequested = true;\n      // Use the bound function to ensure proper context\n      requestAnimationFrame(this.boundRenderFunction);\n    }\n  }\n  \n  /**\n   * Mark canvas as needing update\n   */\n  markCanvasForUpdate() {\n    this.canvasNeedsUpdate = true;\n    \n    // Check for sound manager's renderEnvelope before requesting render\n    const soundManager = stateManager.getComponent('soundManager');\n    if (soundManager && typeof soundManager.renderEnvelope === 'function') {\n      // Ensure we have a valid bound function before calling requestAnimationFrame\n      if (typeof this.boundRenderFunction === 'function') {\n        this.requestRender();\n      } else {\n        // Rebuild the function if it's missing\n        this.startRenderLoop();\n        this.requestRender();\n      }\n    } else {\n      // Fallback if soundManager isn't available yet\n      const waveformCanvas = document.getElementById('waveform-canvas');\n      if (waveformCanvas && window.renderEnvelope) {\n        window.renderEnvelope(waveformCanvas);\n      }\n    }\n  }\n  \n  /**\n   * Clean up all observers and timers\n   */\n  cleanup() {\n    // Stop all observers\n    Object.values(this.resizeObservers).forEach(observer => observer.disconnect());\n    Object.values(this.mutationObservers).forEach(observer => observer.disconnect());\n    \n    // Clear all timers\n    Object.values(this.activeTimers).forEach(timer => clearInterval(timer));\n  }\n}\n\n// Create a single instance to be imported by all components\nexport const reactiveManager = new ReactiveManager(); ","/**\n * NeuronGridManager - Efficiently manages the neuron grid display\n * \n * Uses:\n * - Element pooling instead of recreating elements\n * - CSS classes instead of inline styles\n * - Efficient updates by only changing what's necessary\n * - One-time event listener binding\n */\nimport { stateManager } from './StateManager.js';\nimport './neuron-grid.css';\n\nexport class NeuronGridManager {\n  constructor() {\n    this.container = null;\n    this.wrapper = null;\n    this.elementPool = []; // Pool of reusable DOM elements\n    this.activeElements = new Map(); // Map of neuron ID to active element\n    this.initialized = false;\n    \n    // Store bound event handlers to avoid recreating them\n    this.handleElementClick = this.handleElementClick.bind(this);\n    \n    // Register with state manager\n    if (stateManager) {\n      stateManager.registerComponent('neuronGridManager', this);\n    }\n    \n    // Make available globally for backward compatibility\n    window.updateNeuronGrid = this.update.bind(this);\n  }\n  \n  /**\n   * Initialize the grid display container\n   * @param {HTMLElement} parentElement - The parent element to attach the grid to\n   */\n  initialize(parentElement) {\n    if (this.initialized) return;\n    \n    // Find or create the container\n    this.container = document.getElementById('neuron-grid-container');\n    if (!this.container) {\n      this.container = document.createElement('div');\n      this.container.id = 'neuron-grid-container';\n      this.container.className = 'neuron-grid-container';\n      parentElement.appendChild(this.container);\n    } else {\n      // If container exists, make sure it has our class\n      this.container.className = 'neuron-grid-container';\n    }\n    \n    // Create grid wrapper\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = 'neuron-grid-wrapper';\n    this.container.appendChild(this.wrapper);\n    \n    // Ensure we have the neuronPulse animation defined only once\n    this.ensureAnimationStyleExists();\n    \n    this.initialized = true;\n  }\n  \n  /**\n   * Update the grid display\n   * @param {Array} neurons - The array of neurons to display\n   */\n  update(neurons = window.circles) {\n    if (!this.initialized || !this.container) {\n      // Try to initialize with the pane element if available\n      if (window.pane && window.pane.element) {\n        this.initialize(window.pane.element);\n      } else {\n        // Skip warning, only log errors\n        return;\n      }\n    }\n    \n    // Create a set of current neuron IDs for tracking\n    const currentNeuronIds = new Set();\n    \n    // Update existing neurons and create new elements as needed\n    neurons.forEach(circle => {\n      if (!circle || !circle.neuron) return;\n      \n      const neuronId = circle.neuron.id;\n      currentNeuronIds.add(neuronId);\n      \n      let element = this.activeElements.get(neuronId);\n      const isNewElement = !element;\n      \n      // Create or reuse an element\n      if (isNewElement) {\n        // Get element from pool or create new\n        element = this.elementPool.length > 0 \n          ? this.elementPool.pop() \n          : document.createElement('div');\n        \n        element.className = 'neuron-element';\n        element.dataset.neuronId = neuronId;\n        \n        // Only add event listeners to new elements\n        element.addEventListener('click', this.handleElementClick);\n        \n        // Store in active elements map\n        this.activeElements.set(neuronId, element);\n        \n        // Add to the DOM\n        this.wrapper.appendChild(element);\n      }\n      \n      // Update element appearance based on neuron state\n      this.updateElementAppearance(element, circle.neuron);\n    });\n    \n    // Remove elements for neurons that no longer exist\n    Array.from(this.activeElements.keys()).forEach(neuronId => {\n      if (!currentNeuronIds.has(neuronId)) {\n        const element = this.activeElements.get(neuronId);\n        \n        // Remove from DOM\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n        \n        // Clear any custom properties\n        element.className = 'neuron-element';\n        element.style = '';\n        element.title = '';\n        \n        // Return to pool\n        this.elementPool.push(element);\n        \n        // Remove from active elements\n        this.activeElements.delete(neuronId);\n      }\n    });\n  }\n  \n  /**\n   * Update the appearance of a neuron element\n   * @param {HTMLElement} element - The element to update\n   * @param {Object} neuron - The neuron data\n   */\n  updateElementAppearance(element, neuron) {\n    // Reset classes\n    element.className = 'neuron-element';\n    \n    // Calculate and set appearance based on neuron state\n    if (neuron.isFiring) {\n      // Firing state\n      element.classList.add('firing');\n      \n      // Update tooltip\n      if (neuron.presetName) {\n        element.title = `${neuron.presetName} (Neuron ${neuron.id}) - Firing!`;\n      } else {\n        element.title = `Neuron ${neuron.id} - Firing!`;\n      }\n    } else if (neuron.presetColor) {\n      // Has preset color\n      element.classList.add('has-preset');\n      \n      // Set color via CSS variables\n      const r = Math.floor(neuron.presetColor.r * 255);\n      const g = Math.floor(neuron.presetColor.g * 255);\n      const b = Math.floor(neuron.presetColor.b * 255);\n      \n      element.style.setProperty('--neuron-color-r', r);\n      element.style.setProperty('--neuron-color-g', g);\n      element.style.setProperty('--neuron-color-b', b);\n      element.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;\n      \n      // Update tooltip\n      element.title = `${neuron.presetName || ''} (Neuron ${neuron.id})`;\n      \n      // Add charging info to tooltip\n      if (neuron.currentCharge > 0) {\n        element.title += ` - Charging: ${Math.round(neuron.currentCharge * 100)}%`;\n      }\n      \n      // Add DC input info to tooltip\n      if (neuron.dcInput > 0) {\n        element.title += ` - DC: ${neuron.dcInput.toFixed(2)}`;\n        element.classList.add('has-dc');\n      }\n    } else {\n      // Default neuron\n      element.classList.add('default');\n      \n      // Set color based on charge\n      const chargeValue = neuron.currentCharge || 0;\n      const green = Math.floor(Math.min(0.2, chargeValue) * 255);\n      element.style.backgroundColor = `rgb(0, ${green}, 255)`;\n      \n      // Update tooltip\n      element.title = `Neuron ${neuron.id}`;\n      \n      // Add charging info to tooltip\n      if (neuron.currentCharge > 0) {\n        element.title += ` - Charging: ${Math.round(neuron.currentCharge * 100)}%`;\n      }\n      \n      // Add DC input info to tooltip\n      if (neuron.dcInput > 0) {\n        element.title += ` - DC: ${neuron.dcInput.toFixed(2)}`;\n        element.classList.add('has-dc');\n      }\n    }\n  }\n  \n  /**\n   * Handle click on a neuron element\n   * @param {Event} event - Click event\n   */\n  handleElementClick(event) {\n    const neuronId = event.currentTarget.dataset.neuronId;\n    if (!neuronId) return;\n    \n    // Find the neuron in the circles array\n    const neuron = window.circles.find(circle => \n      circle && circle.neuron && circle.neuron.id.toString() === neuronId\n    );\n    \n    // Select the neuron if found and inputManager exists\n    if (neuron && window.inputManager) {\n      window.inputManager.selectNeuron(neuron);\n    }\n  }\n  \n  /**\n   * Ensure animation style exists in the document\n   * Create it only once\n   */\n  ensureAnimationStyleExists() {\n    if (!document.getElementById('neuronPulseStyle')) {\n      // Already defined in the CSS file, no need to create dynamically\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // Remove all elements and clear pools\n    this.activeElements.forEach(element => {\n      element.removeEventListener('click', this.handleElementClick);\n      if (element.parentNode) {\n        element.parentNode.removeChild(element);\n      }\n    });\n    \n    this.elementPool.forEach(element => {\n      element.removeEventListener('click', this.handleElementClick);\n    });\n    \n    this.elementPool = [];\n    this.activeElements.clear();\n    \n    if (this.wrapper && this.wrapper.parentNode) {\n      this.wrapper.parentNode.removeChild(this.wrapper);\n    }\n    \n    this.wrapper = null;\n    this.initialized = false;\n  }\n}\n\n// Create a singleton instance to be imported by other components\nexport const neuronGridManager = new NeuronGridManager(); ","/**\n * Minimal logger implementation - only logs errors to console\n * All other log levels are no-ops to improve performance\n */\n\nconst Logger = {\n  error: (message, ...args) => console.error(message, ...args),\n  warn: () => {},  // No-op\n  info: () => {},  // No-op\n  debug: () => {}  // No-op\n};\n\nexport default Logger; ","/**\n * initManagers.js - Initialize all manager components in one import\n * \n * This file exports a function that initializes all manager components\n * and makes them available globally. It can be imported at the top of main.js\n * or any other entry point file.\n */\n\nimport { resourceManager } from './ResourceManager.js';\nimport { eventManager } from './EventManager.js';\nimport { timerManager } from './TimerManager.js';\nimport { stateManager } from './StateManager.js';\nimport { reactiveManager } from './ReactiveManager.js';\nimport { neuronGridManager } from './NeuronGridManager.js';\nimport Logger from './utils/logger.js';\n\n/**\n * Initialize all resource and event managers\n * Making them available globally and setting up initial state\n */\nexport function initializeManagers() {\n  Logger.debug('Initializing all resource and event managers...');\n  \n  // Make managers available globally\n  window.resourceManager = resourceManager;\n  window.eventManager = eventManager;\n  window.timerManager = timerManager;\n  window.stateManager = stateManager;\n  window.reactiveManager = reactiveManager;\n  window.neuronGridManager = neuronGridManager;\n  \n  // Set up global cleanup function\n  window.cleanupAllManagers = () => {\n    Logger.debug('Cleaning up all managers...');\n    \n    // Clean up in reverse order of dependencies\n    neuronGridManager.cleanup();\n    reactiveManager.cleanup();\n    eventManager.cleanup();\n    timerManager.cleanup();\n    resourceManager.cleanup();\n    \n    Logger.debug('All managers cleaned up.');\n  };\n  \n  // Register cleanup on page unload\n  window.addEventListener('beforeunload', window.cleanupAllManagers);\n  \n  Logger.info('All managers initialized and available globally.');\n  \n  return {\n    resourceManager,\n    eventManager,\n    timerManager,\n    stateManager,\n    reactiveManager,\n    neuronGridManager\n  };\n}\n\n// Auto-initialize when this file is imported if autoInit=true URL parameter is present\nconst urlParams = new URLSearchParams(window.location.search);\nif (urlParams.get('autoInit') === 'true') {\n  initializeManagers();\n}\n\n/**\n * Patch existing application code to use managers\n * This smooths the transition by redirecting commonly used methods\n * to their manager equivalents\n */\nexport function patchExistingCode() {\n  // Patch setTimeout/setInterval with timerManager\n  const originalSetTimeout = window.setTimeout;\n  const originalSetInterval = window.setInterval;\n  const originalClearTimeout = window.clearTimeout;\n  const originalClearInterval = window.clearInterval;\n  \n  // Store mapping between original timer IDs and manager timer IDs\n  const timeoutMap = new Map();\n  const intervalMap = new Map();\n  \n  // Replace global setTimeout\n  window.setTimeout = (callback, delay, ...args) => {\n    if (window.timerManager) {\n      const managerId = window.timerManager.setTimeout('global', () => {\n        callback(...args);\n      }, delay);\n      \n      // Create a fake ID for legacy code\n      const fakeId = Math.floor(Math.random() * 1000000000);\n      timeoutMap.set(fakeId, managerId);\n      return fakeId;\n    } else {\n      return originalSetTimeout(callback, delay, ...args);\n    }\n  };\n  \n  // Replace global setInterval\n  window.setInterval = (callback, delay, ...args) => {\n    if (window.timerManager) {\n      const managerId = window.timerManager.setInterval('global', () => {\n        callback(...args);\n      }, delay);\n      \n      // Create a fake ID for legacy code\n      const fakeId = Math.floor(Math.random() * 1000000000);\n      intervalMap.set(fakeId, managerId);\n      return fakeId;\n    } else {\n      return originalSetInterval(callback, delay, ...args);\n    }\n  };\n  \n  // Replace global clearTimeout\n  window.clearTimeout = (id) => {\n    if (window.timerManager && timeoutMap.has(id)) {\n      window.timerManager.clearTimeout('global', timeoutMap.get(id));\n      timeoutMap.delete(id);\n    } else {\n      originalClearTimeout(id);\n    }\n  };\n  \n  // Replace global clearInterval\n  window.clearInterval = (id) => {\n    if (window.timerManager && intervalMap.has(id)) {\n      window.timerManager.clearInterval('global', intervalMap.get(id));\n      intervalMap.delete(id);\n    } else {\n      originalClearInterval(id);\n    }\n  };\n  \n  Logger.debug('Patched existing code to use managers.');\n}\n\n// Export function to restore original methods\nexport function restoreOriginalCode() {\n  if (window._originalSetTimeout) window.setTimeout = window._originalSetTimeout;\n  if (window._originalSetInterval) window.setInterval = window._originalSetInterval;\n  if (window._originalClearTimeout) window.clearTimeout = window._originalClearTimeout;\n  if (window._originalClearInterval) window.clearInterval = window._originalClearInterval;\n  \n  Logger.debug('Restored original methods.');\n} ","import * as THREE from 'three';\n\n/**\n * TimerManager - Efficient and robust timer management for neuron simulations\n * Prevents timer loss during heavy operations and animation frame conflicts\n */\nexport class TimerManager {\n  constructor() {\n    // Callback registries\n    this.rafCallbacks = new Map();\n    this.intervalCallbacks = new Map();\n    this.timeoutCallbacks = new Map();\n    \n    // Tracking\n    this.isRunning = false;\n    this.frameId = null;\n    this.lastFrameTime = 0;\n    this.frameDelta = 0;\n    this.frameCount = 0;\n    \n    // Performance monitoring\n    this.frameRates = [];\n    this.averageFrameRate = 60;\n    this.frameRateHistory = 60;\n    this.lastPerformanceReport = 0;\n    this.performanceReportInterval = 5000; // Report every 5 seconds in console\n    \n    // Start the manager\n    this.start();\n  }\n  \n  /**\n   * Start the animation loop\n   */\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    this.lastFrameTime = performance.now();\n    this.frameId = requestAnimationFrame(this.update.bind(this));\n  }\n  \n  /**\n   * Stop the animation loop\n   */\n  stop() {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    if (this.frameId) {\n      cancelAnimationFrame(this.frameId);\n      this.frameId = null;\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // First stop the animation loop\n    this.stop();\n    \n    // Clear all timers\n    for (const [id, _] of this.timeoutCallbacks.entries()) {\n      clearTimeout(id);\n    }\n    this.timeoutCallbacks.clear();\n    \n    for (const [id, _] of this.intervalCallbacks.entries()) {\n      clearInterval(id);\n    }\n    this.intervalCallbacks.clear();\n    \n    // Clear all RAF callbacks\n    this.rafCallbacks.clear();\n  }\n  \n  /**\n   * Main update loop - processes all callbacks\n   */\n  update(timestamp) {\n    if (!this.isRunning) return;\n    \n    // Calculate delta time\n    this.frameDelta = timestamp - this.lastFrameTime;\n    this.lastFrameTime = timestamp;\n    this.frameCount++;\n    \n    // Track performance\n    this.frameRates.push(1000 / this.frameDelta);\n    if (this.frameRates.length > this.frameRateHistory) {\n      this.frameRates.shift();\n    }\n    \n    // Calculate average frame rate\n    if (this.frameRates.length > 0) {\n      this.averageFrameRate = this.frameRates.reduce((sum, rate) => sum + rate, 0) / this.frameRates.length;\n    }\n    \n    // Process all requestAnimationFrame callbacks\n    for (const [id, callback] of this.rafCallbacks.entries()) {\n      try {\n        // If callback returns false, remove it\n        if (callback(timestamp) === false) {\n          this.rafCallbacks.delete(id);\n        }\n      } catch (error) {\n        console.error(`[TimerManager] Error in RAF callback ${id}:`, error);\n        // Remove problematic callback\n        this.rafCallbacks.delete(id);\n      }\n    }\n    \n    // Continue the loop\n    this.frameId = requestAnimationFrame(this.update.bind(this));\n  }\n  \n  /**\n   * Register a requestAnimationFrame callback\n   * @param {string} id - Unique identifier for the callback\n   * @param {Function} callback - Function to call each frame\n   * @returns {string} The ID of the registered callback\n   */\n  requestAnimationFrame(id, callback) {\n    // Generate a unique ID if not provided\n    const callbackId = id || `raf_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Store the callback\n    this.rafCallbacks.set(callbackId, callback);\n    \n    return callbackId;\n  }\n  \n  /**\n   * Cancel a requestAnimationFrame callback\n   * @param {string} id - Identifier for the callback to cancel\n   * @param {string} callbackId - The specific callback ID to cancel\n   */\n  cancelAnimationFrame(id, callbackId) {\n    // If specific callbackId provided, use that\n    const targetId = callbackId || id;\n    \n    // Remove the callback\n    if (this.rafCallbacks.has(targetId)) {\n      this.rafCallbacks.delete(targetId);\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Set a timeout that's tracked by the manager\n   * @param {string} group - Optional group identifier\n   * @param {Function} callback - Function to call\n   * @param {number} delay - Delay in milliseconds\n   * @returns {number} Timeout ID\n   */\n  setTimeout(group, callback, delay) {\n    const timeoutId = setTimeout(() => {\n      // Execute callback\n      try {\n        callback();\n      } catch (error) {\n        console.error(`[TimerManager] Error in timeout callback (${group}):`, error);\n      }\n      \n      // Remove from tracking\n      this.timeoutCallbacks.delete(timeoutId);\n    }, delay);\n    \n    // Store for tracking/cleanup\n    this.timeoutCallbacks.set(timeoutId, { group });\n    \n    return timeoutId;\n  }\n  \n  /**\n   * Clear a timeout\n   * @param {number} timeoutId - The timeout ID to clear\n   */\n  clearTimeout(group, timeoutId) {\n    if (this.timeoutCallbacks.has(timeoutId)) {\n      clearTimeout(timeoutId);\n      this.timeoutCallbacks.delete(timeoutId);\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Set an interval that's tracked by the manager\n   * @param {string} group - Optional group identifier\n   * @param {Function} callback - Function to call\n   * @param {number} delay - Delay in milliseconds\n   * @returns {number} Interval ID\n   */\n  setInterval(group, callback, delay) {\n    const intervalId = setInterval(() => {\n      // Execute callback\n      try {\n        callback();\n      } catch (error) {\n        console.error(`[TimerManager] Error in interval callback (${group}):`, error);\n      }\n    }, delay);\n    \n    // Store for tracking/cleanup\n    this.intervalCallbacks.set(intervalId, { group });\n    \n    return intervalId;\n  }\n  \n  /**\n   * Clear an interval\n   * @param {number} intervalId - The interval ID to clear\n   */\n  clearInterval(group, intervalId) {\n    if (this.intervalCallbacks.has(intervalId)) {\n      clearInterval(intervalId);\n      this.intervalCallbacks.delete(intervalId);\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Clear all timers in a group\n   * @param {string} group - Group identifier\n   */\n  clearGroup(group) {\n    // Clear timeouts in this group\n    for (const [id, info] of this.timeoutCallbacks.entries()) {\n      if (info.group === group) {\n        clearTimeout(id);\n        this.timeoutCallbacks.delete(id);\n      }\n    }\n    \n    // Clear intervals in this group\n    for (const [id, info] of this.intervalCallbacks.entries()) {\n      if (info.group === group) {\n        clearInterval(id);\n        this.intervalCallbacks.delete(id);\n      }\n    }\n    \n    // Clear RAF callbacks in this group\n    for (const [id, _] of this.rafCallbacks.entries()) {\n      if (id.startsWith(`${group}_`)) {\n        this.rafCallbacks.delete(id);\n      }\n    }\n  }\n  \n  /**\n   * Throttle a function to only execute once per limit period\n   * @param {string} group - Group identifier\n   * @param {string} id - Throttle ID\n   * @param {Function} fn - Function to throttle\n   * @param {number} limit - Throttle limit in ms\n   */\n  throttle(group, id, fn, limit) {\n    const throttleKey = `${group}_throttle_${id}`;\n    \n    // Check if we're still in throttle period\n    if (this.timeoutCallbacks.has(throttleKey)) {\n      return;\n    }\n    \n    // Execute function\n    fn();\n    \n    // Set up throttle period\n    this.setTimeout(group, () => {}, limit, throttleKey);\n  }\n  \n  /**\n   * Debounce a function to only execute after quiet period\n   * @param {string} group - Group identifier\n   * @param {string} id - Debounce ID\n   * @param {Function} fn - Function to debounce\n   * @param {number} wait - Debounce wait in ms\n   */\n  debounce(group, id, fn, wait) {\n    const debounceKey = `${group}_debounce_${id}`;\n    \n    // Clear any existing timeout\n    if (this.timeoutCallbacks.has(debounceKey)) {\n      this.clearTimeout(group, debounceKey);\n    }\n    \n    // Set up new timeout\n    this.setTimeout(group, fn, wait, debounceKey);\n  }\n  \n  /**\n   * Get performance metrics\n   */\n  getPerformanceMetrics() {\n    return {\n      frameRate: this.averageFrameRate,\n      activeTasks: {\n        raf: this.rafCallbacks.size,\n        interval: this.intervalCallbacks.size,\n        timeout: this.timeoutCallbacks.size\n      }\n    };\n  }\n}\n\n// Initialize and make available as a singleton\nexport const initTimerManager = () => {\n  if (window.timerManager) {\n    try {\n      window.timerManager.cleanup();\n    } catch (error) {\n      console.error('[TimerManager] Error cleaning up old timer manager:', error);\n    }\n  }\n  \n  // Create new instance\n  window.timerManager = new TimerManager();\n  return window.timerManager;\n};\n\n// Export the singleton instance for module imports\nexport const timerManager = window.timerManager || new TimerManager(); ","import { TimerManager } from './TimerManager';\n\n/**\n * Initialize system managers required for optimal SNN simulation\n * This ensures TimerManager and other core services are available \n * before the simulation starts\n */\nexport function initSystemManagers() {\n  // Create and expose the global timer manager\n  if (!window.timerManager) {\n    window.timerManager = new TimerManager();\n  }\n  \n  return {\n    timerManager: window.timerManager\n  };\n}\n\n// Create a function to check if the necessary managers are available\nexport function ensureManagersInitialized() {\n  if (!window.timerManager) {\n    return initSystemManagers();\n  }\n  return {\n    timerManager: window.timerManager\n  };\n} ","/**\n * NeuronEngine - Central neural simulation system\n * \n * Manages all neuron updates within a single, centralized loop.\n * Replaces individual neuron timers with a synchronous update system.\n */\n\nclass NeuronEngine {\n  constructor() {\n    // Core simulation properties\n    this.neurons = new Map(); // Map of id -> neuron data\n    this.connections = new Map(); // Map of sourceId_targetId -> connection data\n    \n    // Simulation timing\n    this.isRunning = false;\n    this.updateInterval = 16; // ~60fps (ms)\n    this.updateTimerId = null;\n    this.lastUpdateTime = 0;\n    this.deltaTime = 0;\n    \n    // Performance monitoring\n    this.frameCount = 0;\n    this.startTime = 0;\n    this.fps = 60;\n    this.isPaused = false;\n    \n    // System callbacks\n    this.onEffectNeeded = null; // Called when visual effects should be created\n    this.onSoundNeeded = null; // Called when neuron sounds should be played\n    this.onUpdate = null; // Called after each update cycle\n    \n    // Internal constants\n    this.THRESHOLD = 1.0; // Default firing threshold\n    \n    // Bind methods\n    this._update = this._update.bind(this);\n  }\n  \n  /**\n   * Initialize the engine\n   * @param {Object} options Configuration options\n   */\n  initialize(options = {}) {\n    this.updateInterval = options.updateInterval || 16;\n    this.onEffectNeeded = options.onEffectNeeded;\n    this.onSoundNeeded = options.onSoundNeeded;\n    this.onUpdate = options.onUpdate;\n    \n    return this;\n  }\n  \n  /**\n   * Start the simulation\n   */\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    this.isPaused = false;\n    this.startTime = performance.now();\n    this.lastUpdateTime = this.startTime;\n    \n    // Use requestAnimationFrame for better timing\n    this.updateTimerId = requestAnimationFrame(this._update);\n    \n    return this;\n  }\n  \n  /**\n   * Pause the simulation\n   */\n  pause() {\n    this.isPaused = true;\n    return this;\n  }\n  \n  /**\n   * Resume the simulation\n   */\n  resume() {\n    this.isPaused = false;\n    return this;\n  }\n  \n  /**\n   * Stop the simulation\n   */\n  stop() {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    this.isPaused = false;\n    \n    if (this.updateTimerId) {\n      cancelAnimationFrame(this.updateTimerId);\n      this.updateTimerId = null;\n    }\n    \n    return this;\n  }\n  \n  /**\n   * Main update loop - processes all neurons\n   * @private\n   */\n  _update(timestamp) {\n    if (!this.isRunning) return;\n    \n    // Calculate delta time\n    this.deltaTime = timestamp - this.lastUpdateTime;\n    this.lastUpdateTime = timestamp;\n    \n    // Update FPS counter\n    this.frameCount++;\n    if (this.frameCount >= 30) {\n      const elapsed = (timestamp - this.startTime) / 1000;\n      this.fps = Math.round(this.frameCount / elapsed);\n      this.frameCount = 0;\n      this.startTime = timestamp;\n    }\n    \n    // Skip update if paused\n    if (!this.isPaused) {\n      // Update all neurons\n      this._updateNeurons(this.deltaTime);\n      \n      // Process any neurons that should fire\n      this._processFiringNeurons();\n      \n      // Call onUpdate callback if provided\n      if (typeof this.onUpdate === 'function') {\n        this.onUpdate(timestamp, this.deltaTime, this.fps);\n      }\n    }\n    \n    // Continue the update loop\n    this.updateTimerId = requestAnimationFrame(this._update);\n  }\n  \n  /**\n   * Update all neurons in the simulation\n   * @param {number} deltaTime Time since last update in ms\n   * @private\n   */\n  _updateNeurons(deltaTime) {\n    // Convert deltaTime to seconds for charge calculations\n    const dt = deltaTime / 1000;\n    \n    // Process each neuron\n    for (const [id, neuron] of this.neurons) {\n      // Skip processing deleted neurons\n      if (!neuron) continue;\n      \n      // If neuron has DC input and isn't in refractory period or firing, accumulate charge\n      if (neuron.dcInput > 0 && !neuron.isFiring) {\n        // Calculate charge increment based on DC input value\n        // Reduced for more subtle control at low DC values\n        const chargeIncrement = dt * neuron.dcInput * 5;\n        neuron.currentCharge += chargeIncrement;\n        \n        // Flag for firing if threshold reached\n        if (neuron.currentCharge >= this.THRESHOLD) {\n          neuron.shouldFire = true;\n        }\n      }\n      \n      // Update any neuron state that depends on time\n      this._updateNeuronState(neuron, deltaTime);\n    }\n  }\n  \n  /**\n   * Process neurons that should fire this frame\n   * @private\n   */\n  _processFiringNeurons() {\n    // Collect neurons that should fire\n    const firingNeurons = [];\n    \n    for (const [id, neuron] of this.neurons) {\n      if (neuron && neuron.shouldFire && !neuron.isFiring) {\n        firingNeurons.push(neuron);\n      }\n    }\n    \n    // Process firing for these neurons\n    for (const neuron of firingNeurons) {\n      this._fireNeuron(neuron);\n    }\n  }\n  \n  /**\n   * Fire a specific neuron and propagate signals\n   * @param {Object} neuron The neuron data object\n   * @private\n   */\n  _fireNeuron(neuron) {\n    // Reset firing flag\n    neuron.shouldFire = false;\n    \n    // Set firing state\n    neuron.isFiring = true;\n    \n    // Reset charge\n    neuron.currentCharge = 0;\n    \n    // Add a lastFiredTime to track when we can charge again\n    neuron.lastFiredTime = performance.now();\n    \n    // Trigger visual effect if callback provided\n    if (typeof this.onEffectNeeded === 'function') {\n      this.onEffectNeeded('fire', neuron);\n    }\n    \n    // Trigger sound if callback provided\n    if (typeof this.onSoundNeeded === 'function') {\n      this.onSoundNeeded('fire', neuron);\n    }\n    \n    // After short delay, reset firing state\n    setTimeout(() => {\n      neuron.isFiring = false;\n      \n      // Trigger visual state update if callback provided\n      if (typeof this.onEffectNeeded === 'function') {\n        this.onEffectNeeded('update', neuron);\n      }\n    }, 5);\n    \n    // Propagate signals to connected neurons\n    this._propagateSignals(neuron);\n  }\n  \n  /**\n   * Propagate signals from a firing neuron to its connected neurons\n   * @param {Object} neuron The source neuron\n   * @private\n   */\n  _propagateSignals(neuron) {\n    console.debug(`[NeuronEngine] Propagating signals from neuron ${neuron.id}`);\n    console.debug(`[NeuronEngine] Outgoing connections: ${neuron.outgoingConnections.length}`);\n    \n    if (!neuron.outgoingConnections || neuron.outgoingConnections.length === 0) {\n      console.debug(`[NeuronEngine] No outgoing connections for neuron ${neuron.id}`);\n      return;\n    }\n    \n    // Process each connection\n    for (const targetId of neuron.outgoingConnections) {\n      const targetNeuron = this.neurons.get(targetId);\n      if (!targetNeuron) {\n        console.warn(`[NeuronEngine] Target neuron ${targetId} not found`);\n        continue;\n      }\n      \n      console.debug(`[NeuronEngine] Propagating to target ${targetId}`);\n      \n      // Get connection properties\n      const weight = neuron.synapticWeights.get(targetId) || 0.1;\n      const speed = neuron.synapticSpeeds.get(targetId) || 0.5;\n      \n      console.debug(`[NeuronEngine] Connection properties: weight=${weight}, speed=${speed}`);\n      \n      // *** ADDED: Directly create visual particles if WorkerManager is available ***\n      this._createVisualParticle(neuron.id, targetId, weight, speed);\n      \n      // For speed=1 connections, deliver signal immediately without visual effect\n      if (speed === 1) {\n        console.debug(`[NeuronEngine] Instant connection - delivering signal immediately without visual effect`);\n        this._deliverSignal(targetNeuron, weight);\n        continue;\n      }\n      \n      // For very fast connections (0.95-0.99), deliver signal immediately but still show visual effect\n      if (speed >= 0.95) {\n        console.debug(`[NeuronEngine] Fast connection - delivering signal immediately with visual effect`);\n        this._deliverSignal(targetNeuron, weight);\n        \n        // Still create visual effect\n        if (typeof this.onEffectNeeded === 'function') {\n          this.onEffectNeeded('signal', {\n            sourceNeuron: neuron,\n            targetNeuron: targetNeuron,\n            weight: weight,\n            speed: speed,\n            delay: 0\n          });\n        }\n        continue;\n      }\n      \n      // Otherwise calculate delay based on speed and create visual signal\n      // Make speed have a more dramatic effect:\n      // speed 0.1 (slow) = up to 900ms delay\n      // speed 0.9 (fast) = as little as 50ms delay\n      const delay = Math.max(50, Math.pow(1 - speed, 2) * 1000);\n      console.debug(`[NeuronEngine] Scheduled signal delivery with delay: ${delay.toFixed(0)}ms (speed: ${speed.toFixed(2)})`);\n      \n      // Trigger signal particle effect if callback provided\n      if (typeof this.onEffectNeeded === 'function') {\n        this.onEffectNeeded('signal', {\n          sourceNeuron: neuron,\n          targetNeuron: targetNeuron,\n          weight: weight,\n          speed: speed,\n          delay: delay\n        });\n      }\n      \n      // Schedule signal delivery after delay\n      setTimeout(() => {\n        this._deliverSignal(targetNeuron, weight);\n      }, delay);\n    }\n  }\n  \n  /**\n   * Create a visual particle for signal animation\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} weight Connection weight\n   * @param {number} speed Connection speed\n   * @private\n   */\n  _createVisualParticle(sourceId, targetId, weight, speed) {\n    // Only proceed if we're in browser environment with window object\n    if (typeof window === 'undefined') return;\n    \n    try {\n      // Find the source and target neuron visual objects\n      if (window.circles && Array.isArray(window.circles)) {\n        const sourceNeuron = window.circles.find(c => c.neuron && c.neuron.id === sourceId);\n        const targetNeuron = window.circles.find(c => c.neuron && c.neuron.id === targetId);\n        \n        if (sourceNeuron && targetNeuron) {\n          // If WorkerManager is available, create the particle using its method\n          if (window.workerManager && typeof window.workerManager.createParticle === 'function') {\n            console.debug(`[NeuronEngine] Creating particle via WorkerManager: ${sourceId} → ${targetId}`);\n            window.workerManager.createParticle(sourceNeuron, targetNeuron, weight, speed);\n          } \n          // Alternative direct particle creation (backup method)\n          else if (window.Neuron && typeof window.Neuron.createParticle === 'function') {\n            console.debug(`[NeuronEngine] Creating particle via Neuron.createParticle: ${sourceId} → ${targetId}`);\n            window.Neuron.createParticle(sourceNeuron, targetNeuron, weight, speed);\n          }\n          // Direct method call on sourceNeuron if available\n          else if (sourceNeuron.neuron && typeof sourceNeuron.neuron.createAndAnimateSignalParticle === 'function') {\n            console.debug(`[NeuronEngine] Creating particle via neuron method: ${sourceId} → ${targetId}`);\n            sourceNeuron.neuron.createAndAnimateSignalParticle(targetId, weight, speed, targetNeuron.neuron);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`[NeuronEngine] Error creating visual particle:`, error);\n    }\n  }\n  \n  /**\n   * Deliver a signal to a target neuron\n   * @param {Object} targetNeuron The target neuron\n   * @param {number} weight The synaptic weight\n   * @private\n   */\n  _deliverSignal(targetNeuron, weight) {\n    console.debug(`[NeuronEngine] Delivering signal to neuron ${targetNeuron.id} with weight ${weight}`);\n    \n    if (!targetNeuron) {\n      console.error(`[NeuronEngine] Cannot deliver signal: target neuron is null`);\n      return;\n    }\n    \n    if (targetNeuron.isFiring) {\n      console.info(`[NeuronEngine] Cannot deliver signal: neuron ${targetNeuron.id} is already firing`);\n      return;\n    }\n    \n    const previousCharge = targetNeuron.currentCharge;\n    \n    // Add charge based on weight with a more pronounced effect\n    // Scale weight to make differences more noticeable (0.1 = small charge, 1.0 = large charge)\n    // Use a non-linear scaling to make differences more apparent\n    const scaledWeight = weight * weight * 1.5; // Weight has a quadratic effect on charge\n    targetNeuron.currentCharge += scaledWeight;\n    \n    console.debug(`[NeuronEngine] Charge update: ${previousCharge.toFixed(2)} -> ${targetNeuron.currentCharge.toFixed(2)} (added ${scaledWeight.toFixed(2)})`);\n    \n    // Check if threshold reached\n    if (targetNeuron.currentCharge >= this.THRESHOLD) {\n      console.debug(`[NeuronEngine] Neuron ${targetNeuron.id} reached threshold, scheduling fire`);\n      targetNeuron.shouldFire = true;\n    }\n    \n    // Trigger visual update if callback provided\n    if (typeof this.onEffectNeeded === 'function') {\n      this.onEffectNeeded('update', targetNeuron);\n    }\n  }\n  \n  /**\n   * Update a neuron's state based on elapsed time\n   * @param {Object} neuron The neuron to update\n   * @param {number} deltaTime Time since last update in ms\n   * @private\n   */\n  _updateNeuronState(neuron, deltaTime) {\n    // Trigger visual update if callback provided\n    if (typeof this.onEffectNeeded === 'function') {\n      this.onEffectNeeded('update', neuron);\n    }\n  }\n  \n  /**\n   * Create a new neuron in the simulation\n   * @param {Object} data Initial neuron data\n   * @returns {Object} The created neuron data object\n   */\n  createNeuron(data = {}) {\n    // Generate unique ID if not provided\n    const id = data.id || this.neurons.size + 1;\n    \n    // Create neuron data object\n    const neuron = {\n      id: id,\n      mesh: data.mesh || null,\n      position: data.position || { x: 0, y: 0, z: 0 },\n      \n      // State\n      currentCharge: 0,\n      isFiring: false,\n      shouldFire: false,\n      \n      // Properties\n      dcInput: data.dcInput || 0,\n      baseScale: data.baseScale || 0.2,\n      maxScale: data.maxScale || 1,\n      originalColor: data.originalColor || 0x0000ff,\n      firingColor: data.firingColor || 0xffff00,\n      presetColor: data.presetColor || null,\n      presetName: data.presetName || null,\n      \n      // Connections\n      outgoingConnections: [], // Array of target IDs\n      synapticWeights: new Map(), // Map of targetId -> weight\n      synapticSpeeds: new Map(), // Map of targetId -> speed\n      \n      // Additional properties\n      isHarmonyAnchor: data.isHarmonyAnchor || false,\n      currentEnvelope: data.currentEnvelope || { attack: 0, sustain: 0, release: 0 }\n    };\n    \n    // Store in neurons map\n    this.neurons.set(id, neuron);\n    \n    console.info(`[NeuronEngine] Created neuron ${id}`);\n    return neuron;\n  }\n  \n  /**\n   * Remove a neuron from the simulation\n   * @param {number} id The neuron ID\n   * @returns {boolean} Success\n   */\n  removeNeuron(id) {\n    if (!this.neurons.has(id)) {\n      return false;\n    }\n    \n    // Get the neuron\n    const neuron = this.neurons.get(id);\n    \n    // Remove all connections to/from this neuron\n    for (const targetId of neuron.outgoingConnections) {\n      this.removeConnection(id, targetId);\n    }\n    \n    // Remove incoming connections from other neurons\n    for (const [sourceId, sourceNeuron] of this.neurons) {\n      if (sourceNeuron.outgoingConnections.includes(id)) {\n        this.removeConnection(sourceId, id);\n      }\n    }\n    \n    // Remove from neurons map\n    this.neurons.delete(id);\n    \n    console.debug(`[NeuronEngine] Removed neuron ${id}`);\n    return true;\n  }\n  \n  /**\n   * Create a connection between neurons in the centralized system\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} weight Initial synaptic weight (0-1)\n   * @param {number} speed Initial synaptic speed (0-1)\n   * @returns {boolean} Success\n   */\n  createConnection(sourceId, targetId, weight = 0.1, speed = 0.5) {\n    console.debug(`[NeuronEngine] Creating connection from ${sourceId} to ${targetId} (weight: ${weight}, speed: ${speed})`);\n    \n    // Validate neurons exist\n    if (!this.neurons.has(sourceId) || !this.neurons.has(targetId)) {\n      console.error(`[NeuronEngine] Cannot create connection: neuron not found (source: ${sourceId}, target: ${targetId})`);\n      return false;\n    }\n    \n    const sourceNeuron = this.neurons.get(sourceId);\n    \n    // Add to outgoing connections if not already there\n    if (!sourceNeuron.outgoingConnections.includes(targetId)) {\n      sourceNeuron.outgoingConnections.push(targetId);\n    }\n    \n    // Set weight and speed\n    sourceNeuron.synapticWeights.set(targetId, weight);\n    sourceNeuron.synapticSpeeds.set(targetId, speed);\n    \n    // Store connection key for lookup\n    const connectionKey = `${sourceId}_${targetId}`;\n    this.connections.set(connectionKey, { sourceId, targetId, weight, speed });\n    \n    console.info(`[NeuronEngine] Created connection from ${sourceId} to ${targetId}`);\n    return true;\n  }\n  \n  /**\n   * Remove a connection between neurons\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @returns {boolean} Success\n   */\n  removeConnection(sourceId, targetId) {\n    if (!this.neurons.has(sourceId)) {\n      return false;\n    }\n    \n    const sourceNeuron = this.neurons.get(sourceId);\n    \n    // Remove from outgoing connections\n    sourceNeuron.outgoingConnections = sourceNeuron.outgoingConnections.filter(id => id !== targetId);\n    \n    // Remove weight and speed\n    sourceNeuron.synapticWeights.delete(targetId);\n    sourceNeuron.synapticSpeeds.delete(targetId);\n    \n    // Remove from connections map\n    const connectionKey = `${sourceId}_${targetId}`;\n    this.connections.delete(connectionKey);\n    \n    console.debug(`[NeuronEngine] Removed connection from ${sourceId} to ${targetId}`);\n    return true;\n  }\n  \n  /**\n   * Update a connection's weight\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} weight New synaptic weight (0-1)\n   * @returns {boolean} Success\n   */\n  updateConnectionWeight(sourceId, targetId, weight) {\n    if (!this.neurons.has(sourceId) || !this.neurons.has(targetId)) {\n      return false;\n    }\n    \n    const sourceNeuron = this.neurons.get(sourceId);\n    sourceNeuron.synapticWeights.set(targetId, weight);\n    \n    // Update in connections map\n    const connectionKey = `${sourceId}_${targetId}`;\n    const connection = this.connections.get(connectionKey);\n    if (connection) {\n      connection.weight = weight;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Update a connection's speed\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} speed New synaptic speed (0-1)\n   * @returns {boolean} Success\n   */\n  updateConnectionSpeed(sourceId, targetId, speed) {\n    if (!this.neurons.has(sourceId) || !this.neurons.has(targetId)) {\n      return false;\n    }\n    \n    const sourceNeuron = this.neurons.get(sourceId);\n    sourceNeuron.synapticSpeeds.set(targetId, speed);\n    \n    // Update in connections map\n    const connectionKey = `${sourceId}_${targetId}`;\n    const connection = this.connections.get(connectionKey);\n    if (connection) {\n      connection.speed = speed;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Set DC input for a neuron\n   * @param {number} neuronId Neuron ID\n   * @param {number} value DC input value (0-1)\n   * @param {boolean} resetCharge Whether to reset current charge\n   * @returns {boolean} Success\n   */\n  setDCInput(neuronId, value, resetCharge = false) {\n    if (!this.neurons.has(neuronId)) {\n      return false;\n    }\n    \n    const neuron = this.neurons.get(neuronId);\n    \n    // Clamp value without rounding\n    neuron.dcInput = Math.max(0, Math.min(1, value));\n    \n    // Reset charge if requested\n    if (resetCharge) {\n      neuron.currentCharge = 0;\n      neuron.isFiring = false;\n      neuron.shouldFire = false;\n    }\n    \n    console.debug(`[NeuronEngine] Set DC input for neuron ${neuronId} to ${neuron.dcInput}`);\n    return true;\n  }\n  \n  /**\n   * Add charge to a neuron\n   * @param {number} neuronId Neuron ID\n   * @param {number} amount Amount of charge to add\n   * @returns {boolean} Success\n   */\n  addCharge(neuronId, amount) {\n    if (!this.neurons.has(neuronId)) {\n      return false;\n    }\n    \n    const neuron = this.neurons.get(neuronId);\n    \n    // Don't add charge if firing\n    if (neuron.isFiring) {\n      return false;\n    }\n    \n    // Add charge and cap at threshold\n    neuron.currentCharge = Math.min(neuron.currentCharge + amount, this.THRESHOLD);\n    \n    // Check if neuron should fire\n    if (neuron.currentCharge >= this.THRESHOLD) {\n      neuron.shouldFire = true;\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Get a neuron by ID\n   * @param {number} neuronId Neuron ID\n   * @returns {Object} Neuron data object\n   */\n  getNeuron(neuronId) {\n    return this.neurons.get(neuronId);\n  }\n  \n  /**\n   * Get all neurons\n   * @returns {Array} Array of neuron data objects\n   */\n  getAllNeurons() {\n    return Array.from(this.neurons.values());\n  }\n  \n  /**\n   * Force a neuron to fire\n   * @param {number} neuronId Neuron ID\n   * @returns {boolean} Success\n   */\n  fireNeuron(neuronId) {\n    if (!this.neurons.has(neuronId)) {\n      return false;\n    }\n    \n    const neuron = this.neurons.get(neuronId);\n    \n    // Don't fire if already firing\n    if (neuron.isFiring) {\n      return false;\n    }\n    \n    // Set should fire flag\n    neuron.shouldFire = true;\n    \n    return true;\n  }\n  \n  /**\n   * Reset a neuron to initial state\n   * @param {number} neuronId Neuron ID\n   * @returns {boolean} Success\n   */\n  resetNeuron(neuronId) {\n    if (!this.neurons.has(neuronId)) {\n      return false;\n    }\n    \n    const neuron = this.neurons.get(neuronId);\n    \n    // Reset to initial state\n    neuron.currentCharge = 0;\n    neuron.isFiring = false;\n    neuron.shouldFire = false;\n    \n    return true;\n  }\n  \n  /**\n   * Reset all neurons to initial state\n   */\n  resetAllNeurons() {\n    for (const neuron of this.neurons.values()) {\n      // Reset to initial state\n      neuron.currentCharge = 0;\n      neuron.isFiring = false;\n      neuron.shouldFire = false;\n    }\n  }\n  \n  /**\n   * Get all DC neurons\n   * @returns {Array} Array of neuron data objects with DC input > 0\n   */\n  getDCNeurons() {\n    return Array.from(this.neurons.values())\n      .filter(neuron => neuron.dcInput > 0);\n  }\n  \n  /**\n   * Clean up resources and stop the simulation\n   */\n  dispose() {\n    this.stop();\n    \n    // Clear all timeouts that might be pending\n    for (const neuron of this.neurons.values()) {\n      neuron.outgoingConnections = [];\n      neuron.synapticWeights.clear();\n      neuron.synapticSpeeds.clear();\n    }\n    \n    this.neurons.clear();\n    this.connections.clear();\n    \n    console.debug('[NeuronEngine] Disposed');\n  }\n}\n\n// Create and export a singleton instance\nexport const neuronEngine = new NeuronEngine();\nexport default neuronEngine; ","/**\n * NeuronAdapter - Interfaces between the centralized NeuronEngine and THREE.js visuals\n * \n * This adapter handles the visual representation of neurons and their connections,\n * while delegating all simulation logic to the centralized NeuronEngine.\n */\n\nimport * as THREE from 'three';\nimport neuronEngine from './NeuronEngine';\n\nexport class NeuronAdapter {\n  constructor(scene, options = {}) {\n    // Store scene reference\n    this.scene = scene;\n    \n    // Configuration\n    this.options = {\n      chargeColorInterpolation: true,\n      showScaleChanges: true,\n      ...options\n    };\n    \n    // Visual properties\n    this.neuronMeshes = new Map(); // Map of neuronId -> THREE.Mesh\n    this.connectionLines = new Map(); // Map of connectionId -> THREE.Line\n    \n    // Internal state\n    this.initialized = false;\n    \n    // Effects manager reference\n    this.effectsManager = null;\n    \n    // Bind methods\n    this.handleEffects = this.handleEffects.bind(this);\n    this.handleSounds = this.handleSounds.bind(this);\n  }\n  \n  /**\n   * Initialize the adapter\n   * @param {Object} effectsManager Optional effects manager\n   */\n  initialize(effectsManager = null) {\n    if (this.initialized) return this;\n    \n    // Store effects manager\n    this.effectsManager = effectsManager;\n    \n    // Initialize neuron engine with our callback handlers\n    neuronEngine.initialize({\n      onEffectNeeded: this.handleEffects,\n      onSoundNeeded: this.handleSounds\n    });\n    \n    // Start the simulation\n    neuronEngine.start();\n    \n    this.initialized = true;\n    return this;\n  }\n  \n  /**\n   * Create a neuron with visual representation\n   * @param {THREE.Mesh} mesh The THREE.js mesh for this neuron\n   * @param {Object} properties Additional neuron properties\n   * @returns {Object} The created neuron data\n   */\n  createNeuron(mesh, properties = {}) {\n    if (!mesh) {\n      console.error('[NeuronAdapter] Cannot create neuron without mesh');\n      return null;\n    }\n    \n    // Extract position from mesh\n    const position = {\n      x: mesh.position.x,\n      y: mesh.position.y,\n      z: mesh.position.z\n    };\n    \n    // Create neuron in engine\n    const neuron = neuronEngine.createNeuron({\n      mesh: mesh, // Store reference but not used directly by engine\n      position: position,\n      baseScale: properties.baseScale || 0.2,\n      maxScale: properties.maxScale || 1,\n      originalColor: properties.originalColor || 0x0000ff,\n      firingColor: properties.firingColor || 0xffff00,\n      presetColor: properties.presetColor || null,\n      presetName: properties.presetName || null,\n      isHarmonyAnchor: properties.isHarmonyAnchor || false,\n      currentEnvelope: properties.currentEnvelope || { attack: 0, sustain: 0, release: 0 }\n    });\n    \n    // Store mesh reference for this neuron\n    this.neuronMeshes.set(neuron.id, mesh);\n    \n    // Set initial visual state\n    this.updateNeuronVisuals(neuron);\n    \n    // Also store neuron reference on the mesh\n    mesh.neuronId = neuron.id;\n    \n    return neuron;\n  }\n  \n  /**\n   * Remove a neuron and its visual representation\n   * @param {number} neuronId Neuron ID\n   */\n  removeNeuron(neuronId) {\n    const neuron = neuronEngine.getNeuron(neuronId);\n    if (!neuron) return;\n    \n    // Remove from engine\n    neuronEngine.removeNeuron(neuronId);\n    \n    // Remove mesh from scene if it exists\n    const mesh = this.neuronMeshes.get(neuronId);\n    if (mesh && mesh.parent) {\n      mesh.parent.remove(mesh);\n    }\n    \n    // Remove from mesh map\n    this.neuronMeshes.delete(neuronId);\n  }\n  \n  /**\n   * Create a connection between neurons\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} weight Initial connection weight (0-1)\n   * @param {number} speed Initial connection speed (0-1)\n   */\n  createConnection(sourceId, targetId, weight = 0.1, speed = 0.5) {\n    // Create connection in engine\n    const success = neuronEngine.createConnection(sourceId, targetId, weight, speed);\n    \n    if (success) {\n      // Update visual representation\n      this.updateConnectionVisuals(sourceId, targetId);\n    } else {\n      console.error(`[NeuronAdapter] Failed to create connection in engine`);\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Remove a connection\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   */\n  removeConnection(sourceId, targetId) {\n    // Remove connection from engine\n    const success = neuronEngine.removeConnection(sourceId, targetId);\n    \n    if (success) {\n      // Remove visual representation\n      const connectionKey = `${sourceId}_${targetId}`;\n      const line = this.connectionLines.get(connectionKey);\n      \n      if (line && line.parent) {\n        line.parent.remove(line);\n      }\n      \n      this.connectionLines.delete(connectionKey);\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Set DC input for a neuron\n   * @param {number} neuronId Neuron ID\n   * @param {number} value DC input value (0-1)\n   * @param {boolean} resetCharge Whether to reset current charge\n   */\n  setDCInput(neuronId, value, resetCharge = false) {\n    // Update in engine\n    const success = neuronEngine.setDCInput(neuronId, value, resetCharge);\n    \n    if (success) {\n      // Update visuals\n      const neuron = neuronEngine.getNeuron(neuronId);\n      this.updateNeuronVisuals(neuron);\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Add charge to a neuron\n   * @param {number} neuronId Neuron ID\n   * @param {number} amount Amount of charge to add\n   */\n  addCharge(neuronId, amount) {\n    // Add charge in engine\n    const success = neuronEngine.addCharge(neuronId, amount);\n    \n    if (success) {\n      // Update visuals\n      const neuron = neuronEngine.getNeuron(neuronId);\n      this.updateNeuronVisuals(neuron);\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Force a neuron to fire\n   * @param {number} neuronId Neuron ID\n   */\n  fireNeuron(neuronId) {\n    return neuronEngine.fireNeuron(neuronId);\n  }\n  \n  /**\n   * Update a connection's weight\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} weight New weight (0-1)\n   */\n  updateConnectionWeight(sourceId, targetId, weight) {\n    return neuronEngine.updateConnectionWeight(sourceId, targetId, weight);\n  }\n  \n  /**\n   * Update a connection's speed\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @param {number} speed New speed (0-1)\n   */\n  updateConnectionSpeed(sourceId, targetId, speed) {\n    return neuronEngine.updateConnectionSpeed(sourceId, targetId, speed);\n  }\n  \n  /**\n   * Reset a neuron to initial state\n   * @param {number} neuronId Neuron ID\n   */\n  resetNeuron(neuronId) {\n    const success = neuronEngine.resetNeuron(neuronId);\n    \n    if (success) {\n      // Update visuals\n      const neuron = neuronEngine.getNeuron(neuronId);\n      this.updateNeuronVisuals(neuron);\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Get a neuron by ID\n   * @param {number} neuronId Neuron ID\n   * @returns {Object} Neuron data\n   */\n  getNeuron(neuronId) {\n    return neuronEngine.getNeuron(neuronId);\n  }\n  \n  /**\n   * Get the THREE.js mesh for a neuron\n   * @param {number} neuronId Neuron ID\n   * @returns {THREE.Mesh} The neuron's mesh\n   */\n  getNeuronMesh(neuronId) {\n    return this.neuronMeshes.get(neuronId);\n  }\n  \n  /**\n   * Handle effect requests from the neuron engine\n   * @param {string} type Effect type (fire, signal, update)\n   * @param {Object} data Effect data\n   * @private\n   */\n  handleEffects(type, data) {\n    switch (type) {\n      case 'fire':\n        this.createFiringEffect(data);\n        break;\n      case 'signal':\n        this.createSignalEffect(data);\n        break;\n      case 'update':\n        this.updateNeuronVisuals(data);\n        break;\n    }\n  }\n  \n  /**\n   * Handle sound requests from the neuron engine\n   * @param {string} type Sound type (fire)\n   * @param {Object} data Sound data\n   * @private\n   */\n  handleSounds(type, data) {\n    if (type === 'fire' && window.soundManager) {\n      const neuron = data;\n      \n      // Calculate sound parameters based on neuron properties\n      const sourcesCount = neuron.outgoingConnections.length;\n      let avgWeight = 0;\n      let avgSpeed = 0;\n      \n      if (sourcesCount > 0) {\n        let totalWeight = 0;\n        let totalSpeed = 0;\n        \n        for (const targetId of neuron.outgoingConnections) {\n          totalWeight += neuron.synapticWeights.get(targetId) || 0.1;\n          totalSpeed += neuron.synapticSpeeds.get(targetId) || 0.5;\n        }\n        \n        avgWeight = totalWeight / sourcesCount;\n        avgSpeed = totalSpeed / sourcesCount;\n      } else {\n        avgWeight = 0.5;\n        avgSpeed = 0.5;\n      }\n      \n      // Play sound through sound manager\n      window.soundManager.playNeuronFiring(\n        avgWeight,\n        avgSpeed,\n        neuron.id,\n        sourcesCount === 0,\n        neuron.dcInput > 0,\n        1 // distance (not used in centralized system)\n      );\n    }\n  }\n  \n  /**\n   * Create firing effect for a neuron - simplified for performance\n   * @param {Object} neuron Neuron data\n   * @private\n   */\n  createFiringEffect(neuron) {\n    // Update the visual state first\n    this.updateNeuronVisuals(neuron);\n    \n    // Get the mesh\n    const mesh = this.neuronMeshes.get(neuron.id);\n    if (!mesh) return;\n    \n    // Basic color change without additional animations\n    const firingColor = neuron.presetColor ?\n      new THREE.Color().copy(neuron.presetColor).multiplyScalar(1.5) :\n      new THREE.Color(neuron.firingColor);\n    \n    if (mesh.material) {\n      mesh.material.color.copy(firingColor);\n      \n      // Reset color after delay\n      setTimeout(() => {\n        if (mesh.material) {\n          const originalColor = neuron.presetColor ?\n            new THREE.Color().copy(neuron.presetColor) :\n            new THREE.Color(neuron.originalColor);\n          mesh.material.color.copy(originalColor);\n        }\n      }, 150);\n    }\n  }\n  \n  /**\n   * Create signal effect between neurons - disabled for performance\n   * @param {Object} data Signal data\n   * @private\n   */\n  createSignalEffect(data) {\n    // Signal animations are disabled for performance\n    // The engine already handles the logic without needing visual effects\n    return;\n  }\n  \n  /**\n   * Update the visual representation of a neuron\n   * @param {Object} neuron Neuron data\n   * @private\n   */\n  updateNeuronVisuals(neuron) {\n    if (!neuron) return;\n    \n    const mesh = this.neuronMeshes.get(neuron.id);\n    if (!mesh || !mesh.material) return;\n    \n    // Update scale based on charge and DC input\n    if (this.options.showScaleChanges) {\n      const dcScale = neuron.baseScale + (neuron.maxScale - neuron.baseScale) * Math.min(1.0, neuron.dcInput);\n      const chargeRatio = neuron.currentCharge / 1.0; // Assume threshold is 1.0\n      let targetScale;\n      \n      if (neuron.isFiring) {\n        // Use larger scale when firing\n        targetScale = Math.min(dcScale * 1.4, neuron.maxScale);\n      } else {\n        // Scale based on charge\n        targetScale = dcScale * (1 + chargeRatio * 0.5);\n      }\n      \n      // Apply scale\n      mesh.scale.setScalar(targetScale);\n    }\n    \n    // Update color based on state\n    if (neuron.isFiring) {\n      // Use firing color\n      if (neuron.presetColor) {\n        // For preset colors, just make them brighter when firing\n        mesh.material.color.copy(neuron.presetColor).multiplyScalar(1.8);\n      } else {\n        mesh.material.color.setHex(neuron.firingColor);\n      }\n    } else if (this.options.chargeColorInterpolation) {\n      // Interpolate color based on charge\n      if (neuron.presetColor) {\n        // Use preset color as base and brighten based on charge\n        const chargeRatio = neuron.currentCharge / 1.0;\n        if (chargeRatio > 0) {\n          const baseColor = new THREE.Color().copy(neuron.presetColor);\n          const brighterColor = new THREE.Color().copy(neuron.presetColor).multiplyScalar(1.5);\n          mesh.material.color.copy(baseColor).lerp(brighterColor, chargeRatio);\n        } else {\n          mesh.material.color.copy(neuron.presetColor);\n        }\n      } else {\n        // Default interpolation\n        const chargeRatio = neuron.currentCharge / 1.0;\n        const originalColor = new THREE.Color(neuron.originalColor);\n        const chargingColor = new THREE.Color(0x00ffff); // Cyan for charging\n        mesh.material.color.copy(originalColor).lerp(chargingColor, chargeRatio);\n      }\n    } else {\n      // Just use original color\n      if (neuron.presetColor) {\n        mesh.material.color.copy(neuron.presetColor);\n      } else {\n        mesh.material.color.setHex(neuron.originalColor);\n      }\n    }\n  }\n  \n  /**\n   * Update the visual representation of a connection\n   * @param {number} sourceId Source neuron ID\n   * @param {number} targetId Target neuron ID\n   * @private\n   */\n  updateConnectionVisuals(sourceId, targetId) {\n    // This would implement connection line visualization\n    // But we're focusing on the core functionality for now\n  }\n  \n  /**\n   * Handle neuron update from engine\n   * This is called every frame by the engine\n   * @private\n   */\n  update(timestamp, deltaTime) {\n    // Additional visual updates could be performed here\n    // But most updates are triggered by events\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    // Stop the engine\n    neuronEngine.dispose();\n    \n    // Clean up connection lines\n    for (const line of this.connectionLines.values()) {\n      if (line.parent) {\n        line.parent.remove(line);\n      }\n      if (line.geometry) line.geometry.dispose();\n      if (line.material) line.material.dispose();\n    }\n    this.connectionLines.clear();\n    \n    // Clear references\n    this.neuronMeshes.clear();\n    this.effectsManager = null;\n    this.initialized = false;\n  }\n}\n\n// Export singleton instance\nexport default NeuronAdapter; ","/**\n * Centralized Neural Simulation System\n * \n * Exports a completely redesigned neural simulation system with:\n * - Single source of truth\n * - Centralized update loop\n * - Separation of simulation and visualization\n * - Stable timing and performance\n */\n\nimport neuronEngine from './NeuronEngine';\nimport { NeuronAdapter } from './NeuronAdapter';\nimport Logger from '../utils/logger.js';\n\n/**\n * Directly register existing neurons into the centralized system\n * This ensures all neurons exist before trying to create connections between them\n */\nexport function registerExistingNeurons() {\n  if (!window.circles || !Array.isArray(window.circles)) {\n    return;\n  }\n  \n  // First register all neurons with their IDs\n  window.circles.forEach((circle, index) => {\n    if (!circle || !circle.position) return;\n    \n    // Get the neuron ID from the circle or generate one\n    const neuronId = circle.neuron?.id || `${index + 1}`;\n    \n    // Check if this neuron already exists in the system\n    if (neuronEngine.getNeuron(neuronId)) {\n      return;\n    }\n    \n    // Create the neuron in the centralized system\n    const neuron = neuronEngine.createNeuron({\n      id: neuronId,\n      mesh: circle,\n      position: {\n        x: circle.position.x,\n        y: circle.position.y,\n        z: circle.position.z\n      },\n      baseScale: circle.neuron?.baseScale || 0.2,\n      maxScale: circle.neuron?.maxScale || 1,\n      originalColor: circle.neuron?.originalColor || 0x0000ff,\n      firingColor: circle.neuron?.firingColor || 0xffff00,\n      presetColor: circle.neuron?.presetColor || null,\n      presetName: circle.neuron?.presetName || null,\n      dcInput: circle.neuron?.dcInput || 0\n    });\n    \n    // Store reference to neuron in the circle\n    circle.neuronId = neuronId;\n    \n    // Register with adapter\n    if (window.neuronAdapter) {\n      window.neuronAdapter.neuronMeshes.set(neuronId, circle);\n    }\n  });\n  \n  // After all neurons are registered, create the connections\n  window.circles.forEach((circle, index) => {\n    if (!circle || !circle.neuron || !circle.neuronId) return;\n    \n    const sourceId = circle.neuronId;\n    \n    // Get outgoing connections\n    const connections = circle.neuron.outgoingConnections;\n    if (!connections || connections.size === 0) return;\n    \n    // Create each connection\n    connections.forEach(targetIndex => {\n      if (targetIndex < 0 || targetIndex >= window.circles.length) return;\n      \n      const targetCircle = window.circles[targetIndex];\n      if (!targetCircle || !targetCircle.neuronId) return;\n      \n      const targetId = targetCircle.neuronId;\n      const weight = circle.neuron.synapticWeights?.get(targetIndex) || 0.1;\n      const speed = circle.neuron.synapticSpeeds?.get(targetIndex) || 0.5;\n      \n      neuronEngine.createConnection(sourceId, targetId, weight, speed);\n    });\n  });\n}\n\n/**\n * Initialize the centralized neural simulation system\n * @param {THREE.Scene} scene - The THREE.js scene\n * @param {Object} effectsManager - Optional effects manager\n * @returns {Object} - The initialized systems\n */\nexport function initializeCentralizedSystem(scene, effectsManager = null) {\n  // Create adapter instance\n  const neuronAdapter = new NeuronAdapter(scene);\n  \n  // Initialize with effects manager if provided\n  neuronAdapter.initialize(effectsManager);\n  \n  // Make available globally (for compatibility with existing code)\n  window.neuralEngine = neuronEngine;\n  window.neuronAdapter = neuronAdapter;\n  \n  // Register any existing neurons\n  registerExistingNeurons();\n  \n  // Return references to both components\n  return {\n    engine: neuronEngine,\n    adapter: neuronAdapter\n  };\n}\n\n// Export components\nexport { neuronEngine, NeuronAdapter };\n\n// Export a compatibility layer for existing code\nexport const Neuron = {\n  // Static methods\n  createNeuron: (mesh, properties) => {\n    if (!window.neuronAdapter) {\n      Logger.error('[Compatibility] Neuron adapter not initialized');\n      return null;\n    }\n    return window.neuronAdapter.createNeuron(mesh, properties);\n  },\n  \n  // Legacy static properties and methods\n  dcNeurons: {\n    size: 0,\n    add: () => {},\n    delete: () => {},\n    forEach: (callback) => {\n      if (!window.neuralEngine) return;\n      const dcNeurons = window.neuralEngine.getDCNeurons();\n      dcNeurons.forEach(callback);\n    }\n  },\n  \n  // Static method to update all DC neurons (not needed in new system)\n  updateAllDCNeurons: () => {\n    // No-op, handled by central system\n  }\n}; ","import * as THREE from 'three';\nimport Logger from '../utils/logger';\n\nimport { Neuron, neuronEngine } from './index';\n\n/**\n * Patch functions to make existing code compatible with the centralized neural system\n * \n * This module provides patches that can be applied to make the existing codebase\n * work with our new centralized neural simulation system without requiring a complete rewrite.\n */\n\n/**\n * Apply patches to make the existing code work with the centralized system\n */\nexport function applyCompatibilityPatches() {\n  Logger.debug('[Patches] Applying compatibility patches for centralized neural system');\n  \n  // Store original Neuron class for reference\n  if (window.OriginalNeuron) {\n    Logger.warn('[Patches] Original Neuron class already stored, skipping backup');\n  } else {\n    window.OriginalNeuron = window.Neuron;\n  }\n  \n  // Replace global Neuron class with our compatibility layer\n  window.Neuron = Neuron;\n  \n  // Patch global circles array to work with our system\n  if (window.circles && Array.isArray(window.circles)) {\n    patchCirclesArray();\n  }\n  \n  // Add support for legacy \"neuron\" property on mesh objects\n  patchMeshNeuronProperty();\n  \n  Logger.debug('[Patches] Compatibility patches applied successfully');\n}\n\n/**\n * Patch the global circles array to work with our centralized system\n */\nfunction patchCirclesArray() {\n  // Store original array\n  const originalCircles = [...window.circles];\n  \n  Logger.debug(`[Patches] Starting migration of ${originalCircles.length} neurons to centralized system`);\n  \n  // For each circle that has a neuron property\n  originalCircles.forEach((circle, index) => {\n    if (circle && circle.neuron) {\n      const originalNeuron = circle.neuron;\n      \n      // Ensure we have a proper ID (use the original ID if available, otherwise create one)\n      // CRITICAL FIX: Use the string ID rather than numeric index to ensure correct connections\n      const neuronId = originalNeuron.id || `${index + 1}`;\n      \n      Logger.debug(`[Patches] Migrating neuron ${neuronId} to centralized system`);\n      \n      // Create a neuron in our centralized system\n      const neuron = neuronEngine.createNeuron({\n        id: neuronId,\n        mesh: circle,\n        position: {\n          x: circle.position.x,\n          y: circle.position.y,\n          z: circle.position.z\n        },\n        baseScale: originalNeuron.baseScale || 0.2,\n        maxScale: originalNeuron.maxScale || 1,\n        originalColor: originalNeuron.originalColor || 0x0000ff,\n        firingColor: originalNeuron.firingColor || 0xffff00,\n        presetColor: originalNeuron.presetColor || null,\n        presetName: originalNeuron.presetName || null,\n        dcInput: originalNeuron.dcInput || 0,\n        isHarmonyAnchor: originalNeuron.isHarmonyAnchor || false\n      });\n      \n      // Store the neuron mesh in the adapter for visualization\n      if (window.neuronAdapter) {\n        window.neuronAdapter.neuronMeshes.set(neuronId, circle);\n      }\n      \n      // Copy connections if any\n      if (originalNeuron.outgoingConnections && originalNeuron.outgoingConnections.size > 0) {\n        Logger.debug(`[Patches] Migrating ${originalNeuron.outgoingConnections.size} connections for neuron ${neuronId}`);\n        \n        originalNeuron.outgoingConnections.forEach(targetIndex => {\n          // Convert the target index to a proper ID (same approach as above)\n          // The target should be the ID, not the array index\n          const targetNeuron = window.circles[targetIndex]?.neuron;\n          const targetId = targetNeuron?.id || `${targetIndex + 1}`;\n          \n          const weight = originalNeuron.synapticWeights.get(targetIndex) || 0.1;\n          const speed = originalNeuron.synapticSpeeds.get(targetIndex) || 0.5;\n          \n          Logger.debug(`[Patches] Creating connection from ${neuronId} to ${targetId}`);\n          neuronEngine.createConnection(neuronId, targetId, weight, speed);\n        });\n      }\n      \n      // Replace original neuron reference with a neuron adapter\n      circle.neuron = createNeuronShim(neuronId);\n      circle.neuronId = neuronId;\n    }\n  });\n  \n  Logger.debug('[Patches] Patched circles array with centralized neurons');\n}\n\n/**\n * Patch mesh objects to support legacy \"neuron\" property\n */\nfunction patchMeshNeuronProperty() {\n  // We can't replace THREE.Mesh directly as it's read-only\n  // Instead, add a utility function to patch individual meshes\n  \n  // Create a global utility function to patch mesh objects\n  window.patchMeshForNeuron = function(mesh) {\n    if (!mesh) return mesh;\n    \n    // Skip if already patched\n    if (mesh._neuronPatched) return mesh;\n    \n    // Add neuronId property (used by our adapter)\n    mesh.neuronId = null;\n    \n    // Add neuron property with getter/setter\n    Object.defineProperty(mesh, 'neuron', {\n      get: function() {\n        if (!this.neuronId) return null;\n        return createNeuronShim(this.neuronId);\n      },\n      set: function(value) {\n        // If value is null, remove neuron\n        if (!value) {\n          if (this.neuronId) {\n            neuronEngine.removeNeuron(this.neuronId);\n            this.neuronId = null;\n          }\n          return;\n        }\n        \n        // If the value is already a neuron shim, just store its ID\n        if (value.isNeuronShim) {\n          this.neuronId = value.id;\n          return;\n        }\n        \n        // Otherwise, create a new neuron in the centralized system\n        const neuron = neuronEngine.createNeuron({\n          mesh: this,\n          position: {\n            x: this.position.x,\n            y: this.position.y,\n            z: this.position.z\n          },\n          // Try to copy properties from the old neuron\n          baseScale: value.baseScale || 0.2,\n          maxScale: value.maxScale || 1,\n          originalColor: value.originalColor || 0x0000ff,\n          firingColor: value.firingColor || 0xffff00,\n          presetColor: value.presetColor || null,\n          presetName: value.presetName || null,\n          dcInput: value.dcInput || 0,\n          isHarmonyAnchor: value.isHarmonyAnchor || false\n        });\n        \n        this.neuronId = neuron.id;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    \n    // Mark as patched to avoid double patching\n    mesh._neuronPatched = true;\n    \n    return mesh;\n  };\n  \n  // Patch the createNeuron function to ensure meshes are patched\n  const originalCreateNeuron = neuronEngine.createNeuron;\n  neuronEngine.createNeuron = function(options) {\n    if (options.mesh) {\n      window.patchMeshForNeuron(options.mesh);\n    }\n    return originalCreateNeuron.call(this, options);\n  };\n  \n  // Patch any existing meshes in the scene\n  if (window.scene && Array.isArray(window.scene.children)) {\n    window.scene.children.forEach(child => {\n      if (child instanceof THREE.Mesh) {\n        window.patchMeshForNeuron(child);\n      }\n    });\n  }\n  \n  Logger.debug('[Patches] Added patchMeshForNeuron utility function');\n}\n\n/**\n * Create a shim object that mimics the interface of the original Neuron class\n * but delegates all operations to our centralized neural engine\n * @param {number} neuronId The ID of the neuron in our centralized system\n * @returns {Object} A shim that behaves like the original Neuron instance\n */\nfunction createNeuronShim(neuronId) {\n  const neuron = neuronEngine.getNeuron(neuronId);\n  if (!neuron) {\n    Logger.error(`[Patches] Cannot create shim for non-existent neuron: ${neuronId}`);\n    return null;\n  }\n  \n  // Create a proxy object that mimics the original Neuron interface\n  const shim = {\n    id: neuronId,\n    isNeuronShim: true,\n    \n    // Properties that mirror the engine's neuron properties\n    get mesh() { return window.neuronAdapter?.getNeuronMesh(neuronId); },\n    get currentCharge() { return neuron.currentCharge; },\n    get isFiring() { return neuron.isFiring; },\n    get dcInput() { return neuron.dcInput; },\n    get outgoingConnections() { return new Set(neuron.outgoingConnections); },\n    get synapticWeights() { return new Map(neuron.synapticWeights); },\n    get synapticSpeeds() { return new Map(neuron.synapticSpeeds); },\n    get baseScale() { return neuron.baseScale; },\n    get maxScale() { return neuron.maxScale; },\n    get originalColor() { return neuron.originalColor; },\n    get firingColor() { return neuron.firingColor; },\n    get presetColor() { return neuron.presetColor; },\n    set presetColor(value) { neuron.presetColor = value; },\n    get presetName() { return neuron.presetName; },\n    get isHarmonyAnchor() { return neuron.isHarmonyAnchor; },\n    get currentEnvelope() { return neuron.currentEnvelope; },\n    \n    // Main methods that delegate to the engine\n    setDCInput(value, resetCharge = false) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.setDCInput(neuronId, value, resetCharge);\n      }\n      return neuronEngine.setDCInput(neuronId, value, resetCharge);\n    },\n    \n    addCharge(amount) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.addCharge(neuronId, amount);\n      }\n      return neuronEngine.addCharge(neuronId, amount);\n    },\n    \n    fire() {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.fireNeuron(neuronId);\n      }\n      return neuronEngine.fireNeuron(neuronId);\n    },\n    \n    addConnection(targetId, weight = 0.1, speed = 0.5) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.createConnection(neuronId, targetId, weight, speed);\n      }\n      return neuronEngine.createConnection(neuronId, targetId, weight, speed);\n    },\n    \n    updateConnectionWeight(targetId, weight) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.updateConnectionWeight(neuronId, targetId, weight);\n      }\n      return neuronEngine.updateConnectionWeight(neuronId, targetId, weight);\n    },\n    \n    updateConnectionSpeed(targetId, speed) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.updateConnectionSpeed(neuronId, targetId, speed);\n      }\n      return neuronEngine.updateConnectionSpeed(neuronId, targetId, speed);\n    },\n    \n    removeConnection(targetId) {\n      if (window.neuronAdapter) {\n        return window.neuronAdapter.removeConnection(neuronId, targetId);\n      }\n      return neuronEngine.removeConnection(neuronId, targetId);\n    },\n    \n    reset() {\n      return neuronEngine.resetNeuron(neuronId);\n    },\n    \n    // Methods that do nothing in the centralized system\n    update() {\n      // No-op, handled by central update loop\n    },\n    \n    updateVisualState() {\n      // No-op, handled by adapter\n    },\n    \n    cleanup() {\n      return neuronEngine.removeNeuron(neuronId);\n    },\n    \n    setExternalAnimation(duration = 500) {\n      return true;\n    },\n    \n    // Compatibility methods for code that expects refractory period\n    isInRefractoryPeriod() {\n      return false;\n    }\n  };\n  \n  return shim;\n}\n\n/**\n * Restore original code patched by this module\n */\nexport function removeCompatibilityPatches() {\n  // Restore original Neuron class\n  if (window.OriginalNeuron) {\n    window.Neuron = window.OriginalNeuron;\n    window.OriginalNeuron = null;\n  }\n  \n  // Cleanup any remaining references\n  Logger.debug('[Patches] Compatibility patches removed');\n} ","/**\n * Initialize the Centralized Neural Simulation System and integrate with existing code\n */\n\nimport { initializeCentralizedSystem } from './index';\nimport { applyCompatibilityPatches } from './patchExistingCode';\nimport Logger from '../utils/logger.js';\n\n/**\n * Initialize the centralized neural simulation system in the main application\n * @param {Object} scene The THREE.js scene\n * @param {Object} effectsManager The effects manager instance\n * @param {Object} options Additional options\n * @returns {Object} The initialized system components\n */\nexport function initializeCentralizedNeuralSystem(scene, effectsManager = null, options = {}) {\n  // Log initialization\n  Logger.debug('==== Initializing Centralized Neural Simulation System ====');\n  Logger.info('Scene:', scene ? 'Available' : 'Missing');\n  Logger.info('EffectsManager:', effectsManager ? 'Available' : 'Missing');\n  \n  // Initialize the centralized system\n  const { engine, adapter } = initializeCentralizedSystem(scene, effectsManager);\n  \n  // Apply compatibility patches to work with existing code\n  if (options.applyPatches !== false) {\n    applyCompatibilityPatches();\n    Logger.debug('Applied compatibility patches for existing code');\n  }\n  \n  // Register with global application state if available\n  if (window.stateManager) {\n    window.stateManager.registerComponent('neuralEngine', engine);\n    window.stateManager.registerComponent('neuronAdapter', adapter);\n    Logger.debug('Registered neural components with state manager');\n  }\n  \n  // Set up centralized system event listeners\n  setupEventListeners(engine, adapter);\n  \n  Logger.debug('==== Centralized Neural Simulation System Initialization Complete ====');\n  \n  // Return components\n  return {\n    engine,\n    adapter\n  };\n}\n\n/**\n * Set up event listeners for the centralized system\n * @param {Object} engine The neural engine\n * @param {Object} adapter The neuron adapter\n */\nfunction setupEventListeners(engine, adapter) {\n  // Listen for window focus/blur events\n  window.addEventListener('focus', () => {\n    // Resume the simulation when window gains focus\n    if (engine.isPaused) {\n      engine.resume();\n      Logger.debug('[System] Resumed neural simulation');\n    }\n  });\n  \n  window.addEventListener('blur', () => {\n    // Pause the simulation when window loses focus\n    if (!engine.isPaused) {\n      engine.pause();\n      Logger.debug('[System] Paused neural simulation');\n    }\n  });\n  \n  // Listen for scene-specific events if using an event system\n  if (window.eventManager) {\n    // Listen for neuron creation/removal events\n    window.eventManager.addEventListener(window, 'neuronCreated', (event) => {\n      // event.detail would contain the neuron data\n      Logger.debug('[System] Detected neuron creation event');\n    });\n    \n    window.eventManager.addEventListener(window, 'neuronRemoved', (event) => {\n      // event.detail would contain the neuron ID\n      Logger.debug('[System] Detected neuron removal event');\n    });\n  }\n  \n  // Global error handler to prevent simulation crashes\n  window.addEventListener('error', (event) => {\n    Logger.error('[System] Caught global error:', event.error);\n    // Prevent the error from crashing the simulation\n    event.preventDefault();\n  });\n}\n\n// Export the initialization function as default\nexport default initializeCentralizedNeuralSystem; ","/**\n * Integrator - Provides a central point to activate the centralized neural system\n * \n * Usage:\n * 1. Import this file in main.js: import { enableCentralizedNeuralSystem } from './components/core/integrator';\n * 2. Call the function after scene setup: enableCentralizedNeuralSystem(scene, effectsManager);\n * 3. Everything else will be handled automatically\n */\n\nimport initializeCentralizedNeuralSystem from './initializeSystem';\nimport { registerExistingNeurons } from './index';\nimport Logger from '../utils/logger.js';\n\n// Store original objects to support restoring\nlet originalObjects = {\n  Neuron: null,\n  circles: null\n};\n\n// Flag to track if the system is enabled\nlet isEnabled = false;\n\n/**\n * Enable the centralized neural system\n * @param {THREE.Scene} scene The THREE.js scene\n * @param {Object} effectsManager The effects manager (optional)\n * @param {Object} options Additional options\n * @returns {Object} The initialized system components\n */\nexport function enableCentralizedNeuralSystem(scene, effectsManager = null, options = {}) {\n  if (isEnabled) {\n    // Skip non-critical logs\n    return window.neuralSystem || null;\n  }\n  \n  // First check if we have existing neurons to migrate\n  const hasExistingNeurons = window.circles && Array.isArray(window.circles) && window.circles.length > 0;\n  \n  if (hasExistingNeurons) {\n    Logger.debug(`[Integrator] Found ${window.circles.length} existing neurons to migrate`);\n    \n    // Log the IDs of existing neurons for debugging\n    const existingIds = window.circles\n      .filter(circle => circle && circle.neuron)\n      .map(circle => circle.neuron.id || 'unknown');\n    \n    Logger.debug(`[Integrator] Existing neuron IDs: ${existingIds.join(', ')}`);\n  }\n  \n  // Store original objects for potential restoration\n  originalObjects.Neuron = window.Neuron;\n  originalObjects.circles = window.circles ? [...window.circles] : null;\n  \n  // If no scene is provided but it's available globally, use that\n  if (!scene && window.scene) {\n    scene = window.scene;\n    Logger.debug('[Integrator] Using global scene');\n  }\n  \n  // Same for effects manager\n  if (!effectsManager && window.effectsManager) {\n    effectsManager = window.effectsManager;\n    Logger.debug('[Integrator] Using global effects manager');\n  }\n  \n  // Initialize the system\n  const system = initializeCentralizedNeuralSystem(scene, effectsManager, options);\n  \n  // Make the system globally available\n  window.neuralSystem = system;\n  \n  // Log initialization success in a noticeable way\n  Logger.debug('[NEURAL SYSTEM] Centralized neural system ENABLED');\n  Logger.info('- Engine and adapter are available at window.neuralSystem');\n  Logger.debug('- Direct access: window.neuralEngine and window.neuronAdapter');\n  \n  // Verify that neurons were correctly migrated if we had existing ones\n  if (hasExistingNeurons && system.engine) {\n    const migratedNeurons = system.engine.getAllNeurons();\n    Logger.debug(`[Integrator] Neurons in centralized system: ${migratedNeurons.length}`);\n    \n    // Check each neuron for connections\n    migratedNeurons.forEach(neuron => {\n      Logger.debug(`[Integrator] Neuron ${neuron.id} has ${neuron.outgoingConnections.length} connections`);\n    });\n  }\n  \n  // Mark as enabled\n  isEnabled = true;\n  \n  // Return the system components\n  return system;\n}\n\n/**\n * Disable the centralized neural system and restore original behavior\n * @returns {boolean} Success\n */\nexport function disableCentralizedNeuralSystem() {\n  if (!isEnabled) {\n    // Skip non-critical logs\n    return false;\n  }\n  \n  // Clean up neural engine\n  if (window.neuralEngine) {\n    window.neuralEngine.dispose();\n  }\n  \n  // Restore original objects\n  if (originalObjects.Neuron) {\n    window.Neuron = originalObjects.Neuron;\n  }\n  \n  // Restore circles would be complex and is not fully implemented\n  \n  // Mark as disabled\n  isEnabled = false;\n  \n  Logger.debug('[Integrator] Centralized neural system disabled');\n  return true;\n}\n\n/**\n * Check if the centralized neural system is enabled\n * @returns {boolean} Whether the system is enabled\n */\nexport function isCentralizedNeuralSystemEnabled() {\n  return isEnabled;\n}\n\n/**\n * Get access to the neural engine and adapter\n * @returns {Object} The neural engine and adapter\n */\nexport function getNeuralSystem() {\n  if (!isEnabled) {\n    // Skip non-critical logs\n    return null;\n  }\n  \n  return {\n    engine: window.neuralEngine,\n    adapter: window.neuronAdapter\n  };\n}\n\n/**\n * Utility function to fix neuron registration issues\n * This can be called directly from the console or by application code\n * @returns {boolean} Success flag\n */\nexport function fixNeuronRegistration() {\n  if (!isEnabled) {\n    Logger.error('[Integrator] Cannot fix neurons - centralized system not enabled');\n    return false;\n  }\n  \n  // Ensure neuronEngine and adapter are available\n  if (!window.neuralEngine || !window.neuronAdapter) {\n    Logger.error('[Integrator] Cannot fix neurons - missing engine or adapter');\n    return false;\n  }\n  \n  // Re-register all existing neurons\n  registerExistingNeurons();\n  \n  return true;\n}\n\n// Make the fix function globally available for debugging\nif (typeof window !== 'undefined') {\n  window.fixNeuralSystem = fixNeuronRegistration;\n} ","import * as THREE from 'three';\nimport gsap from 'gsap';\nimport { ensureManagersInitialized } from './utils/initSystemManagers';\nimport { enableCentralizedNeuralSystem } from './core/integrator';\n\nexport class Neuron {\n    // Ensure Neuron class is accessible in the global scope\n    static {\n        if (typeof window !== 'undefined') {\n            window.Neuron = Neuron;\n        }\n    }\n    static isScrolling = false;\n    static scrollTimeout = null;\n    static neuronCount = 0;\n    \n    // Track window focus state\n    static windowHasFocus = true;\n    // Track if application is actively running\n    static isAppActive = true;\n    \n    // Track neurons with DC input\n    static dcNeurons = new Set();\n    \n    // Pre-allocate reusable objects\n    static tempVector = new THREE.Vector3();\n    static tempVector2 = new THREE.Vector3();\n    static tempColor = new THREE.Color();\n\n    // Static initialization block\n    static {\n        // Pre-allocate reusable geometry\n        this.particleGeometry = new THREE.PlaneGeometry(0.05, 0.05);\n        this.particleGeometry.computeBoundingSphere();\n        \n        // Global array to track all particles for deletion purposes\n        this.allParticles = [];\n        \n        // Track pending charge deliveries for cleanup when connections are deleted\n        this.pendingChargeDeliveries = new Map();\n        \n        // Track when the last particle cleanup occurred\n        this.lastParticleCleanupTime = Date.now();\n        \n        // Set up periodic particle cleanup to catch any orphaned particles\n        // This runs every 5 seconds and removes particles with invalid sources/targets\n        if (typeof window !== 'undefined' && window.timerManager) {\n            window.timerManager.setInterval('neuron_particle_cleanup', () => {\n                // Only run if we have particles to clean up\n                if (this.allParticles && this.allParticles.length > 0) {\n                    this.cleanupOrphanedParticles();\n                }\n            }, 5000);\n        }\n        \n        // Ensure the TimerManager is initialized\n        ensureManagersInitialized();\n        \n        // Add event listeners for window focus/blur to handle DC intervals properly\n        window.addEventListener('focus', () => {\n            console.log('Window gained focus - restoring DC intervals');\n            this.windowHasFocus = true;\n            this.isAppActive = true;\n            \n            // Restore DC inputs for all tracked neurons\n            this.dcNeurons.forEach(neuron => {\n                if (neuron && neuron.dcInput > 0) {\n                    // Store the current DC value\n                    const dcValue = neuron.dcInput;\n                    \n                    // Force clear the interval first\n                    if (neuron.dcInterval) {\n                        if (window.timerManager && neuron.dcParameters?.usingRAF) {\n                            window.timerManager.cancelAnimationFrame('neuron_' + neuron.id, neuron.dcInterval);\n                        } else if (neuron.dcParameters?.usingRAF) {\n                            cancelAnimationFrame(neuron.dcInterval);\n                        } else {\n                            clearInterval(neuron.dcInterval);\n                        }\n                        neuron.dcInterval = null;\n                    }\n                    \n                    // Re-establish the DC input with a short delay to ensure proper timing\n                    setTimeout(() => {\n                        neuron.setDCInput(dcValue, false, true);\n                    }, 50);\n                }\n            });\n            \n            // Also ensure the audio context resumes\n            if (window.Tone && window.Tone.context && window.Tone.context.state === 'suspended') {\n                window.Tone.context.resume();\n                console.log('Resumed Tone.js audio context');\n            }\n            // Restore all neuron sound assignments\n            if (window.soundManager && typeof window.soundManager.restoreAllNeuronSounds === 'function') {\n                window.soundManager.restoreAllNeuronSounds();\n            }\n        });\n        \n        window.addEventListener('blur', () => {\n            console.log('Window lost focus - stopping all DC intervals and audio');\n            this.windowHasFocus = false;\n            this.isAppActive = false;\n            \n            // Stop all DC neurons from firing when window loses focus\n            this.dcNeurons.forEach(neuron => {\n                if (neuron && neuron.dcInput > 0) {\n                    // Force clear the interval to stop firing\n                    if (neuron.dcInterval) {\n                        if (window.timerManager && neuron.dcParameters?.usingRAF) {\n                            window.timerManager.cancelAnimationFrame('neuron_' + neuron.id, neuron.dcInterval);\n                        } else if (neuron.dcParameters?.usingRAF) {\n                            cancelAnimationFrame(neuron.dcInterval);\n                        } else {\n                            clearInterval(neuron.dcInterval);\n                        }\n                        neuron.dcInterval = null;\n                    }\n                }\n            });\n            \n            // Suspend audio context to stop all sound immediately\n            if (window.Tone && window.Tone.context && window.Tone.context.state === 'running') {\n                window.Tone.context.suspend();\n                console.log('Suspended Tone.js audio context');\n            }\n            \n            // Additionally silence all neurons via SoundManager if available\n            if (window.soundManager && typeof window.soundManager.silenceAllNeurons === 'function') {\n                window.soundManager.silenceAllNeurons();\n                console.log('Silenced all neurons via SoundManager');\n            }\n        });\n        \n        // Also add visibilitychange event to handle tab visibility\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                console.log('Tab hidden - stopping all DC intervals and audio');\n                this.isAppActive = false;\n                \n                // Stop all DC neurons from firing when tab is hidden\n                this.dcNeurons.forEach(neuron => {\n                    if (neuron && neuron.dcInput > 0) {\n                        // Force clear the interval to stop firing\n                        if (neuron.dcInterval) {\n                            if (window.timerManager && neuron.dcParameters?.usingRAF) {\n                                window.timerManager.cancelAnimationFrame('neuron_' + neuron.id, neuron.dcInterval);\n                            } else if (neuron.dcParameters?.usingRAF) {\n                                cancelAnimationFrame(neuron.dcInterval);\n                            } else {\n                                clearInterval(neuron.dcInterval);\n                            }\n                            neuron.dcInterval = null;\n                        }\n                    }\n                });\n                \n                // Suspend audio context to stop all sound immediately\n                if (window.Tone && window.Tone.context && window.Tone.context.state === 'running') {\n                    window.Tone.context.suspend();\n                    console.log('Suspended Tone.js audio context due to tab hidden');\n                }\n            } else {\n                console.log('Tab visible again - restoring DC intervals');\n                \n                // Only restore if the window has focus\n                if (this.windowHasFocus) {\n                    this.isAppActive = true;\n                    \n                    // Restore DC inputs for all tracked neurons with a short delay to sync timing\n                    setTimeout(() => {\n                        this.dcNeurons.forEach(neuron => {\n                            if (neuron && neuron.dcInput > 0) {\n                                // Store the current DC value\n                                const dcValue = neuron.dcInput;\n                                \n                                // Force clear the interval first\n                                if (neuron.dcInterval) {\n                                    if (window.timerManager && neuron.dcParameters?.usingRAF) {\n                                        window.timerManager.cancelAnimationFrame('neuron_' + neuron.id, neuron.dcInterval);\n                                    } else if (neuron.dcParameters?.usingRAF) {\n                                        cancelAnimationFrame(neuron.dcInterval);\n                                    } else {\n                                        clearInterval(neuron.dcInterval);\n                                    }\n                                    neuron.dcInterval = null;\n                                }\n                                \n                                // Re-establish the DC input\n                                neuron.setDCInput(dcValue, false, true);\n                            }\n                        });\n                        \n                        // Resume audio context\n                        if (window.Tone && window.Tone.context && window.Tone.context.state === 'suspended') {\n                            window.Tone.context.resume();\n                            console.log('Resumed Tone.js audio context');\n                        }\n                    }, 50);\n                }\n            }\n        });\n        \n        // Also add a periodic checker to ensure DC inputs are maintained even during long unfocused periods\n        let checkerId = null;\n        const startPeriodicChecker = () => {\n            // Use TimerManager for better reliability\n            if (window.timerManager) {\n                checkerId = window.timerManager.setInterval('neuron_dc_checker', () => {\n                    // Only run this check if we have focus and the page is visible\n\n                    \n                    // Make sure scrolling state gets cleared properly after inactivity\n                    if (this.isScrolling) {\n                        if (!this.scrollTimeout) {\n                            this.scrollTimeout = setTimeout(() => {\n                                this.isScrolling = false;\n                                this.scrollTimeout = null;\n                                console.log(\"Clearing scrolling state after inactivity\");\n                            }, 300);\n                        }\n                    }\n                }, 1000);\n            } else {\n                // Fallback to regular setInterval\n                checkerId = setInterval(() => {\n                    // Only run this check if we have focus and the page is visible\n                    if (this.windowHasFocus && !document.hidden) {\n                        this.dcNeurons.forEach(neuron => {\n                            if (neuron && neuron.dcInput > 0 && !neuron.dcInterval) {\n                                console.log(`Restoring missing DC interval for neuron ${neuron.id}`);\n                                neuron.setDCInput(neuron.dcInput, false, true);\n                            }\n                        });\n                    }\n                    \n                    // Make sure scrolling state gets cleared properly after inactivity\n                    if (this.isScrolling) {\n                        if (!this.scrollTimeout) {\n                            this.scrollTimeout = setTimeout(() => {\n                                this.isScrolling = false;\n                                this.scrollTimeout = null;\n                                console.log(\"Clearing scrolling state after inactivity\");\n                            }, 300);\n                        }\n                    }\n                }, 1000);\n            }\n        };\n        \n        // Start the checker\n        startPeriodicChecker();\n    }\n\n    // Shared particle material\n    static particleMaterial = new THREE.MeshBasicMaterial({\n        color: 0x00ffff,\n        transparent: true,\n        opacity: 0.8\n    });\n\n    constructor(mesh) {\n        this.id = ++Neuron.neuronCount;\n        mesh.position.y = -0.01 + (this.id * 0.1);\n        this.mesh = mesh;\n\n        // Constants\n        this.threshold = 1;\n        this.chargeRate = 0.01;\n        this.chargingInterval = 1000;\n        this.baseScale = 0.2;\n        this.maxScale = 1;\n        this.refractionPeriod = 10;\n        this.originalColor = 0x0000ff; // Pure Blue\n        this.firingColor = 0xffff00; // Pure Yellow\n        \n        // Add preset colors support\n        this.presetColor = null;  // THREE.Color object when a preset is applied\n        this.presetName = null;   // Name of the applied preset\n        \n        // Add envelope details storage here\n        this.currentEnvelope = {\n            attack: 0,\n            sustain: 0,\n            release: 0\n        };\n        \n        // State\n        this.currentCharge = 0;\n        this.lastFiredTime = 0;\n        this.isFiring = false;\n        this.dcInput = 0;\n        this.dcInterval = null;\n        \n        // Musical harmony settings\n        this.isHarmonyAnchor = false; // Added: neurons marked as anchors resist harmonic influence\n        \n        // Scale management - NEW unified system\n        this.scaleState = {\n            base: this.baseScale,\n            target: this.baseScale,\n            current: this.baseScale,\n            animation: null,\n            animating: false,\n            lastUpdate: 0\n        };\n        \n        // Optimized collections\n        this.outgoingConnections = new Set();\n        this.synapticWeights = new Map();\n        this.synapticSpeeds = new Map();\n        \n        // Animation management\n        this.currentAnimation = null;\n        this.particleAnimations = new Set();\n        this.lastUpdateTime = performance.now();\n        \n        // Add flag to control external animations\n        this.externalAnimationActive = false;\n        this.externalAnimationEndTime = 0;\n        \n        // Add flag to track refractory period for more precise control\n        this.inRefractoryPeriod = false;\n        this.refractoryEndTime = 0;\n        this.lastFiringAttempt = 0; // Track when we last tried to fire\n        this.minTimeBetweenFirings = 50; // Minimum 50ms between firing attempts\n        \n        // Initialize color update tracking\n        this.lastColorUpdate = {\n            isFiring: false,\n            currentCharge: 0,\n            colorUpdateNeeded: true // Set to true initially to force first update\n        };\n    \n        // Set initial scale\n        this.mesh.scale.setScalar(this.baseScale);\n    }\n\n    // Method to temporarily block color updates during external animations\n    setExternalAnimation(duration = 500) {\n        this.externalAnimationActive = true;\n        this.externalAnimationEndTime = performance.now() + duration;\n        \n        // Set a timeout to reset the flag\n        setTimeout(() => {\n            this.externalAnimationActive = false;\n        }, duration);\n        \n        return this;\n    }\n\n    update() {\n        const currentTime = performance.now();\n\n        // Safety check for stuck firing state\n        if (this.isFiring && currentTime - this.lastFiredTime > this.refractionPeriod * 2) {\n            this.forceReset();\n            return;\n        }\n\n        // Update refractory period state\n        if (this.inRefractoryPeriod && currentTime >= this.refractoryEndTime) {\n            this.inRefractoryPeriod = false;\n            this.refractoryEndTime = 0;\n        }\n\n        // Only check for DC firing if DC input is greater than 0\n        if (!this.isFiring && !this.isInRefractoryPeriod() && this.dcInput > 0) {\n            // If we're scrolling and the DC interval got lost, restore it\n            if ((Neuron.isScrolling || document.hidden) && this.dcInput > 0 && !this.dcInterval) {\n                // Re-create charging interval based on stored parameters\n                if (this.dcParameters) {\n                    // Use the exact same parameters that were calculated before\n                    const { chargePerInterval, intervalTime } = this.dcParameters;\n                    \n                    this.dcInterval = setInterval(() => {\n                        if (!this.isFiring && !this.isInRefractoryPeriod()) {\n                            this.addCharge(chargePerInterval);\n                        }\n                    }, intervalTime);\n                } else {\n                    // If parameters weren't stored for some reason, recreate with current settings\n                    this.setDCInput(this.dcInput);\n                }\n            }\n        }\n\n        // Check if we need to update color based on firing state changes\n        let colorUpdateNeeded = false;\n        \n        // Handle firing state and visual effects\n        if (!this.externalAnimationActive) {\n            if (this.isFiring) {\n                const timeSinceFiring = currentTime - this.lastFiredTime;\n                if (timeSinceFiring < this.refractionPeriod) {\n                    // Only update color if firing state changed\n                    if (!this.lastColorUpdate.isFiring) {\n                        colorUpdateNeeded = true;\n                    }\n                } else {\n                    // Firing ended\n                    this.isFiring = false;\n                    this.currentCharge = 0; // Reset charge when firing ends\n                    this.inRefractoryPeriod = true;\n                    this.refractoryEndTime = currentTime + 50; // 50ms additional refractory period\n                    colorUpdateNeeded = true;\n                }\n            }\n        } else if (currentTime > this.externalAnimationEndTime) {\n            // Animation expired but flag not reset\n            this.externalAnimationActive = false;\n            colorUpdateNeeded = true;\n        }\n\n        // Mark that we need a color update if state changed\n        if (colorUpdateNeeded) {\n            this.lastColorUpdate.colorUpdateNeeded = true;\n        }\n\n        // Update scale based on state, but only update colors when necessary\n        this.updateVisualState();\n    }\n\n    // Color updates are now managed through this.lastColorUpdate\n    // which is initialized in the constructor\n    \n    updateVisualState() {\n        if (!this.mesh) return;\n\n        // Calculate base scale from DC input with more gradual increase\n        const dcScale = this.baseScale + (this.maxScale - this.baseScale) * Math.min(1.0, this.dcInput);\n        \n        // Calculate charge scale with more controlled growth\n        let chargeScale;\n        \n        // Different scaling approach based on DC input level\n        if (this.dcInput > 0.5) {\n            // For high DC input, use a milder charge scale factor to prevent excessive growth\n            chargeScale = dcScale * (1 + (this.currentCharge / this.threshold) * 0.3);\n        } else {\n            // For low or no DC input, allow more dramatic charge scaling\n            chargeScale = dcScale * (1 + (this.currentCharge / this.threshold) * 0.5);\n        }\n        \n        // Apply absolute maximum scale limit\n        const ABSOLUTE_MAX_SCALE = 0.8; // Hard limit on maximum size\n        const cappedScale = Math.min(chargeScale, ABSOLUTE_MAX_SCALE);\n        \n        // Update scale state\n        this.scaleState.base = dcScale;\n        \n        // Apply damping to target scale changes to prevent jitter\n        const previousTarget = this.scaleState.target;\n        const newTarget = this.isFiring ? this.scaleState.current : cappedScale;\n        \n        // Apply damping for smoother transitions (reduce by 90%)\n        const damping = 0.9;\n        this.scaleState.target = previousTarget \n            ? previousTarget + (newTarget - previousTarget) * (1 - damping)\n            : newTarget;\n        \n        // IMPORTANT FIX: Enforce absolute maximum scale to prevent indefinite growth\n        this.scaleState.target = Math.min(this.scaleState.target, ABSOLUTE_MAX_SCALE);\n        \n        // Only apply scale directly if no animation is running\n        if (!this.scaleState.animating) {\n            // IMPORTANT FIX: Apply the target scale directly, don't allow previous scaling to affect it\n            this.mesh.scale.set(this.scaleState.target, this.scaleState.target, this.scaleState.target);\n            this.scaleState.current = this.scaleState.target;\n        }\n        \n        // Only check for the explicit flag for color updates - ignoring charge and firing states\n        const initialUpdate = this.lastColorUpdate.colorUpdateNeeded;\n        \n        // Only update colors when explicitly requested (e.g., when instrument changes)\n        if (!this.externalAnimationActive && initialUpdate) {\n            // If a preset color is available, use it as the base color\n            if (this.presetColor) {\n                // Just use the preset color directly - no charge or firing state effects\n                this.mesh.material.color.copy(this.presetColor);\n            } else {\n                // Default behavior for non-preset neurons - plain blue\n                this.mesh.material.color.setHex(this.originalColor);\n            }\n            \n            // Store current values for next comparison\n            this.lastColorUpdate.isFiring = this.isFiring;\n            this.lastColorUpdate.currentCharge = this.currentCharge;\n            this.lastColorUpdate.colorUpdateNeeded = false;\n        }\n    }\n\n    fire() {\n        // Enforce minimum time between firings to prevent double-firing\n        const currentTime = performance.now();\n        const timeSinceLastAttempt = currentTime - this.lastFiringAttempt;\n        \n        // Update last attempt time\n        this.lastFiringAttempt = currentTime;\n        \n        // If we're already firing or in refractory period, don't allow new firing\n        if (this.isFiring || this.isInRefractoryPeriod()) {\n            return;\n        }\n        \n        // Enforce minimum time between firing attempts (prevents double-firing)\n        if (timeSinceLastAttempt < this.minTimeBetweenFirings) {\n            return;\n        }\n        \n        // We are now firing!\n        this.isFiring = true;\n        this.lastFiredTime = currentTime;\n        \n        // Gather connection data for sound and animation\n        const connectionCount = this.outgoingConnections.size;\n        let totalWeight = 0;\n        let totalSpeed = 0;\n        let totalDistance = 0;\n    \n        for (const targetIndex of this.outgoingConnections) {\n            const weight = this.synapticWeights.get(targetIndex) ?? 0.1;\n            const speed = this.synapticSpeeds.get(targetIndex) ?? 0.5;\n            totalWeight += weight;\n            totalSpeed += speed;\n            \n            if (window.circles?.[targetIndex]) {\n                const target = window.circles[targetIndex];\n                const dx = target.position.x - this.mesh.position.x;\n                const dz = target.position.z - this.mesh.position.z;\n                totalDistance += Math.sqrt(dx * dx + dz * dz);\n            }\n        }\n        \n        let avgWeight = connectionCount > 0 ? totalWeight / connectionCount : 0.5;\n        let avgSpeed = connectionCount > 0 ? totalSpeed / connectionCount : 0.5;\n        let avgDistance = connectionCount > 0 ? totalDistance / connectionCount : 0;\n        \n        // Cap at reasonable values to prevent extreme results\n        avgWeight = Math.min(1, Math.max(0.1, avgWeight));\n        avgSpeed = Math.min(1, Math.max(0.1, avgSpeed));\n        avgDistance = Math.min(20, Math.max(1, avgDistance));\n    \n        // Update envelope details with minimum values\n        this.currentEnvelope = {\n            attack: Math.max(0.1, avgWeight ? (0.45 - (avgWeight * 0.45)).toFixed(2) : 0.1),\n            sustain: Math.max(0.2, avgWeight ? (avgWeight * 0.3).toFixed(2) : 0.2),\n            release: Math.max(0.1, avgDistance < 6 ? 0.1 : (Math.min(avgDistance, 10) / 10 * 0.5).toFixed(2))\n        };\n    \n        // Play sound\n        if (window.soundManager && typeof window.soundManager.playNeuronFiring === 'function') {\n            window.soundManager.playNeuronFiring(\n                avgWeight, \n                avgSpeed, \n                this.id,\n                connectionCount === 0,\n                this.dcInput > 0,\n                avgDistance\n            );\n        }\n        \n        // Visual firing animation\n        this.animateFiring();\n    \n        // Process outgoing connections - simple and direct\n        for (const targetIndex of this.outgoingConnections) {\n            const targetNeuron = window.circles?.[targetIndex]?.neuron;\n            if (!targetNeuron) continue;\n            \n            const weight = this.synapticWeights.get(targetIndex) ?? 0.1;\n            const speed = this.synapticSpeeds.get(targetIndex) ?? 0.5;\n            \n            // High speed (near 1.0) means almost instant delivery\n            const delay = speed >= 0.99 ? 0 : Math.max(50, (1 - speed) * 500);\n            console.log(`Connection from=${this.id} to=${targetIndex}: speed=${speed.toFixed(2)}, delay=${delay}ms`);\n            \n            // Create a unique connection identifier\n            const connectionId = `${this.id}_${targetNeuron.id}`;\n            \n            // Clear any existing pending deliveries for this connection\n            if (Neuron.pendingChargeDeliveries.has(connectionId)) {\n                clearTimeout(Neuron.pendingChargeDeliveries.get(connectionId));\n                Neuron.pendingChargeDeliveries.delete(connectionId);\n            }\n            \n            // Store the timeout reference so it can be canceled if the connection is deleted\n            const timeoutId = setTimeout(() => {\n                // Remove from pending deliveries when executed\n                Neuron.pendingChargeDeliveries.delete(connectionId);\n                \n                // Check if the connection still exists before delivering charge\n                if (this.outgoingConnections.has(targetIndex) && targetNeuron) {\n                    if (delay === 0) {\n                        // Instant delivery without visual effect\n                        targetNeuron.addCharge(weight);\n                    } else {\n                        // Use OptimizedParticleSystem if available, otherwise fall back to legacy system\n                        if (window.particleSystem && typeof window.particleSystem.createParticle === 'function') {\n                            // Calculate source and target positions\n                            const sourcePos = new THREE.Vector3(\n                                this.mesh.position.x,\n                                0.05,\n                                this.mesh.position.z\n                            );\n                            \n                            const targetPos = new THREE.Vector3(\n                                window.circles[targetIndex].position.x,\n                                0.05,\n                                window.circles[targetIndex].position.z\n                            );\n                            \n                            console.log(`Creating optimized particle: from=${this.id} to=${targetIndex}, speed=${speed.toFixed(2)}`);\n                            window.particleSystem.createParticle(\n                                sourcePos,\n                                targetPos,\n                                this.id,\n                                targetNeuron.id,\n                                weight,\n                                speed\n                            );\n                        } else {\n                            // Fall back to legacy particle system\n                            console.warn(`Falling back to legacy particle system: from=${this.id} to=${targetIndex}, speed=${speed.toFixed(2)}`);\n                            this.createAndAnimateSignalParticle(targetIndex, weight, speed, targetNeuron);\n                        }\n                    }\n                }\n            }, delay);\n            \n            // Store in the static map for potential cancellation\n            Neuron.pendingChargeDeliveries.set(connectionId, timeoutId);\n        }\n        \n        this.updateVisualState();\n    }\n    \n    // Visual animation for firing, simplified with no color changes\n    animateFiring() {\n        // No color updates during firing - only update state and trigger refractory period\n        \n        // Add refractory period after a short delay\n        setTimeout(() => {\n            // Reset firing state\n            this.isFiring = false;\n            this.currentCharge = 0;\n            \n            // Set refractory period\n            this.inRefractoryPeriod = true;\n            this.refractoryEndTime = performance.now() + 50;\n            \n            // Only update scale, not color\n            this.updateVisualState();\n        }, 150);\n    }\n    \n    /**\n     * Propagate DC input to connected neurons\n     * This is called when the neuron fires and has a non-zero DC input\n     */\n    // DC doesn't propagate between neurons in a true SNN\n    // Removed propagateDC method\n\n    createAndAnimateSignalParticle(targetIndex, weight, speed, targetNeuron) {\n        console.log(`Creating signal particle: target=${targetIndex}, weight=${weight.toFixed(2)}, speed=${speed.toFixed(2)}`);\n        \n        if (!this.mesh || !this.mesh.parent || !window.circles[targetIndex]) return;\n        \n        // Calculate source and target positions\n        const sourcePos = new THREE.Vector3(\n            this.mesh.position.x,\n            0.05,\n            this.mesh.position.z\n        );\n        \n        const targetPos = new THREE.Vector3(\n            window.circles[targetIndex].position.x,\n            0.05,\n            window.circles[targetIndex].position.z\n        );\n        \n        // Handle instant signal for high speeds\n        if (speed >= 0.99) {\n            console.log(`Speed too high (${speed.toFixed(2)}), skipping particle creation`);\n            if (targetNeuron) {\n                targetNeuron.addCharge(weight);\n            }\n            return;\n        }\n        \n        // Create a particle\n        // Create a particle traveling from source to target\n        const geometry = new THREE.SphereGeometry(0.15, 8, 8); // Increased size from 0.05 to 0.15\n        \n        // Set particle color based on weight (hue varies with weight)\n        const color = new THREE.Color();\n        // Create a color based on weight - higher weight = more red/yellow\n        color.setHSL(weight * 0.3, 1, 0.5);\n        \n        const material = new THREE.MeshBasicMaterial({ \n            color,\n            transparent: true,\n            opacity: 1.0 // Increased opacity from 0.8 to 1.0\n        });\n        \n        const particle = new THREE.Mesh(geometry, material);\n        \n        // Position at source\n        particle.position.copy(sourcePos);\n        \n        // Store information for animation\n        particle.targetPosition = targetPos.clone();\n        particle.sourcePosition = sourcePos.clone();\n        particle.progress = 0;\n        particle.speed = 0.01 + (speed * 0.04); // Scale speed for animation (0.01-0.05)\n        particle.sourceNeuronId = this.id;\n        particle.targetNeuronId = targetNeuron ? targetNeuron.id : null;\n        particle.creationTime = Date.now(); // Store creation time for cleanup\n        particle.connectionId = `${this.id}_${targetNeuron ? targetNeuron.id : targetIndex}`; // Store connection ID\n        \n        // Add to scene and tracking\n        if (window.scene) {\n            window.scene.add(particle);\n            console.log(`Added particle to scene, current particles: ${window.Neuron.allParticles?.length || 0}`);\n        } else if (this.mesh.parent) {\n            this.mesh.parent.add(particle);\n            console.log(`Added particle to mesh.parent, current particles: ${window.Neuron.allParticles?.length || 0}`);\n        } else {\n            console.warn(\"Could not add particle to any scene!\");\n            return;\n        }\n        \n        // Initialize global tracking array if needed\n        if (!window.Neuron.allParticles) {\n            window.Neuron.allParticles = [];\n        }\n        \n        // Add to global tracking array\n        window.Neuron.allParticles.push(particle);\n        \n        // Calculate delay based on distance and speed for charge delivery\n        const distance = sourcePos.distanceTo(targetPos);\n        \n        // Base delay is proportional to animation time\n        // For speed=0.1: particle.speed~0.014 -> ~71 frames to travel (1166ms at 60fps)\n        // For speed=0.9: particle.speed~0.046 -> ~22 frames to travel (366ms at 60fps)\n        const baseDelay = 500; // ms\n        const speedFactor = 1 - speed;\n        const delay = baseDelay * speedFactor * (distance / 5);\n        \n        // Create a unique connection identifier - same format used in the fire method\n        const connectionId = `${this.id}_${targetNeuron ? targetNeuron.id : targetIndex}`;\n        \n        // Clear any existing pending deliveries for this connection\n        if (Neuron.pendingChargeDeliveries.has(connectionId)) {\n            clearTimeout(Neuron.pendingChargeDeliveries.get(connectionId));\n            Neuron.pendingChargeDeliveries.delete(connectionId);\n        }\n        \n        // Store the timeout reference so it can be canceled if the connection is deleted\n        const timeoutId = setTimeout(() => {\n            // Remove from pending deliveries when executed\n            Neuron.pendingChargeDeliveries.delete(connectionId);\n            \n            // Check if the connection still exists before delivering charge\n            if (this.outgoingConnections.has(targetIndex) && targetNeuron) {\n                targetNeuron.addCharge(weight);\n            }\n            \n            // Clean up this specific particle if it still exists\n            if (particle && particle.parent) {\n                particle.parent.remove(particle);\n                if (particle.material) particle.material.dispose();\n                if (particle.geometry) particle.geometry.dispose();\n                \n                // Remove from tracking array\n                const index = Neuron.allParticles.indexOf(particle);\n                if (index !== -1) Neuron.allParticles.splice(index, 1);\n            }\n        }, delay);\n        \n        // Store in the static map for potential cancellation\n        Neuron.pendingChargeDeliveries.set(connectionId, timeoutId);\n        \n        // Store the timeout ID directly on the particle for immediate cleanup\n        particle.timeoutId = timeoutId;\n    }\n\n    setDCInput(value, resetCharge = false, preserveContinuity = true) {\n        const previousDC = this.dcInput;\n        \n        // Just clamp value between 0 and 1, no rounding\n        this.dcInput = Math.max(0, Math.min(1, value));\n        \n        // No longer updating color when DC input changes\n        \n        // If DC input is 0, reset the neuron and remove from tracking\n        if (this.dcInput <= 0) {\n            // Always clear interval if DC = 0\n            if (this.dcInterval) {\n                if (window.timerManager && this.dcParameters?.usingRAF) {\n                    window.timerManager.cancelAnimationFrame('neuron_' + this.id, this.dcInterval);\n                } else if (this.dcParameters?.usingRAF) {\n                    cancelAnimationFrame(this.dcInterval);\n                } else {\n                    clearInterval(this.dcInterval);\n                }\n                this.dcInterval = null;\n            }\n            \n            Neuron.dcNeurons.delete(this);\n            this.forceReset();\n            return;\n        }\n        \n        // CRITICAL IMPROVEMENT: Use the timerManager if available\n        // Track this neuron even before we decide whether to recreate the timer\n        if (this.dcInput > 0) {\n            Neuron.dcNeurons.add(this);\n        }\n        \n        // IMPORTANT: This is a critical part that ensures continuous firing.\n        // We'll now avoid recreating the timer in even more cases to maintain rhythm.\n        // Only recreate the timer if:\n        // 1. No timer exists yet\n        // 2. DC was previously 0 (neuron was off)\n        // 3. User explicitly requested a reset AND not preserving continuity\n        const needsTimerRecreation = !this.dcInterval || \n                                    previousDC === 0 ||\n                                    (resetCharge === true && preserveContinuity === false);\n        \n        // Update visual state immediately \n        this.updateVisualState();\n        \n        // If we can preserve continuity and already have a timer running, don't recreate it\n        if (!needsTimerRecreation) {\n            // Just update the dc parameters without stopping the timer\n            // Reduced for more subtle control at low DC values\n            const baseChargeRate = 0.04;\n            const chargePerFrame = baseChargeRate * this.dcInput;\n            \n            // Update parameters without stopping firing cycle\n            if (this.dcParameters) {\n                this.dcParameters.chargePerFrame = chargePerFrame;\n            } else {\n                this.dcParameters = {\n                    chargePerFrame: chargePerFrame,\n                    usingRAF: true\n                };\n            }\n            \n            return; // Exit early to maintain continuity\n        }\n        \n        // If we're here, we need to recreate the timer\n        \n        // Clear any existing interval if we need to recreate it\n        if (this.dcInterval) {\n            if (window.timerManager && this.dcParameters?.usingRAF) {\n                window.timerManager.cancelAnimationFrame('neuron_' + this.id, this.dcInterval);\n            } else if (this.dcParameters?.usingRAF) {\n                cancelAnimationFrame(this.dcInterval);\n            } else {\n                clearInterval(this.dcInterval);\n            }\n            this.dcInterval = null;\n        }\n        \n        // Only start DC charging if the app is active (window has focus and tab is visible)\n        if (this.dcInput > 0 && Neuron.isAppActive) {\n            // Set base charge rate - how quickly DC adds charge each frame\n            // Reduced for more subtle control at low DC values\n            const baseChargeRate = 0.04;\n            \n            // Calculate charge per frame based on DC input\n            const chargePerFrame = baseChargeRate * this.dcInput;\n            \n            // Reset neuron state only in specific circumstances\n            // - If explicitly requested\n            // - If DC was previously 0 (neuron was off)\n            // - But NOT during normal interaction like selecting or connecting\n            if (resetCharge || previousDC === 0) {\n                this.currentCharge = 0;\n                this.isFiring = false;\n                this.lastFiredTime = 0;\n                this.inRefractoryPeriod = false;\n                this.refractoryEndTime = 0;\n            }\n            \n            // Store parameters for restoration\n            this.dcParameters = {\n                chargePerFrame: chargePerFrame,\n                usingRAF: true\n            };\n            \n            // Create charge update function that's more resilient to errors\n            const updateCharge = (timestamp) => {\n                // Safety checks\n                if (!this.mesh || this.dcInput <= 0) {\n                    return false; // Stop the animation loop\n                }\n                \n                try {\n                    // Add charge if not firing or in refractory period\n                    if (!this.isFiring && !this.isInRefractoryPeriod()) {\n                        this.addCharge(this.dcParameters.chargePerFrame); // Use current parameter value\n                    }\n                } catch (error) {\n                    console.error(`Error in DC update for neuron ${this.id}:`, error);\n                    // Don't return false here - keep the timer running even if there's an error\n                }\n                \n                return true; // Continue the animation loop\n            };\n            \n            // Use timerManager if available for better reliability\n            if (window.timerManager) {\n                this.dcInterval = window.timerManager.requestAnimationFrame(\n                    'neuron_' + this.id,\n                    updateCharge\n                );\n                \n                // Track this neuron in our global list\n                Neuron.dcNeurons.add(this);\n            } else {\n                // Use direct requestAnimationFrame as fallback\n                const rafCallback = (timestamp) => {\n                    if (updateCharge(timestamp) && this.dcInput > 0) {\n                        this.dcInterval = requestAnimationFrame(rafCallback);\n                    } else {\n                        this.dcInterval = null;\n                    }\n                };\n                this.dcInterval = requestAnimationFrame(rafCallback);\n            }\n            \n            // Register with global tracker\n            if (!window.activeDCNeurons) window.activeDCNeurons = new Set();\n            window.activeDCNeurons.add(this);\n        } else if (this.dcInput > 0) {\n            // If app not active, store parameters for later\n            // Reduced for more subtle control at low DC values\n            const baseChargeRate = 0.04;\n            const chargePerFrame = baseChargeRate * this.dcInput;\n            \n            this.dcParameters = {\n                chargePerFrame: chargePerFrame,\n                usingRAF: true\n            };\n        }\n    }\n\n    addCharge(amount) {\n        // Don't add charge if we're already firing or in refractory period\n        if (this.isFiring || this.isInRefractoryPeriod()) {\n            return;\n        }\n        \n        // Allow neurons with DC=0 to receive input charges from other neurons\n        // The DC is only used for auto-charging, not for receiving signals\n    \n        const previousCharge = this.currentCharge;\n        this.currentCharge = Math.min(this.currentCharge + amount, this.threshold);\n    \n        // Update visual state when charge changes\n        if (this.currentCharge !== previousCharge) {\n            // No longer updating color for charge changes\n            this.lastColorUpdate.currentCharge = this.currentCharge;\n            \n            this.updateVisualState();\n            \n            // Fire event for UI updates\n            if (window.dispatchEvent && typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent('neuronChargeUpdate', { \n                    detail: { \n                        neuronId: this.id, \n                        charge: this.currentCharge,\n                        threshold: this.threshold,\n                        isFiring: this.isFiring,\n                        inRefractory: this.isInRefractoryPeriod(),\n                        dcInput: this.dcInput\n                    } \n                }));\n            }\n        }\n    \n        // Check if threshold reached - fire the neuron\n        if (this.currentCharge >= this.threshold && !this.isFiring) {\n            this.fire();\n        }\n    }\n\n    forceReset() {\n        // Kill any ongoing animations\n        if (this.currentAnimation) {\n            this.currentAnimation.kill(null, false);\n            this.currentAnimation = null;\n        }\n        \n        // Kill scale animation\n        if (this.scaleState.animation) {\n            this.scaleState.animation.kill();\n            this.scaleState.animation = null;\n            this.scaleState.animating = false;\n        }\n        \n        // Reset all state\n        this.isFiring = false;\n        this.currentCharge = 0;\n        this.lastFiredTime = 0;\n        \n        // Cancel animation frame or clear interval properly\n        if (this.dcInterval) {\n            if (window.timerManager && this.dcParameters?.usingRAF) {\n                window.timerManager.cancelAnimationFrame('neuron_' + this.id, this.dcInterval);\n            } else if (this.dcParameters?.usingRAF) {\n                cancelAnimationFrame(this.dcInterval);\n            } else {\n                clearInterval(this.dcInterval);\n            }\n            this.dcInterval = null;\n        }\n        \n        // Reset visual appearance\n        if (this.mesh) {\n            // Force color update on next visual state update\n            this.lastColorUpdate.colorUpdateNeeded = true;\n            this.lastColorUpdate.isFiring = false;\n            this.lastColorUpdate.currentCharge = 0;\n            \n            const baseScale = this.baseScale + (this.maxScale - this.baseScale) * this.dcInput;\n            this.mesh.scale.setScalar(baseScale);\n            \n            // Update scale state\n            this.scaleState.base = baseScale;\n            this.scaleState.target = baseScale;\n            this.scaleState.current = baseScale;\n        }\n        \n        this.updateVisualState();\n        \n        // Dispatch reset event for UI updates through stateManager if available\n        if (window.stateManager) {\n            window.stateManager.dispatchEvent('neuronReset', { neuronId: this.id });\n        } else if (window.dispatchEvent && typeof CustomEvent === 'function') {\n            window.dispatchEvent(new CustomEvent('neuronReset', { \n                detail: { neuronId: this.id } \n            }));\n        }\n    }\n\n    // Utility methods\n    isInRefractoryPeriod() {\n        // More accurate refractory period tracking\n        // Check both time-based method and explicit flag\n        const currentTime = performance.now();\n        const timeSinceFiring = currentTime - this.lastFiredTime;\n        \n        // Return true if either explicit flag is set or traditional time check is true\n        return this.inRefractoryPeriod || \n               (this.lastFiredTime > 0 && timeSinceFiring < this.refractionPeriod);\n    }\n\n    getNeuronState() {\n        return {\n            id: this.id,\n            charge: this.currentCharge,\n            isFiring: this.isFiring,\n            isRefractory: this.isInRefractoryPeriod(),\n            dcInput: this.dcInput,\n            connections: Array.from(this.outgoingConnections),\n            weights: Array.from(this.synapticWeights),\n            speeds: Array.from(this.synapticSpeeds)\n        };\n    }\n\n    // Connection management methods\n    addConnection(targetIndex, initialWeight = 0.1, initialSpeed = 0.5) {\n        // Add connection details\n        this.outgoingConnections.add(targetIndex);\n        this.synapticWeights.set(targetIndex, initialWeight);\n        this.synapticSpeeds.set(targetIndex, initialSpeed);\n        \n        // NOTE: We don't need to set the color here\n        // The ConnectionManager already handles green flashing for both neurons\n        // through its flashNeuronGreen function\n        \n        // IMPORTANT: Track the current DC state before adding the connection\n        const hadDCInput = this.dcInput > 0;\n        const currentDCValue = this.dcInput;\n        \n        // Absolutely no reapplying of DC input or resetting of timers\n        // This ensures continuous firing without any disruption\n        \n        // Redundant safety check - if the DC interval was somehow lost during connection,\n        // restore it without disrupting the neuron's current state\n        if (hadDCInput && currentDCValue > 0 && !this.dcInterval) {\n            console.log(`Restoring DC during connection for neuron ${this.id}`);\n            // Re-establish DC input while preserving continuity\n            this.setDCInput(currentDCValue, false, true);\n        }\n    }\n\n    updateConnectionWeight(targetIndex, weight) {\n        if (this.outgoingConnections.has(targetIndex)) {\n            this.synapticWeights.set(targetIndex, weight);\n            // No need to reapply DC - maintaining continuity\n        }\n    }\n\n    updateConnectionSpeed(targetIndex, speed) {\n        if (this.outgoingConnections.has(targetIndex)) {\n            this.synapticSpeeds.set(targetIndex, speed);\n            // No need to reapply DC - maintaining continuity\n        }\n    }\n\n    removeConnection(targetIndex) {\n        // Get the target neuron ID before removing the connection\n        const targetNeuron = window.circles?.[targetIndex]?.neuron;\n        const sourceId = this.id;\n        let targetId = null;\n        \n        if (targetNeuron) {\n            targetId = targetNeuron.id;\n            // Cancel any pending charge deliveries for this connection\n            const connectionId = `${this.id}_${targetNeuron.id}`;\n            if (Neuron.pendingChargeDeliveries.has(connectionId)) {\n                clearTimeout(Neuron.pendingChargeDeliveries.get(connectionId));\n                Neuron.pendingChargeDeliveries.delete(connectionId);\n            }\n            \n            // Explicitly clean up any particles associated with this connection\n            Neuron.cleanupConnectionParticles(sourceId, targetId);\n            \n            // Log the cleanup\n            console.log(`Removing connection: ${sourceId} -> ${targetId}, cleaning up particles`);\n        } else {\n            console.warn(`Cannot find target neuron at index ${targetIndex} for cleanup`);\n        }\n        \n        // Remove the connection from data structures\n        this.outgoingConnections.delete(targetIndex);\n        this.synapticWeights.delete(targetIndex);\n        this.synapticSpeeds.delete(targetIndex);\n        \n        // Force another cleanup in case any particles were in the process of being created\n        setTimeout(() => {\n            if (sourceId && targetId) {\n                Neuron.cleanupConnectionParticles(sourceId, targetId);\n            }\n        }, 100);\n        \n        // Run orphaned particle cleanup to catch any remaining particles\n        setTimeout(() => {\n            Neuron.cleanupOrphanedParticles();\n        }, 200);\n    }\n\n    reset() {\n        this.currentCharge = 0;\n        this.isFiring = false;\n        this.lastFiredTime = 0;\n        this.updateVisualState();\n    }\n\n    cleanup() {\n        const neuronId = this.id;\n        const componentId = 'neuron_' + neuronId;\n        \n        // Use timerManager if available for timer cleanup\n        if (window.timerManager) {\n            window.timerManager.clearGroup(componentId);\n        } else {\n            // Clear interval/animation frame the traditional way\n            if (this.dcInterval) {\n                if (this.dcParameters?.usingRAF) {\n                    cancelAnimationFrame(this.dcInterval);\n                } else {\n                    clearInterval(this.dcInterval);\n                }\n                this.dcInterval = null;\n            }\n        }\n        \n        // Remove from DC neurons tracking\n        Neuron.dcNeurons.delete(this);\n        \n        // Use resourceManager if available\n        if (window.resourceManager) {\n            // Register THREE.js objects with resourceManager\n            if (this.mesh) {\n                if (this.mesh.material) {\n                    if (Array.isArray(this.mesh.material)) {\n                        this.mesh.material.forEach(material => {\n                            if (material) {\n                                window.resourceManager.registerResource('materials', material, componentId);\n                            }\n                        });\n                    } else {\n                        window.resourceManager.registerResource('materials', this.mesh.material, componentId);\n                    }\n                }\n                \n                if (this.mesh.geometry) {\n                    window.resourceManager.registerResource('geometries', this.mesh.geometry, componentId);\n                }\n                \n                // Register touch area\n                if (this.mesh.touchArea) {\n                    if (this.mesh.touchArea.material) {\n                        window.resourceManager.registerResource('materials', this.mesh.touchArea.material, componentId);\n                    }\n                    if (this.mesh.touchArea.geometry) {\n                        window.resourceManager.registerResource('geometries', this.mesh.touchArea.geometry, componentId);\n                    }\n                    window.resourceManager.registerResource('objects', this.mesh.touchArea, componentId);\n                }\n                \n                // Register harmony anchor indicator\n                if (this.mesh.harmonyAnchorIndicator) {\n                    if (this.mesh.harmonyAnchorIndicator.material) {\n                        window.resourceManager.registerResource('materials', this.mesh.harmonyAnchorIndicator.material, componentId);\n                    }\n                    if (this.mesh.harmonyAnchorIndicator.geometry) {\n                        window.resourceManager.registerResource('geometries', this.mesh.harmonyAnchorIndicator.geometry, componentId);\n                    }\n                    window.resourceManager.registerResource('objects', this.mesh.harmonyAnchorIndicator, componentId);\n                }\n                \n                // Register the mesh itself\n                window.resourceManager.registerResource('meshes', this.mesh, componentId);\n            }\n            \n            // Let resourceManager dispose all at once\n            window.resourceManager.cleanupOwner(componentId, false);\n        } else {\n            // Traditional resource cleanup\n            // Remove from scene if it still exists\n            if (this.mesh && this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            \n            // Dispose of material if it exists\n            if (this.mesh && this.mesh.material) {\n                // Check if it's an array of materials\n                if (Array.isArray(this.mesh.material)) {\n                    this.mesh.material.forEach(material => {\n                        if (material && material.dispose) {\n                            material.dispose();\n                        }\n                    });\n                } else if (this.mesh.material.dispose) {\n                    this.mesh.material.dispose();\n                }\n            }\n            \n            // Dispose of geometry if it exists\n            if (this.mesh && this.mesh.geometry && this.mesh.geometry.dispose) {\n                this.mesh.geometry.dispose();\n            }\n            \n            // Remove touch area if it exists\n            if (this.mesh.touchArea && this.mesh.touchArea.parent) {\n                this.mesh.touchArea.parent.remove(this.mesh.touchArea);\n                \n                // Dispose of touchArea geometry and material\n                if (this.mesh.touchArea.geometry) {\n                    this.mesh.touchArea.geometry.dispose();\n                }\n                if (this.mesh.touchArea.material) {\n                    this.mesh.touchArea.material.dispose();\n                }\n            }\n            \n            // Remove harmony anchor indicator if it exists\n            if (this.mesh && this.mesh.harmonyAnchorIndicator) {\n                if (this.mesh.harmonyAnchorIndicator.parent) {\n                    this.mesh.harmonyAnchorIndicator.parent.remove(this.mesh.harmonyAnchorIndicator);\n                }\n                \n                // Dispose resources\n                if (this.mesh.harmonyAnchorIndicator.geometry) {\n                    this.mesh.harmonyAnchorIndicator.geometry.dispose();\n                }\n                if (this.mesh.harmonyAnchorIndicator.material) {\n                    this.mesh.harmonyAnchorIndicator.material.dispose();\n                }\n                \n                // Clear reference\n                this.mesh.harmonyAnchorIndicator = null;\n            }\n        }\n        \n        // Clean up any particles associated with this neuron\n        if (Neuron.allParticles && Neuron.allParticles.length > 0) {\n            // Create a copy of the array to safely remove items while iterating\n            const particles = [...Neuron.allParticles];\n            \n            // Check each particle\n            particles.forEach(particle => {\n                if (!particle || !particle.parent) return;\n                \n                // If particle is associated with this neuron, remove it\n                // We don't have direct association, so check position proximity\n                if (this.mesh && particle.position) {\n                    const distance = particle.position.distanceTo(this.mesh.position);\n                    // If particle is close to this neuron or exactly at its position\n                    if (distance < 1.0) {\n                        // Remove from scene\n                        particle.parent.remove(particle);\n                        \n                        // Use resourceManager if available\n                        if (window.resourceManager) {\n                            if (particle.material) {\n                                window.resourceManager.registerResource('materials', particle.material, componentId);\n                            }\n                            if (particle.geometry) {\n                                window.resourceManager.registerResource('geometries', particle.geometry, componentId);\n                            }\n                        } else {\n                            // Dispose material manually\n                            if (particle.material) particle.material.dispose();\n                        }\n                        \n                        // Remove from global array\n                        const index = Neuron.allParticles.indexOf(particle);\n                        if (index !== -1) Neuron.allParticles.splice(index, 1);\n                    }\n                }\n            });\n            \n            // Final cleanup if using resourceManager\n            if (window.resourceManager) {\n                window.resourceManager.cleanupOwner(componentId, false);\n            }\n        }\n        \n        // Clear collections\n        this.outgoingConnections.clear();\n        this.synapticWeights.clear();\n        this.synapticSpeeds.clear();\n        \n        // IMPORTANT: Clean up sound references in SoundManager\n        if (window.soundManager) {\n            // If this neuron is selected, deselect it\n            if (window.soundManager.selectedNeuronId === this.id) {\n                window.soundManager.selectedNeuronId = null;\n            }\n            \n            // Clear any cached sound data for this neuron\n            if (window.soundManager.neuronFrequencies) {\n                window.soundManager.neuronFrequencies.delete(this.id);\n            }\n            \n            if (window.soundManager.neuronSoundOverrides) {\n                window.soundManager.neuronSoundOverrides.delete(this.id);\n            }\n            \n            // Clear pending restorations for this neuron using timerManager if available\n            if (window.timerManager && window.soundManager.pendingRestorations && window.soundManager.pendingRestorations.has(this.id)) {\n                window.timerManager.clearTimeout('soundManager', window.soundManager.pendingRestorations.get(this.id));\n                window.soundManager.pendingRestorations.delete(this.id);\n            } else if (window.soundManager.pendingRestorations && window.soundManager.pendingRestorations.has(this.id)) {\n                clearTimeout(window.soundManager.pendingRestorations.get(this.id));\n                window.soundManager.pendingRestorations.delete(this.id);\n            }\n            \n            // Additional cleanups based on OptimizedSoundManager\n            if (window.soundManager.neuronBusAssignments) {\n                window.soundManager.neuronBusAssignments.delete(this.id);\n            }\n            \n            if (window.soundManager.voicePriorities) {\n                window.soundManager.voicePriorities.delete(this.id);\n            }\n            \n            // Force silence any active sounds that might be playing for this neuron\n            try {\n                if (typeof window.soundManager.silenceNeuron === 'function') {\n                    window.soundManager.silenceNeuron(this.id);\n                }\n            } catch (error) {\n                console.warn('Error silencing neuron during cleanup:', error);\n            }\n        }\n        \n        // Notify stateManager that neuron was removed\n        if (window.stateManager) {\n            window.stateManager.dispatchEvent('neuronRemoved', { neuronId: this.id });\n        }\n    }\n\n    static updateAllDCNeurons() {\n        // Ensure all neurons with DC input have active intervals\n        if (Neuron.dcNeurons.size > 0) {\n            Neuron.dcNeurons.forEach(neuron => {\n                // Check if the neuron's interval is active\n                if (neuron.dcInput > 0 && !neuron.dcInterval) {\n                    // Reset the DC input to restart the interval but preserve continuity\n                    neuron.setDCInput(neuron.dcInput, false, true);\n                }\n            });\n        }\n    }\n\n    // Method to create a particle explosion around the neuron\n    createParticleExplosion(options = {}) {\n        if (!this.mesh || !this.mesh.parent) return;\n        \n        // Use provided options or defaults\n        const numParticles = options.count || 8;\n        const particleSize = options.scale || 0.1;\n        const particleGeometry = new THREE.PlaneGeometry(particleSize, particleSize);\n        const duration = options.duration || 1000; // milliseconds\n        const particleSpeed = options.speed || 0.5; // multiplier for animation speed\n        \n        // Use the provided color, or neuron's preset color, or neuron's actual color\n        const particleColor = options.color ? \n            options.color.clone() : \n            (this.presetColor ? \n            this.presetColor.clone() : \n                this.mesh.material.color.clone());\n            \n        // Brighten the color slightly for better visibility\n        particleColor.r = Math.min(1.5, particleColor.r * 1.2);\n        particleColor.g = Math.min(1.5, particleColor.g * 1.2);\n        particleColor.b = Math.min(1.5, particleColor.b * 1.2);\n            \n        const particleMaterial = new THREE.MeshBasicMaterial({\n            color: particleColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        \n        for (let i = 0; i < numParticles; i++) {\n            const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());\n            const angle = (i / numParticles) * Math.PI * 2;\n            const radius = 0.2;\n            \n            // Position around the neuron in a circle\n            particle.position.set(\n                this.mesh.position.x + Math.cos(angle) * radius,\n                this.mesh.position.y,\n                this.mesh.position.z + Math.sin(angle) * radius\n            );\n            \n            // Set rotation to face camera\n            particle.rotation.x = -Math.PI / 2;\n            \n            // Add to scene\n            this.mesh.parent.add(particle);\n            \n            // Animate outward in a straight line - use particleSpeed to control distance and speed\n            const animDuration = duration / 1000; // Convert ms to seconds for GSAP\n            const distanceFactor = 4 * particleSpeed; // Adjust distance based on speed\n            \n            gsap.to(particle.position, {\n                x: this.mesh.position.x + Math.cos(angle) * (radius * distanceFactor),\n                z: this.mesh.position.z + Math.sin(angle) * (radius * distanceFactor),\n                duration: animDuration,\n                ease: \"power2.out\"\n            });\n            \n            // Fade out and remove\n            gsap.to(particle.material, {\n                opacity: 0,\n                duration: animDuration,\n                ease: \"power2.out\",\n                onComplete: () => {\n                    if (particle.parent) {\n                        particle.parent.remove(particle);\n                    }\n                    particle.material.dispose();\n                    particle.geometry.dispose();\n                }\n            });\n        }\n    }\n\n    /**\n     * Static method to create a particle between two neurons\n     * This allows direct particle creation from anywhere in the code\n     * @param {THREE.Object3D} sourceNeuron Source neuron mesh/object\n     * @param {THREE.Object3D} targetNeuron Target neuron mesh/object\n     * @param {number} weight Connection weight (0-1)\n     * @param {number} speed Connection speed (0-1)\n     */\n    static createParticle(sourceNeuron, targetNeuron, weight = 0.5, speed = 0.5) {\n        if (!sourceNeuron || !targetNeuron || !sourceNeuron.neuron || !targetNeuron.neuron) {\n            console.warn(\"[Neuron.createParticle] Missing neuron parameters:\", sourceNeuron, targetNeuron);\n            return;\n        }\n        \n        try {\n            console.log(`[Neuron.createParticle] Creating particle from ${sourceNeuron.neuron.id} to ${targetNeuron.neuron.id}`);\n            \n            // Use the optimized particle system if available\n            if (window.particleSystem && typeof window.particleSystem.createParticle === 'function') {\n                // Calculate source and target positions\n                const sourcePos = new THREE.Vector3(\n                    sourceNeuron.position.x,\n                    0.05,\n                    sourceNeuron.position.z\n                );\n                \n                const targetPos = new THREE.Vector3(\n                    targetNeuron.position.x,\n                    0.05,\n                    targetNeuron.position.z\n                );\n                \n                // Use the optimized particle system\n                window.particleSystem.createParticle(\n                    sourcePos,\n                    targetPos,\n                    sourceNeuron.neuron.id,\n                    targetNeuron.neuron.id,\n                    weight,\n                    speed\n                );\n                \n                console.log(`[Neuron.createParticle] Created particle via OptimizedParticleSystem`);\n            } else {\n                // Fallback to worker manager if available\n                if (window.workerManager && typeof window.workerManager.createParticle === 'function') {\n                    window.workerManager.createParticle(sourceNeuron, targetNeuron, weight, speed);\n                    console.log(`[Neuron.createParticle] Created particle via WorkerManager`);\n                } else {\n                    console.warn(\"[Neuron.createParticle] No particle system available\");\n                }\n            }\n        } catch (error) {\n            console.error(\"[Neuron.createParticle] Error creating particle:\", error);\n        }\n    }\n\n    // Clean up any active particles for a connection being deleted\n    static cleanupConnectionParticles(sourceNeuronId, targetNeuronId) {\n        // Forward to the optimized particle system if available\n        if (window.particleSystem && typeof window.particleSystem.removeConnection === 'function') {\n            window.particleSystem.removeConnection(sourceNeuronId, targetNeuronId);\n            return;\n        }\n        \n        // If no optimized system, notify but do nothing (legacy code removed)\n        console.warn('[Neuron.cleanupConnectionParticles] OptimizedParticleSystem not available');\n    }\n\n    // Method to clean up \"orphaned\" particles that lack valid source or target neurons\n    static cleanupOrphanedParticles() {\n        // Get all active neurons in the scene from the circles array\n        const activeNeuronIds = [];\n        if (window.circles) {\n            for (const circle of window.circles) {\n                if (circle && circle.neuron) {\n                    activeNeuronIds.push(circle.neuron.id);\n                }\n            }\n        }\n        \n        // Forward to the optimized particle system if available\n        if (window.particleSystem && typeof window.particleSystem.cleanupOrphanedParticles === 'function') {\n            window.particleSystem.cleanupOrphanedParticles(activeNeuronIds);\n            return;\n        }\n        \n        // If no optimized system, notify but do nothing (legacy code removed)\n        console.warn('[Neuron.cleanupOrphanedParticles] OptimizedParticleSystem not available');\n    }\n} // End of Neuron class","import * as THREE from 'three';\nimport gsap from 'gsap';\n\nconst INPUT_CONFIG = {\n  mouse: {\n    dragThreshold: 0.001,\n    doubleClickDelay: 300,\n    canvasDragSpeed: 0.01\n  },\n  touch: {\n    maxDragDistance: 5.0,\n    selectionThreshold: 3.5,\n    doubleTapDelay: 300,\n    tapDistanceThreshold: 30\n  },\n  animation: {\n    flashDuration: 0.2,\n    momentumMultiplier: 10,\n    momentumDuration: 0.5\n  },\n  performance: {\n    throttleInterval: 16, // ~60fps\n    raycastDistance: 10\n  },\n  debug: {\n    showTouchAreas: false,\n    logStateTransitions: false\n  }\n};\n\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport class InputManager {\n    constructor(camera, renderer, connectionManager) {\n        this.camera = camera;\n        this.renderer = renderer;\n        this.connectionManager = connectionManager;\n        this.raycaster = new THREE.Raycaster();\n        this.mouse = new THREE.Vector2();\n        this.draggedNeuron = null;\n        this.isDragging = false;\n        this.isRightClickDragging = false; // New state for right-click canvas dragging\n        this.dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\n        this.dragOffset = new THREE.Vector3();\n        this.lastPosition = new THREE.Vector3();\n        this.velocity = new THREE.Vector3();\n        this.lastMousePosition = new THREE.Vector2(); // Store last mouse position for right-click drag\n        this.canvasDragVelocity = new THREE.Vector3(); // Add velocity tracking for canvas drag\n        \n        // Force drag release when touch is too far from neuron\n        this.maxDragDistance = 5.0;\n        this.initialTouchPosition = new THREE.Vector3();\n        this.touchTargetNeuron = null; // Explicitly track which neuron is the target of the current touch\n        this.touchSelectionConfirmed = false; // Flag to track if the current touch has confirmed a neuron selection\n        this.neuronSelectionThreshold = 3.5; // Detection threshold for neuron selection\n\n        // Mobile-specific properties\n        this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        this.lastTouchDistance = 0;\n        this.isMultiTouch = false;\n        this.lastTapTime = 0;\n        this.doubleTapDelay = 300;\n        this.lastTapPosition = { x: 0, y: 0 };\n        this.tapDistanceThreshold = 30;\n        \n        // Debug mode for touch interaction - set to true to see touch areas\n        this.debugTouchAreas = false;\n        \n        // If in debug mode and on mobile, make touch areas visible\n        if (this.debugTouchAreas && this.isMobile) {\n            setTimeout(() => {\n                window.circles.forEach(circle => {\n                    if (circle.touchArea) {\n                        // Make touch areas semi-transparent for debugging\n                        circle.touchArea.material.opacity = 0.2;\n                        circle.touchArea.visible = true;\n                    }\n                });\n            }, 1000); // Delay to ensure neurons are initialized\n        }\n\n        // For UI references\n        this.ui = {\n            synthFolder: null,\n            neuronLabel: null,\n            refreshFunctions: {}\n        };\n        \n        // Initialize UI references with a delay\n        setTimeout(() => this.initializeUI(), 500);\n        \n        // Mobile GUI properties - only create if on mobile\n        if (this.isMobile) {\n            this.selectedConnection = null;\n            this.mobileControls = null;\n            this.createMobileControls();\n        }\n\n        this.lastClickTime = 0;\n        this.doubleClickDelay = 300; // milliseconds\n        this.lastClickPosition = { x: 0, y: 0 };\n        this.clickDistanceThreshold = 30;\n\n        // Adjust this value to change canvas drag speed (0.1 = slower, 1.0 = faster)\n        this.canvasDragSpeed = 0.01;\n        \n        // Create a pool for vector3 objects to reduce garbage collection\n        this.vector3Pool = [];\n        for (let i = 0; i < 10; i++) {\n            this.vector3Pool.push(new THREE.Vector3());\n        }\n\n        // Initialize state management\n        this.state = {\n            current: 'idle',\n            context: {}\n        };\n\n        // Throttle mouse/touch move events for better performance\n        const throttle = (func, limit) => {\n            let lastCall = 0;\n            return function(...args) {\n                const now = performance.now();\n                if (now - lastCall >= limit) {\n                    lastCall = now;\n                    func.apply(this, args);\n                }\n            };\n        };\n\n        // Set up event handlers\n        this.onMouseDownBound = this.onMouseDown.bind(this);\n        this.onMouseMoveBound = this.onMouseMove.bind(this);\n        this.onMouseUpBound = this.onMouseUp.bind(this);\n        this.onMouseLeaveBound = this.onMouseLeave.bind(this); // NEW - mouse leave handler\n        this.onTouchStartBound = this.onTouchStart.bind(this);\n        this.onTouchMoveBound = this.onTouchMove.bind(this);\n        this.onTouchEndBound = this.onTouchEnd.bind(this);\n        this.onWheelBound = this.onWheel.bind(this);\n        this.onDoubleClickBound = this.onDoubleClick.bind(this);\n        this.handleRightClickBound = this.handleRightClick.bind(this);\n        \n        // Attach event listeners to the renderer's domElement\n        renderer.domElement.addEventListener('mousedown', this.onMouseDownBound, false);\n        renderer.domElement.addEventListener('mousemove', this.onMouseMoveBound, false);\n        renderer.domElement.addEventListener('mouseup', this.onMouseUpBound, false);\n        renderer.domElement.addEventListener('mouseleave', this.onMouseLeaveBound, false); // NEW - mouse leave event\n\n        // Add event listeners based on device type\n        if (this.isMobile) {\n            renderer.domElement.addEventListener('touchstart', this.onTouchStartBound, { passive: false });\n            renderer.domElement.addEventListener('touchmove', this.onTouchMoveBound, { passive: false });\n            renderer.domElement.addEventListener('touchend', this.onTouchEndBound, { passive: false });\n            // Prevent context menu on long press\n            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());\n        } else {\n            renderer.domElement.addEventListener('wheel', this.onWheelBound, { passive: false });\n            renderer.domElement.addEventListener('dblclick', this.onDoubleClickBound); // Add double click for desktop\n        }\n\n        // Add a property to store the last audio time used\n        this.lastAudioTime = 0;\n\n        // Add our own context menu handler for neuron deletion\n        renderer.domElement.addEventListener('contextmenu', this.handleRightClickBound);\n    }\n\n    createMobileControls() {\n        this.mobileControls = document.createElement('div');\n        this.mobileControls.style.position = 'fixed';\n        this.mobileControls.style.bottom = '20px';\n        this.mobileControls.style.left = '50%';\n        this.mobileControls.style.transform = 'translateX(-50%)';\n        this.mobileControls.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n        this.mobileControls.style.padding = '15px';\n        this.mobileControls.style.borderRadius = '10px';\n        this.mobileControls.style.display = 'none';\n        this.mobileControls.style.zIndex = '1000';\n        this.mobileControls.style.width = '80%';\n        this.mobileControls.style.maxWidth = '300px';\n\n        const title = document.createElement('div');\n        title.textContent = 'Synapse Control';\n        title.style.color = 'white';\n        title.style.textAlign = 'center';\n        title.style.marginBottom = '15px';\n        title.style.fontSize = '18px';\n        this.mobileControls.appendChild(title);\n\n        // Weight Slider\n        const weightContainer = this.createSliderContainer('Weight');\n        this.mobileControls.appendChild(weightContainer);\n\n        // Speed Slider\n        const speedContainer = this.createSliderContainer('Speed');\n        this.mobileControls.appendChild(speedContainer);\n\n        document.body.appendChild(this.mobileControls);\n    }\n\n    createSliderContainer(label) {\n        const container = document.createElement('div');\n        container.style.marginBottom = '20px';\n        \n        const labelElement = document.createElement('div');\n        labelElement.style.color = 'white';\n        labelElement.style.marginBottom = '10px';\n        labelElement.style.display = 'flex';\n        labelElement.style.justifyContent = 'space-between';\n        labelElement.style.alignItems = 'center';\n        \n        const labelText = document.createElement('span');\n        labelText.textContent = label;\n        labelText.style.fontSize = '16px';\n        labelElement.appendChild(labelText);\n        \n        const value = document.createElement('span');\n        value.textContent = '0.50';\n        value.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n        value.style.padding = '4px 8px';\n        value.style.borderRadius = '4px';\n        value.style.fontSize = '14px';\n        labelElement.appendChild(value);\n        \n        const slider = document.createElement('input');\n        slider.type = 'range';\n        slider.min = '0';\n        slider.max = '1';\n        slider.step = '0.01';\n        slider.value = '0.5';\n        slider.style.width = '100%';\n        slider.style.height = '20px';\n        slider.style.webkitAppearance = 'none';\n        slider.style.appearance = 'none';\n        slider.style.background = 'rgba(255, 255, 255, 0.1)';\n        slider.style.outline = 'none';\n        slider.style.borderRadius = '10px';\n        slider.style.transition = 'background 0.2s';\n        \n        // Slider thumb styles\n        const thumbStyles = `\n            input[type=\"range\"]::-webkit-slider-thumb {\n                -webkit-appearance: none;\n                appearance: none;\n                width: 24px;\n                height: 24px;\n                background: #4CAF50;\n                border-radius: 50%;\n                cursor: pointer;\n                transition: background 0.2s;\n            }\n            input[type=\"range\"]::-webkit-slider-thumb:hover {\n                background: #45a049;\n            }\n            input[type=\"range\"]::-moz-range-thumb {\n                width: 24px;\n                height: 24px;\n                background: #4CAF50;\n                border-radius: 50%;\n                cursor: pointer;\n                border: none;\n                transition: background 0.2s;\n            }\n            input[type=\"range\"]::-moz-range-thumb:hover {\n                background: #45a049;\n            }\n        `;\n    \n        // Add styles to document if not already added\n        if (!document.getElementById('sliderStyles')) {\n            const styleSheet = document.createElement('style');\n            styleSheet.id = 'sliderStyles';\n            styleSheet.textContent = thumbStyles;\n            document.head.appendChild(styleSheet);\n        }\n        \n        slider.addEventListener('input', (e) => {\n            value.textContent = parseFloat(e.target.value).toFixed(2);\n            if (label === 'Weight') {\n                this.updateConnectionWeight(e.target.value);\n            } else {\n                this.updateConnectionSpeed(e.target.value);\n            }\n        });\n    \n        container.appendChild(labelElement);\n        container.appendChild(slider);\n        return container;\n    }\n\n    updateMousePosition(event) {\n        const rect = this.renderer.domElement.getBoundingClientRect();\n        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n    }\n\n    updateTouchPosition(touch) {\n        if (!touch) return; // Safety check\n        \n        const rect = this.renderer.domElement.getBoundingClientRect();\n        \n        // For mobile, adjust touch position calculation for better precision\n        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        \n        if (isMobile) {\n            // For mobile, we need to ensure touch coordinates are properly mapped\n            // to the WebGL coordinate system\n            \n            // Ensure we use clientX/Y which are coordinates relative to the viewport\n            const touchX = touch.clientX;\n            const touchY = touch.clientY;\n            \n            // Calculate normalized device coordinates (-1 to +1)\n            // These calculations map screen coordinates to WebGL's normalized device coordinates\n            this.mouse.x = ((touchX - rect.left) / rect.width) * 2 - 1;\n            this.mouse.y = -((touchY - rect.top) / rect.height) * 2 + 1;\n            \n            // Optional debug visualization - uncomment to see touch points\n            // this.showTouchDebug(touchX, touchY);\n        } else {\n            // Standard calculation for non-mobile\n            this.mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;\n            this.mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;\n        }\n    }\n\n    getTouchDistance(touches) {\n        // Calculate the distance between two touches for pinch gesture\n        if (!touches || touches.length < 2) return 0;\n        \n        const dx = touches[0].clientX - touches[1].clientX;\n        const dy = touches[0].clientY - touches[1].clientY;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    getIntersectionPoint(mouse) {\n        // Calculate where in 3D space the mouse/touch is pointing\n        this.raycaster.setFromCamera(mouse, this.camera);\n        const intersectionPoint = new THREE.Vector3();\n        this.raycaster.ray.intersectPlane(this.dragPlane, intersectionPoint);\n        return intersectionPoint;\n    }\n\n    updateConnectionWeight(value) {\n        if (!this.isMobile || !this.selectedConnection) return;\n        const newWeight = parseFloat(value);\n        this.selectedConnection.weight = newWeight;\n        \n        const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n        if (this.selectedConnection.source?.neuron) {\n            this.selectedConnection.source.neuron.updateConnectionWeight(targetIndex, newWeight);\n        }\n    }\n\n    updateConnectionSpeed(value) {\n        if (!this.isMobile || !this.selectedConnection) return;\n        const newSpeed = parseFloat(value);\n        this.selectedConnection.speed = newSpeed;\n        \n        const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n        if (this.selectedConnection.source?.neuron) {\n            this.selectedConnection.source.neuron.updateConnectionSpeed(targetIndex, newSpeed);\n        }\n    }\n\n    onTouchStart(event) {\n        event.preventDefault();\n        \n        // Reset touch state completely\n        this.touchSelectionConfirmed = false;\n        this.touchTargetNeuron = null;\n        \n        const currentTime = new Date().getTime();\n        const touch = event.touches[0];\n        \n        // Handle multi-touch first\n        if (event.touches.length === 2) {\n            this.isMultiTouch = true;\n            this.lastTouchDistance = this.getTouchDistance(event.touches);\n            \n            // Calculate midpoint between fingers for better positioning\n            const midpoint = {\n                x: (event.touches[0].clientX + event.touches[1].clientX) / 2,\n                y: (event.touches[0].clientY + event.touches[1].clientY) / 2\n            };\n            \n            // If a neuron is already selected, use it for pinch\n            if (this.draggedNeuron) {\n                this.updateTouchPosition({ clientX: midpoint.x, clientY: midpoint.y });\n                this.touchTargetNeuron = this.draggedNeuron;\n                this.touchSelectionConfirmed = true;\n                console.log(\"Using previously selected neuron for pinch:\", this.draggedNeuron.neuron?.id);\n                return;\n            }\n            \n            // Try to select a neuron at the midpoint of the pinch\n            this.updateTouchPosition({ clientX: midpoint.x, clientY: midpoint.y });\n            this.raycaster.setFromCamera(this.mouse, this.camera);\n            \n            // Use a larger threshold for pinch detection\n            this.raycaster.params.Mesh = this.raycaster.params.Mesh || {};\n            const originalThreshold = this.raycaster.params.Mesh.threshold || 0;\n            this.raycaster.params.Mesh.threshold = this.neuronSelectionThreshold;\n            \n            const circles = [];\n            window.circles.forEach(circle => {\n                if (circle.touchArea) circles.push(circle.touchArea);\n                circles.push(circle);\n            });\n            \n            const intersects = this.raycaster.intersectObjects(circles);\n            this.raycaster.params.Mesh.threshold = originalThreshold;\n            \n            if (intersects.length > 0) {\n                let selectedObject = intersects[0].object;\n                \n                if (selectedObject.isHitArea && selectedObject.parentCircle) {\n                    selectedObject = selectedObject.parentCircle;\n                }\n                \n                this.touchTargetNeuron = selectedObject;\n                this.touchSelectionConfirmed = true;\n                this.selectNeuron(selectedObject); // Use centralized selection method\n                console.log(\"Selected neuron for pinch:\", this.touchTargetNeuron.neuron?.id);\n            }\n            \n            return;\n        }\n        \n        // Reset multi-touch state\n        this.isMultiTouch = false;\n        \n        // Update touch position for all subsequent checks\n        this.updateTouchPosition(touch);\n        \n        // Determine what we're touching in the 3D world\n        const touchWorldPosition = this.getIntersectionPoint(this.mouse);\n        this.initialTouchPosition.copy(touchWorldPosition); // Store for distance checks\n        \n        // Check for double tap - this needs to happen BEFORE arrow detection\n        const tapPosition = { x: touch.clientX, y: touch.clientY };\n        const timeDiff = currentTime - this.lastTapTime;\n        const distance = Math.sqrt(\n            Math.pow(tapPosition.x - this.lastTapPosition.x, 2) + \n            Math.pow(tapPosition.y - this.lastTapPosition.y, 2)\n        );\n        \n        // Store current tap info for next time\n        this.lastTapTime = currentTime;\n        this.lastTapPosition = tapPosition;\n        \n        // If double tap detected, create a new neuron\n        if (timeDiff < this.doubleTapDelay && distance < this.tapDistanceThreshold) {\n            this.raycaster.setFromCamera(this.mouse, this.camera);\n            \n            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\n            const intersectionPoint = new THREE.Vector3();\n            this.raycaster.ray.intersectPlane(plane, intersectionPoint);\n            \n            const intersects = this.raycaster.intersectObjects(window.circles);\n            if (intersects.length === 0) {\n                console.log(\"Double tap detected, creating neuron at\", intersectionPoint);\n                // Create new neuron\n                const neuron = window.settings.addNeuron(intersectionPoint);\n                if (neuron) {\n                    neuron.position.copy(intersectionPoint);\n                    neuron.position.y = 0.1;\n                    \n                    // Update touch area position too\n                    if (neuron.touchArea) {\n                        neuron.touchArea.position.copy(neuron.position);\n                        neuron.touchArea.position.y = 0.1;\n                    }\n                    \n                    // Select the newly created neuron using central method\n                    this.selectNeuron(neuron);\n                    this.touchTargetNeuron = neuron;\n                    this.touchSelectionConfirmed = true;\n                    \n                    // Provide visual feedback\n                    gsap.from(neuron.scale, {\n                        x: 0.05, y: 0.05, z: 0.05,\n                        duration: 0.3,\n                        ease: \"back.out(1.7)\"\n                    });\n                }\n            }\n            return;\n        }\n        \n        // Check if we're clicking on an arrow using our custom method\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        if (this.isClickingOnArrow(event)) {\n            // Let ConnectionManager handle arrow interactions\n            // Deselect any previously selected neuron\n            this.deselectNeuron();\n            return;\n        }\n        \n        // --- Look for neurons under the touch point ---\n        \n        // Use threshold for better touch detection\n        this.raycaster.params.Mesh = this.raycaster.params.Mesh || {};\n        const originalThreshold = this.raycaster.params.Mesh.threshold || 0;\n        this.raycaster.params.Mesh.threshold = this.neuronSelectionThreshold;\n        \n        const circles = [];\n        window.circles.forEach(circle => {\n            if (circle.touchArea) circles.push(circle.touchArea);\n            circles.push(circle);\n        });\n        \n        const intersects = this.raycaster.intersectObjects(circles);\n        this.raycaster.params.Mesh.threshold = originalThreshold;\n        \n        if (intersects.length > 0) {\n            // Found a neuron under the touch\n            let selectedObject = intersects[0].object;\n            \n            if (selectedObject.isHitArea && selectedObject.parentCircle) {\n                selectedObject = selectedObject.parentCircle;\n            }\n            \n            // Select the neuron using our central method\n            this.selectNeuron(selectedObject);\n            this.touchTargetNeuron = selectedObject;\n            this.touchSelectionConfirmed = true;\n            \n            // Set up for dragging\n            this.setState('neuronDragging', { neuron: selectedObject });\n            this.dragOffset.copy(selectedObject.position).sub(touchWorldPosition);\n            this.lastPosition.copy(selectedObject.position);\n            \n            console.log('Touch selected neuron:', selectedObject.neuron?.id);\n        } else {\n            // Touched empty space - deselect current neuron\n            this.setState('idle');\n            console.log('Touch on empty space - deselected all');\n        }\n    }\n\n    onDoubleClick(event) {\n        event.preventDefault();\n        \n        // Get mouse position in normalized device coordinates (-1 to +1)\n        this.updateMousePosition(event);\n        \n        // Set up raycaster\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Create a plane at y=0 to intersect with\n        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\n        const intersectionPoint = new THREE.Vector3();\n        this.raycaster.ray.intersectPlane(plane, intersectionPoint);\n        \n        // Check if we clicked on empty space (not on existing neurons)\n        const intersects = this.raycaster.intersectObjects(window.circles);\n        if (intersects.length === 0) {\n            // Create new neuron at intersection point\n            const neuron = window.settings.addNeuron(intersectionPoint);\n            if (neuron) {\n                // Set proper position for immediate interaction\n                neuron.position.copy(intersectionPoint);\n                neuron.position.y = 0.1; // Position at 0.1 instead of -10 so it's immediately visible\n                \n                // Update touch area position too\n                if (neuron.touchArea) {\n                    neuron.touchArea.position.copy(neuron.position);\n                    neuron.touchArea.position.y = 0.1;\n                }\n                \n                // Add subtle animation for visual feedback\n                const originalScale = neuron.scale.clone();\n                gsap.from(neuron.scale, {\n                    x: 0.05,\n                    y: 0.05,\n                    z: 0.05,\n                    duration: 0.3,\n                    ease: \"back.out(1.7)\",\n                    onComplete: () => {\n                        neuron.scale.copy(originalScale);\n                    }\n                });\n                \n                // Automatically select the newly created neuron\n                this.selectNeuron(neuron);\n            }\n        }\n    }\n\n    onTouchMove(event) {\n        // Always prevent default for touch moves to prevent page scrolling\n        event.preventDefault();\n        \n        // Ignore multi-touch events if we're in connection mode\n        if (this.state === 'connection' && event.touches.length > 1) {\n            return;\n        }\n        \n        // Get the first touch\n        const touch = event.touches[0];\n        \n        // Handle pinch gesture for DC input\n        if (event.touches.length === 2) {\n            // Already handled in previous version\n            // Reset velocity to prevent slingshot\n            this.velocity.set(0, 0, 0);\n            \n            const currentDistance = this.getTouchDistance(event.touches);\n            // Reduce sensitivity for more controlled pinching\n            const delta = (currentDistance - this.lastTouchDistance) * 0.005;\n            \n            // Calculate midpoint between fingers\n            const midpoint = {\n                x: (event.touches[0].clientX + event.touches[1].clientX) / 2,\n                y: (event.touches[0].clientY + event.touches[1].clientY) / 2\n            };\n            \n            if (this.touchTargetNeuron?.neuron) {\n                const currentDC = this.touchTargetNeuron.neuron.dcInput || 0;\n                // Calculate new DC input value with clamping\n                const newDC = Math.max(0, Math.min(1, currentDC + delta));\n                \n                // Only update if change is significant and not too frequent\n                // This helps prevent jitter and double-firing\n                if (Math.abs(newDC - currentDC) > 0.01) {\n                    this.touchTargetNeuron.neuron.setDCInput(newDC);\n                    \n                    // Update the neuron's visual scale using animation for smoother transition\n                    const targetScale = this.touchTargetNeuron.neuron.baseScale + \n                        (this.touchTargetNeuron.neuron.maxScale - this.touchTargetNeuron.neuron.baseScale) * newDC;\n                    \n                    // Use GSAP for smooth animation instead of instant scale change\n                    gsap.to(this.touchTargetNeuron.scale, {\n                        x: targetScale,\n                        y: targetScale,\n                        z: targetScale,\n                        duration: 0.2,\n                        ease: \"power2.out\"\n                    });\n                    \n                    // Also update touchArea scale proportionally\n                    if (this.touchTargetNeuron.touchArea) {\n                        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n                        const touchScale = isMobile ? 0.1 : 1.0;\n                        gsap.to(this.touchTargetNeuron.touchArea.scale, {\n                            x: touchScale * targetScale / 0.2,\n                            y: touchScale * targetScale / 0.2,\n                            z: touchScale * targetScale / 0.2,\n                            duration: 0.2,\n                            ease: \"power2.out\"\n                        });\n                    }\n                }\n            }\n            \n            this.lastTouchDistance = currentDistance;\n            this.lastMidpoint = midpoint; // Store midpoint for touch end\n            return;\n        }\n        \n        // We're handling a single touch - update the position\n        this.updateTouchPosition(touch);\n        \n        // If no neuron is selected or we're not in drag mode, nothing more to do\n        if (!this.touchSelectionConfirmed || !this.touchTargetNeuron) {\n            return;\n        }\n        \n        // Get the intersection point with the drag plane\n        const intersectionPoint = this.getIntersectionPoint(this.mouse);\n        \n        // Calculate the distance from original touch position\n        const distanceFromStart = this.initialTouchPosition.distanceTo(intersectionPoint);\n        \n        // If the touch has moved too far from its starting point, confirm we're in drag mode\n        // This helps distinguish between taps and actual drag attempts\n        if (distanceFromStart > 0.1) {\n            this.setState('neuronDragging', { neuron: this.touchTargetNeuron });\n        }\n        \n        // If not in drag mode, exit early\n        if (this.state.current !== 'neuronDragging') {\n            return;\n        }\n        \n        // Apply the drag offset to the intersection point\n        const newPosition = this.getVector3().copy(intersectionPoint).add(this.dragOffset);\n        newPosition.y = 0.1;\n        \n        // Calculate velocity for momentum effect\n        this.velocity.subVectors(newPosition, this.lastPosition);\n        \n        // Update position of the dragged neuron\n        this.touchTargetNeuron.position.copy(newPosition);\n        \n        // Update touch area position too\n        if (this.touchTargetNeuron.touchArea) {\n            this.touchTargetNeuron.touchArea.position.copy(this.touchTargetNeuron.position);\n        }\n        \n        // Store this position for next frame's velocity calculation\n        this.lastPosition.copy(newPosition);\n        \n        // Update hover label for the dragged neuron too\n        if (window.updateNeuronHoverLabel) {\n            window.updateNeuronHoverLabel(\n                this.draggedNeuron, \n                event.clientX, \n                event.clientY\n            );\n        }\n        \n        // Store a global reference to the currently dragged neuron for use in ConnectionManager\n        window.draggedNeuron = this.touchTargetNeuron;\n        \n        // Force-update all connections related to this neuron immediately\n        // This ensures the arrows follow the neuron without delay during dragging\n        if (this.connectionManager && this.connectionManager.forceUpdateConnectionsForNeuron) {\n            // First clear any cached positions to force fresh calculations\n            if (this.connectionManager.arrowPositionCache) {\n                // Find all connections involving this neuron\n                this.connectionManager.connections.forEach(connection => {\n                    if (connection.source === this.touchTargetNeuron || \n                        connection.target === this.touchTargetNeuron) {\n                        // Clear the cached position\n                        const connectionId = connection.source?.neuron?.id + \"_\" + connection.target?.neuron?.id;\n                        if (connectionId) {\n                            this.connectionManager.arrowPositionCache.delete(connectionId);\n                        }\n                    }\n                });\n            }\n            \n            // Then force update\n            this.connectionManager.forceUpdateConnectionsForNeuron(this.touchTargetNeuron);\n        }\n        \n        // Check for proximity connections\n        this.connectionManager.checkProximityConnection(this.touchTargetNeuron);\n    }\n\n    onTouchEnd(event) {\n        // If touch ended without any selection, just exit\n        if (!this.touchSelectionConfirmed && !this.isMultiTouch) {\n            return;\n        }\n        \n        event.preventDefault();\n        \n        if (this.isMultiTouch) {\n            // We were pinching - cleanup multi-touch state\n            this.isMultiTouch = false;\n            this.lastTouchDistance = 0;\n            this.lastMidpoint = null;\n        }\n        \n        // Capture the currently dragged neuron before we reset state\n        const wasDraggingNeuron = this.state.current === 'neuronDragging';\n        const draggedNeuron = this.touchTargetNeuron;\n        \n        // Handle momentum if we were dragging\n        if (wasDraggingNeuron && this.touchTargetNeuron) {\n            const speed = this.velocity.length();\n            if (speed > INPUT_CONFIG.mouse.dragThreshold) {\n                const targetPosition = new THREE.Vector3()\n                    .copy(this.touchTargetNeuron.position)\n                    .add(this.velocity.multiplyScalar(INPUT_CONFIG.animation.momentumMultiplier));\n                \n                // Ensure y coordinate stays at 0.1\n                targetPosition.y = 0.1;\n                \n                // Keep a reference to the neuron that we were dragging\n                const neuron = this.touchTargetNeuron;\n\n                gsap.to(neuron.position, {\n                    x: targetPosition.x,\n                    z: targetPosition.z,\n                    duration: INPUT_CONFIG.animation.momentumDuration,\n                    ease: \"power2.out\",\n                    onUpdate: () => {\n                        // Safety check to make sure neuron and touchArea still exist\n                        if (neuron && neuron.touchArea && neuron.parent) {\n                            neuron.touchArea.position.copy(neuron.position);\n                            this.connectionManager.checkProximityConnection(neuron);\n                        } else {\n                            // If the neuron has been removed, kill the animation\n                            const tween = gsap.getTweenById(this);\n                            if (tween) tween.kill();\n                        }\n                    }\n                });\n            }\n        }\n        \n        // Reset touch states but keep selection\n        this.setState('idle');\n        this.touchSelectionConfirmed = false;\n        this.touchTargetNeuron = null;\n        this.velocity.set(0, 0, 0);\n        window.draggedNeuron = null;  // Clear global reference\n        \n        // For mobile - ensure the hover label gets a timeout to hide\n        // This fixes cases where the timeout wasn't set during drag operations\n        const isMobile = window.innerWidth < 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        if (isMobile && wasDraggingNeuron && draggedNeuron) {\n            // Check if the hover label is visible\n            const hoverLabel = document.getElementById('neuron-hover-label');\n            if (hoverLabel && hoverLabel.style.display === 'block') {\n                // Set a timer to hide the label after dragging is complete\n                setTimeout(() => {\n                    // Double check the label still exists\n                    if (hoverLabel && hoverLabel.style) {\n                        hoverLabel.style.display = 'none';\n                    }\n                    // Also clear global reference\n                    window.currentHoveredNeuron = null;\n                }, 1000); // 1 second timeout\n            }\n        }\n    }\n\n    onMouseDown(event) {\n        this.updateMousePosition(event);\n        \n        // For touch events, create an event point\n        if (event.type === 'touchstart') {\n            this.touchStartTime = Date.now();\n        }\n        \n        // Cancel any active drag operation\n        this.isDragOperation = false;\n\n        // Handle right-click canvas dragging\n        if (event.button === 2) { // Right click\n            // Check if we're clicking on an arrow first\n            if (this.isClickingOnArrow(event)) {\n                // Let ConnectionManager handle the arrow click\n                return;\n            }\n\n            // If not clicking on an arrow, start canvas dragging\n            this.setState('rightClickDragging', { startPosition: this.mouse.clone() });\n            return;\n        }\n\n        // Determine whether we're clicking on a neuron\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Find all objects (visible and invisible)\n        const intersects = this.raycaster.intersectObjects(window.circles.flatMap(circle => \n            [circle, circle.touchArea].filter(obj => obj)\n        ), false);\n        \n        if (intersects.length > 0) {\n            this.setState('neuronDragging', { neuron: intersects[0].object });\n            \n            let selectedObject = intersects[0].object;\n            \n            // If we hit a touch area, get its parent circle\n            if (selectedObject.isHitArea && selectedObject.parentCircle) {\n                selectedObject = selectedObject.parentCircle;\n            }\n            \n            // Use the central selectNeuron method for consistency instead of direct calls\n            this.selectNeuron(selectedObject);\n            \n            const intersectionPoint = this.getIntersectionPoint(this.mouse);\n            this.dragOffset.copy(this.draggedNeuron.position).sub(intersectionPoint);\n            this.lastPosition.copy(this.draggedNeuron.position);\n        } else {\n            // Clicked on empty space - deselect current neuron\n            if (window.soundManager && window.selectedSynthFolder) {\n                window.soundManager.deselectNeuron();\n                this.toggleSynthPanel(false);\n            }\n            \n            // Deselect connection if we're not clicking on an arrow\n            // (ConnectionManager handles arrow clicks separately)\n            if (this.connectionManager && !this.isClickingOnArrow(event)) {\n                this.connectionManager.deselectConnection();\n            }\n        }\n    }\n\n    onMouseMove(event) {\n        // Handle right-click canvas dragging\n        if (this.state.current === 'rightClickDragging') {\n            this.updateMousePosition(event);\n            const deltaX = this.mouse.x - this.state.context.startPosition.x;\n            const deltaY = -(this.mouse.y - this.state.context.startPosition.y);\n            \n            // Calculate screen-to-world scaling factor\n            const rect = this.renderer.domElement.getBoundingClientRect();\n            const scaleX = (rect.width / 2) * this.canvasDragSpeed;\n            const scaleY = (rect.height / 2) * this.canvasDragSpeed;\n            \n            // Calculate movement delta\n            const worldDelta = new THREE.Vector3(\n                deltaX * scaleX,\n                0,\n                deltaY * scaleY\n            );\n            \n            // Update velocity for momentum\n            this.canvasDragVelocity.copy(worldDelta);\n            \n            // Move all neurons by the mouse delta\n            window.circles.forEach(circle => {\n                if (circle && circle.position) {\n                    circle.position.add(worldDelta);\n                    \n                    // Update touch area position if it exists\n                    if (circle.touchArea) {\n                        circle.touchArea.position.copy(circle.position);\n                    }\n                }\n            });\n            \n            // Update last mouse position\n            this.state.context.startPosition.copy(this.mouse);\n            return;\n        }\n\n        // NEW - Neuron hover detection for showing hover label\n        if (this.state.current === 'idle') {\n            this.updateMousePosition(event);\n            \n            // Check if we're hovering over a neuron\n            this.raycaster.setFromCamera(this.mouse, this.camera);\n            \n            // Get all objects that could be intersected (neurons and their touch areas)\n            const objects = window.circles.flatMap(circle => \n                [circle, circle.touchArea].filter(obj => obj)\n            );\n            \n            const intersects = this.raycaster.intersectObjects(objects, false);\n            \n            if (intersects.length > 0) {\n                // Found a neuron or touch area under the mouse\n                let hoverObject = intersects[0].object;\n                \n                // If we hit a touch area, get its parent circle\n                if (hoverObject.isHitArea && hoverObject.parentCircle) {\n                    hoverObject = hoverObject.parentCircle;\n                }\n                \n                // Update and show the hover label at the mouse position\n                if (window.updateNeuronHoverLabel) {\n                    window.updateNeuronHoverLabel(\n                        hoverObject, \n                        event.clientX, \n                        event.clientY\n                    );\n                }\n            } else {\n                // Not hovering over a neuron, hide the label\n                if (window.updateNeuronHoverLabel) {\n                    window.updateNeuronHoverLabel(null);\n                }\n            }\n        }\n\n        if (this.state.current !== 'neuronDragging') return;\n    \n        this.updateMousePosition(event);\n        const intersectionPoint = this.getIntersectionPoint(this.mouse);\n        \n        const newPosition = this.getVector3().copy(intersectionPoint).add(this.dragOffset);\n        newPosition.y = 0.1;\n    \n        this.velocity.subVectors(newPosition, this.lastPosition);\n        \n        this.draggedNeuron.position.copy(newPosition);\n        \n        // Update touch area position too\n        if (this.draggedNeuron.touchArea) {\n            this.draggedNeuron.touchArea.position.copy(this.draggedNeuron.position);\n        }\n        \n        this.lastPosition.copy(newPosition);\n    \n        // Update hover label for the dragged neuron too\n        if (window.updateNeuronHoverLabel) {\n            window.updateNeuronHoverLabel(\n                this.draggedNeuron, \n                event.clientX, \n                event.clientY\n            );\n        }\n        \n        // Store a global reference to the currently dragged neuron for use in ConnectionManager\n        window.draggedNeuron = this.draggedNeuron;\n        \n        // Force-update all connections related to this neuron immediately\n        // This ensures the arrows follow the neuron without delay during dragging\n        if (this.connectionManager && this.connectionManager.forceUpdateConnectionsForNeuron) {\n            // First clear any cached positions to force fresh calculations\n            if (this.connectionManager.arrowPositionCache) {\n                // Find all connections involving this neuron\n                this.connectionManager.connections.forEach(connection => {\n                    if (connection.source === this.draggedNeuron || \n                        connection.target === this.draggedNeuron) {\n                        // Clear the cached position\n                        const connectionId = connection.source?.neuron?.id + \"_\" + connection.target?.neuron?.id;\n                        if (connectionId) {\n                            this.connectionManager.arrowPositionCache.delete(connectionId);\n                        }\n                    }\n                });\n            }\n            \n            // Then force update\n            this.connectionManager.forceUpdateConnectionsForNeuron(this.draggedNeuron);\n        }\n        \n        // Check for nearby neurons and trigger feedback\n        const circles = window.circles || [];\n        circles.forEach(otherNeuron => {\n            if (!otherNeuron || otherNeuron === this.draggedNeuron) return;\n            \n            const distance = this.draggedNeuron.position.distanceTo(otherNeuron.position);\n            const threshold = 0.5;\n    \n            // Check if connection exists\n            let connectionExists = false;\n            this.connectionManager.connections.forEach(connection => {\n                if ((connection.source === this.draggedNeuron && connection.target === otherNeuron) ||\n                    (connection.source === otherNeuron && connection.target === this.draggedNeuron)) {\n                    connectionExists = true;\n                }\n            });\n    \n            if (distance < threshold && !connectionExists) {\n                // Trigger green feedback on both neurons\n                const draggedNeuron = this.draggedNeuron; // Store reference for animation\n                const originalColor = draggedNeuron.material.color.clone();\n                \n                gsap.to(draggedNeuron.material.color, {\n                    r: 0,\n                    g: 1,\n                    b: 0,\n                    duration: 0.2,\n                    onComplete: () => {\n                        // Check if the neuron still exists before animating back\n                        if (draggedNeuron.parent) {\n                            gsap.to(draggedNeuron.material.color, {\n                                r: originalColor.r,\n                                g: originalColor.g,\n                                b: originalColor.b,\n                                duration: 0.2\n                            });\n                        }\n                    }\n                });\n                \n                // Also trigger feedback on the other neuron\n                const otherOriginalColor = otherNeuron.material.color.clone();\n                gsap.to(otherNeuron.material.color, {\n                    r: 0,\n                    g: 1,\n                    b: 0,\n                    duration: 0.2,\n                    onComplete: () => {\n                        // Check if the other neuron still exists\n                        if (otherNeuron.parent) {\n                            gsap.to(otherNeuron.material.color, {\n                                r: otherOriginalColor.r,\n                                g: otherOriginalColor.g,\n                                b: otherOriginalColor.b,\n                                duration: 0.2\n                            });\n                        }\n                    }\n                });\n            }\n        });\n    \n        // Check for connections while dragging\n        this.connectionManager.checkProximityConnection(this.draggedNeuron);\n    }\n\n    onMouseUp(event) {\n        // Handle right-click drag end\n        if (this.state.current === 'rightClickDragging') {\n            this.setState('idle');\n            this.canvasDragVelocity.set(0, 0, 0);\n            return;\n        }\n\n        // Check if we're dealing with a simple click vs. a drag\n        const wasJustAClick = this.state.current === 'neuronDragging' && this.velocity.length() < INPUT_CONFIG.mouse.dragThreshold;\n        \n        if (this.state.current === 'neuronDragging' && this.draggedNeuron) {\n            // Handle momentum for actual drags\n            const speed = this.velocity.length();\n            if (speed > INPUT_CONFIG.mouse.dragThreshold) {\n                const targetPosition = new THREE.Vector3()\n                    .copy(this.draggedNeuron.position)\n                    .add(this.velocity.multiplyScalar(INPUT_CONFIG.animation.momentumMultiplier));\n                \n                // Ensure y coordinate stays at 0.1\n                targetPosition.y = 0.1;\n                \n                // Keep a reference to the neuron that we were dragging\n                const neuron = this.draggedNeuron;\n\n                gsap.to(neuron.position, {\n                    x: targetPosition.x,\n                    z: targetPosition.z,\n                    duration: INPUT_CONFIG.animation.momentumDuration,\n                    ease: \"power2.out\",\n                    onUpdate: () => {\n                        // Safety check to make sure neuron and touchArea still exist\n                        if (neuron && neuron.touchArea && neuron.parent) {\n                            neuron.touchArea.position.copy(neuron.position);\n                            this.connectionManager.checkProximityConnection(neuron);\n                        } else {\n                            // If the neuron has been removed, kill the animation\n                            const tween = gsap.getTweenById(this);\n                            if (tween) tween.kill();\n                        }\n                    }\n                });\n            } else if (wasJustAClick) {\n                // If it was just a click (not a significant drag)\n                // Just update the neuron label, don't show sound panel\n                if (this.draggedNeuron && this.draggedNeuron.neuron) {\n                    console.log(\"Neuron clicked, updated neuron label:\", this.draggedNeuron.neuron.id);\n                    if (window.updateNeuronLabel) {\n                        window.updateNeuronLabel(this.draggedNeuron.neuron.id);\n                    }\n                }\n            }\n        }\n\n        this.setState('idle');\n        this.draggedNeuron = null;   // Reset the dragged neuron reference\n        window.draggedNeuron = null;  // Clear global reference as well\n        this.velocity.set(0, 0, 0);\n    }\n\n    onWheel(event) {\n        event.preventDefault();\n        \n        this.updateMousePosition(event);\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        const intersects = this.raycaster.intersectObjects(window.circles);\n        \n        if (intersects.length > 0) {\n            const neuron = intersects[0].object;\n            // Use 0.01 steps for more precise DC control\n            const delta = event.deltaY > 0 ? -0.01 : 0.01;\n            \n            if (neuron.neuron) {\n                // For better consistency, track the last DC change time\n                const currentTime = performance.now();\n                const lastChangeTime = neuron.neuron.lastDCChangeTime || 0;\n                \n                // Prevent too frequent DC changes (helps with rhythm consistency)\n                if (currentTime - lastChangeTime < 50) { // 50ms minimum between changes\n                    return;\n                }\n                \n                // Calculate new DC value\n                let newDC = (neuron.neuron.dcInput || 0) + delta;\n                newDC = Math.max(0, Math.min(1, newDC));\n                \n                // Track DC change time\n                neuron.neuron.lastDCChangeTime = currentTime;\n                \n                // If DC becomes 0, use the reset method instead of direct property assignment\n                // This properly resets the neuron state through the centralized system\n                if (newDC === 0) {\n                    // Use the reset method which properly handles state changes\n                    neuron.neuron.reset();\n                }\n                \n                // Apply the new DC value but keep accumulated charge\n                neuron.neuron.setDCInput(newDC);\n                \n                // Force update scale with animation for better visual feedback\n                const targetScale = neuron.neuron.baseScale + \n                    (neuron.neuron.maxScale - neuron.neuron.baseScale) * newDC;\n                \n                gsap.to(neuron.scale, {\n                    x: targetScale,\n                    y: targetScale,\n                    z: targetScale,\n                    duration: 0.2,\n                    ease: \"power2.out\"\n                });\n            }\n        }\n    }\n\n    cleanup() {\n        if (this.isMobile) {\n            this.renderer.domElement.removeEventListener('touchstart', this.onTouchStartBound);\n            this.renderer.domElement.removeEventListener('touchmove', this.onTouchMoveBound);\n            this.renderer.domElement.removeEventListener('touchend', this.onTouchEndBound);\n            this.renderer.domElement.removeEventListener('contextmenu', e => e.preventDefault());\n            \n            // Remove mobile UI elements\n            if (this.mobileControls?.parentNode) {\n                this.mobileControls.parentNode.removeChild(this.mobileControls);\n                this.mobileControls = null;\n            }\n        } else {\n            this.renderer.domElement.removeEventListener('mousedown', this.onMouseDownBound);\n            this.renderer.domElement.removeEventListener('mousemove', this.onMouseMoveBound);\n            this.renderer.domElement.removeEventListener('mouseup', this.onMouseUpBound);\n            this.renderer.domElement.removeEventListener('mouseleave', this.onMouseLeaveBound); // Remove mouseleave handler\n            this.renderer.domElement.removeEventListener('wheel', this.onWheelBound);\n            this.renderer.domElement.removeEventListener('dblclick', this.onDoubleClickBound); // Added this line\n        }\n\n        // Remove our context menu handler\n        this.renderer.domElement.removeEventListener('contextmenu', this.handleRightClickBound);\n    }\n\n    // Method to toggle the visibility of the synth panel\n    toggleSynthPanel(show, neuron = null) {\n        // Get a reference to the synth folder from window\n        const synthFolder = window.selectedSynthFolder;\n        \n        if (synthFolder) {\n            if (show) {\n                console.log(\"InputManager: Showing synth panel\");\n                \n                // Get screen size to determine if we're in desktop mode\n                const isDesktop = window.innerWidth >= 1024;\n                \n                // Show the panel (although in desktop mode this might already be visible)\n                if (!isDesktop) {\n                    // Mark the panel for CSS targeting\n                    synthFolder.element.dataset.synthPanel = 'true';\n                    synthFolder.element.style.display = 'block';\n                    // Don't reposition the panel - CSS will handle it\n                }\n                \n                // Make sure we have a neuron\n                if (neuron && neuron.neuron) {\n                    // Update the neuron label with the neuron's ID\n                    if (window.updateNeuronLabel) {\n                        window.updateNeuronLabel(neuron.neuron.id);\n                    }\n                    \n                    // Default delay before refreshing\n                    const refreshDelay = 10;\n                    \n                    // Add a small delay to ensure DOM changes have propagated\n                    setTimeout(() => {\n                        // Update the connection parameters in Tweakpane\n                        if (window.refreshSoundControls) {\n                            window.refreshSoundControls();\n                        }\n                        \n                        // Update envelope visualization if available\n                        if (window.forceRenderEnvelope) {\n                            window.forceRenderEnvelope();\n                        }\n                    \n                        // Update note button UI if needed\n                        if (window.updateActiveNoteButton && window.settings.selectedNote) {\n                            window.updateActiveNoteButton(window.settings.selectedNote);\n                        }\n                        \n                        console.log(\"Synth panel fully refreshed\");\n                    }, refreshDelay); // Short delay to ensure DOM is updated\n                }\n            } else {\n                const isDesktop = window.innerWidth >= 1024;\n                \n                if (!isDesktop) {\n                    console.log(\"InputManager: Hiding synth panel\");\n                    // Hide the panel only in mobile mode\n                    synthFolder.element.style.display = 'none';\n                } else {\n                    console.log(\"InputManager: Desktop mode - panel remains visible but shows placeholder\");\n                    // In desktop mode, we keep the panel visible but update to show placeholder\n                    if (window.updateSynthFolderDisplay) {\n                        window.updateSynthFolderDisplay();\n                    }\n                }\n                \n                // Always hide the neuron label when no neuron is selected\n                if (window.updateNeuronLabel) {\n                    window.updateNeuronLabel(null);\n                }\n                \n                // Reset active note button\n                if (window.updateActiveNoteButton) {\n                    window.updateActiveNoteButton(null);\n                }\n            }\n        } else {\n            console.warn(\"InputManager: selectedSynthFolder not available\");\n        }\n        \n        // Update only the neuron label position, not the panel position\n        if (window.updateNeuronLabelPosition) {\n            setTimeout(() => window.updateNeuronLabelPosition(), 20);\n        }\n    }\n    \n    // --- Method to select a neuron --- \n    selectNeuron(circle) {\n        if (this.draggedNeuron === circle) return; // Already selected\n        this.deselectNeuron(); // Deselect previous one first\n        this.draggedNeuron = circle;\n        if (this.draggedNeuron && this.draggedNeuron.neuron) {\n            console.log(\"Selected Neuron:\", this.draggedNeuron.neuron.id);\n            // ... existing color/visual feedback code ...\n            // Selection ring has been removed - no need to update\n            if (window.updateNeuronLabel) {\n                window.updateNeuronLabel(this.draggedNeuron.neuron.id);\n            }\n            if (window.soundManager) {\n                window.soundManager.selectedNeuronId = this.draggedNeuron.neuron.id;\n                const params = window.soundManager.getNeuronSoundParameters(this.draggedNeuron.neuron.id);\n                if (params) {\n                    // Only show synth panel automatically on desktop\n                    if (window.innerWidth >= 1024) {\n                    this.toggleSynthPanel(true, this.draggedNeuron.neuron);\n                    }\n                    if (window.refreshSoundControls) {\n                        window.refreshSoundControls();\n                    }\n                    if (this.draggedNeuron.neuron.presetName && window.highlightPresetButton) {\n                        window.highlightPresetButton(this.draggedNeuron.neuron.presetName);\n                    } else if (window.unhighlightActivePreset) {\n                        window.unhighlightActivePreset();\n                    }\n                    \n                    // Don't play preview sound when selecting a neuron\n                    if (window.soundManager.previewDebounceTimeout) {\n                        clearTimeout(window.soundManager.previewDebounceTimeout);\n                    }\n                }\n            }\n            if (window.updateNeuronGrid) {\n                window.updateNeuronGrid();\n            }\n            // No need to reset active DC neurons on selection anymore\n            // We maintain firing continuity with our improved setDCInput method\n        }\n    }\n    \n    // --- Method to deselect a neuron ---\n    deselectNeuron() {\n        if (this.draggedNeuron === null) return;\n        \n        // Return to original color if it was saved\n        if (this.draggedNeuron.originalColor) {\n            // Immediately set back to original color\n            this.draggedNeuron.material.color.copy(this.draggedNeuron.originalColor);\n            \n            // If this neuron has a preset color saved, restore it\n            if (this.draggedNeuron.neuron && this.draggedNeuron.neuron.presetColor) {\n                this.draggedNeuron.material.color.copy(this.draggedNeuron.neuron.presetColor);\n            }\n        }\n        \n        // Tell the sound manager we're deselecting\n        if (window.soundManager) {\n            window.soundManager.selectedNeuronId = null;\n        }\n        \n        // Deactivate selection ring\n                    // Selection ring has been removed - no need to deselect\n        \n        // Hide the label\n        if (window.updateNeuronLabel) {\n            window.updateNeuronLabel(null);\n        }\n        \n        // Hide synth panel\n        this.toggleSynthPanel(false);\n        \n        // Clean up the reference\n        this.draggedNeuron = null;\n        \n        // Update neuron grid\n        if (window.updateNeuronGrid) {\n            window.updateNeuronGrid();\n        }\n        \n        // No need to reset active DC neurons on deselection anymore\n        // We maintain firing continuity with our improved setDCInput method\n    }\n    \n    handleOutsideClick(event) {\n        // If the click is on the canvas, let the canvas handlers manage selection\n        if (event.target === this.renderer.domElement) {\n            return;\n        }\n        // If the click is inside the Tweakpane panel, ignore it\n        if (window.pane && window.pane.element.contains(event.target)) {\n             return;\n        }\n        \n        // Otherwise, deselect any selected neuron\n        this.deselectNeuron();\n    }\n\n    // Helper method to find outgoing connections from a neuron\n    findOutgoingConnections(neuron) {\n        if (!neuron || !this.connectionManager) return [];\n        \n        const outgoingConnections = [];\n        this.connectionManager.connections.forEach(connection => {\n            if (connection.source === neuron) {\n                outgoingConnections.push(connection);\n            }\n        });\n        \n        return outgoingConnections;\n    }\n\n    // Helper to check if we're clicking on an arrow\n    isClickingOnArrow(event) {\n        // Properly handle touch events by extracting touch position\n        if (event.touches) {\n            this.updateTouchPosition(event.touches[0]);\n        } else {\n            this.updateMousePosition(event);\n        }\n        \n        const raycaster = new THREE.Raycaster();\n        raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // For mobile, use a much larger threshold to make arrow detection easier\n        if (event.touches) {\n            raycaster.params.Line = raycaster.params.Line || {};\n            raycaster.params.Line.threshold = 15; // Increased threshold for touch (was 10)\n        }\n        \n        if (!this.connectionManager) return false;\n        \n        const arrows = Array.from(this.connectionManager.connections.values())\n            .map(connection => connection.arrow)\n            .filter(Boolean);\n        \n        const intersects = raycaster.intersectObjects(arrows);\n        return intersects.length > 0;\n    }\n\n    // Helper method to visualize touch points (for debugging)\n    showTouchDebug(x, y) {\n        // Remove old debug element if it exists\n        const oldDebug = document.getElementById('touch-debug');\n        if (oldDebug) {\n            document.body.removeChild(oldDebug);\n        }\n        \n        // Create new debug element\n        const debugEl = document.createElement('div');\n        debugEl.id = 'touch-debug';\n        debugEl.style.position = 'absolute';\n        debugEl.style.left = (x - 10) + 'px';\n        debugEl.style.top = (y - 10) + 'px';\n        debugEl.style.width = '20px';\n        debugEl.style.height = '20px';\n        debugEl.style.borderRadius = '50%';\n        debugEl.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';\n        debugEl.style.pointerEvents = 'none';\n        debugEl.style.zIndex = '10000';\n        \n        document.body.appendChild(debugEl);\n        \n        // Remove after a short time\n        setTimeout(() => {\n            if (debugEl.parentNode) {\n                document.body.removeChild(debugEl);\n            }\n        }, 1000);\n    }\n\n    // Helper method to toggle visibility of touch areas for debugging\n    toggleTouchAreaVisibility(visible) {\n        this.debugTouchAreas = visible !== undefined ? visible : !this.debugTouchAreas;\n        \n        window.circles.forEach(circle => {\n            if (circle.touchArea) {\n                if (this.debugTouchAreas) {\n                    circle.touchArea.material.opacity = 0.2;\n                    circle.touchArea.visible = true;\n                } else {\n                    circle.touchArea.visible = false;\n                }\n            }\n        });\n        \n        console.log(`Touch areas are now ${this.debugTouchAreas ? 'visible' : 'hidden'}`);\n        return this.debugTouchAreas;\n    }\n\n    // Add helper methods\n    getVector3() {\n        return this.vector3Pool.pop() || new THREE.Vector3();\n    }\n\n    releaseVector3(v) {\n        if (this.vector3Pool.length < 20) {\n            v.set(0, 0, 0);\n            this.vector3Pool.push(v);\n        }\n    }\n\n    setState(newState, context = {}) {\n        console.log(`State transition: ${this.state.current} -> ${newState}`);\n        this.state.current = newState;\n        this.state.context = {...this.state.context, ...context};\n    }\n\n    initializeUI() {\n        // Only initialize if these objects/functions exist in the window\n        this.ui = this.ui || {};\n        this.ui.synthFolder = window.selectedSynthFolder;\n        this.ui.neuronLabel = document.getElementById('neuron-label');\n        \n        // Initialize refresh functions object if not already\n        this.ui.refreshFunctions = this.ui.refreshFunctions || {};\n        this.ui.refreshFunctions.soundControls = window.refreshSoundControls;\n        this.ui.refreshFunctions.activeNoteButton = window.updateActiveNoteButton;\n        this.ui.refreshFunctions.neuronLabel = window.updateNeuronLabel;\n        this.ui.refreshFunctions.envelope = window.forceRenderEnvelope;\n        \n        console.log(\"UI references initialized:\", this.ui);\n    }\n    \n    // Add a helper method to safely access UI elements\n    getUIElement(path) {\n        // Example: getUIElement(\"synthFolder.element\") \n        const parts = path.split('.');\n        let current = this.ui;\n        \n        for (const part of parts) {\n            if (!current || current[part] === undefined) {\n                return null;\n            }\n            current = current[part];\n        }\n        \n        return current;\n    }\n\n    // Add a new method to handle right-click for neuron deletion\n    handleRightClick(event) {\n        // Prevent the default context menu\n        event.preventDefault();\n        \n        // Update mouse position and raycaster\n        this.updateMousePosition(event);\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // First, check for signal particles (prioritize them)\n        if (window.Neuron && window.Neuron.allParticles) {\n            const particleIntersects = this.raycaster.intersectObjects(window.Neuron.allParticles);\n            \n            if (particleIntersects.length > 0) {\n                // Found a signal particle, delete it\n                const particle = particleIntersects[0].object;\n                this.deleteSignalParticle(particle);\n                return; // Exit after deleting a particle\n            }\n        }\n        \n        // If no particle was clicked, check for neuron intersections\n        const touchAreas = window.circles\n            .map(circle => circle.touchArea)\n            .filter(Boolean);\n        \n        const intersects = this.raycaster.intersectObjects(touchAreas, false);\n        \n        if (intersects.length > 0) {\n            // Found a neuron to delete\n            const touchArea = intersects[0].object;\n            if (touchArea.parentCircle && touchArea.isHitArea) {\n                const neuronToDelete = touchArea.parentCircle;\n                \n                // Delete the neuron - the deleteNeuron method now handles all animations\n                this.deleteNeuron(neuronToDelete);\n            }\n        }\n    }\n    \n    // Add method to handle neuron deletion\n    deleteNeuron(neuron) {\n        if (!neuron) return;\n        \n        console.log(\"Deleting neuron:\", neuron.neuron?.id);\n        \n        // Create a red particle explosion animation\n        const createRedParticleExplosion = (neuron) => {\n            if (!neuron || !neuron.position) return;\n            \n            // Create 12 particles in a burst around the neuron (more for deletion)\n            const numParticles = 12;\n            const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);\n            \n            // Create bright red material for particles\n            const particleMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(1.5, 0, 0), // Bright red\n                transparent: true,\n                opacity: 0.9\n            });\n            \n            for (let i = 0; i < numParticles; i++) {\n                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());\n                const angle = (i / numParticles) * Math.PI * 2;\n                const radius = 0.2;\n                \n                // Position around the neuron in a circle\n                particle.position.set(\n                    neuron.position.x + Math.cos(angle) * radius,\n                    neuron.position.y,\n                    neuron.position.z + Math.sin(angle) * radius\n                );\n                \n                // Set rotation to face camera\n                particle.rotation.x = -Math.PI / 2;\n                \n                // Add to scene (use window.scene for the particles to outlive the neuron)\n                if (window.scene) {\n                    window.scene.add(particle);\n                } else if (neuron.parent) {\n                    neuron.parent.add(particle);\n                }\n                \n                // Animate outward in a straight line with slightly faster speed for deletion\n                gsap.to(particle.position, {\n                    x: neuron.position.x + Math.cos(angle) * (radius * 5), // Increased spread\n                    z: neuron.position.z + Math.sin(angle) * (radius * 5),\n                    duration: 0.8, // Faster animation\n                    ease: \"power2.out\"\n                });\n                \n                // Fade out and remove\n                gsap.to(particle.material, {\n                    opacity: 0,\n                    duration: 0.8, // Match position animation\n                    ease: \"power2.out\",\n                    onComplete: () => {\n                        // Clean up particle from scene\n                        if (particle.parent) {\n                            particle.parent.remove(particle);\n                        }\n                        \n                        // Dispose resources\n                        if (particle.material) {\n                            particle.material.dispose();\n                        }\n                        if (particle.geometry) {\n                            particle.geometry.dispose();\n                        }\n                        \n                        // Remove from global particles array\n                        const index = window.Neuron.allParticles.indexOf(particle);\n                        if (index !== -1) {\n                            window.Neuron.allParticles.splice(index, 1);\n                        }\n                    }\n                });\n            }\n        };\n        \n        // Trigger the particle explosion\n        createRedParticleExplosion(neuron);\n        \n        // Get the neuron's ID before removal for use in signal particle cleanup\n        const neuronId = neuron.neuron?.id;\n        \n        // Make the neuron flash red and shrink before deletion\n        if (neuron.material) {\n            const originalColor = neuron.material.color.clone();\n            const originalScale = neuron.scale.clone();\n            \n            // Create a timeline for blinking red effect before shrinking\n            const timeline = gsap.timeline();\n            \n            // Check if material supports emissive property (MeshStandardMaterial or MeshPhongMaterial)\n            const hasEmissive = neuron.material.emissive !== undefined;\n            \n            // Store original emissive color if it exists\n            const originalEmissive = hasEmissive ? neuron.material.emissive.clone() : null;\n            \n            // Add 2 red blinks (red -> original -> red) and end on red\n            // Use a brighter red with r value > 1 for more intensity\n            timeline.to(neuron.material.color, { \n                r: 1.6, g: 0, b: 0, \n                duration: 0.15,\n                onStart: () => {\n                    // Set emissive to red if supported\n                    if (hasEmissive) {\n                        neuron.material.emissive.set(0xff0000);\n                    }\n                }\n            })\n            .to(neuron.material.color, { \n                r: originalColor.r, \n                g: originalColor.g, \n                b: originalColor.b, \n                duration: 0.15,\n                onStart: () => {\n                    // Reset emissive if supported\n                    if (hasEmissive && originalEmissive) {\n                        neuron.material.emissive.copy(originalEmissive);\n                    }\n                }\n            })\n            .to(neuron.material.color, { \n                r: 1.6, g: 0, b: 0, \n                duration: 0.15,\n                onStart: () => {\n                    // Set emissive to red if supported\n                    if (hasEmissive) {\n                        neuron.material.emissive.set(0xff0000);\n                    }\n                }\n            });\n            \n            // No shrinking animation - just delete immediately after blinking\n        }\n        \n        // Minimal delay for the second red blink to complete\n        setTimeout(() => {\n            // If this was the selected neuron, deselect it first\n            if (this.draggedNeuron === neuron) {\n                this.deselectNeuron();\n            }\n            \n            // Remove all connections to and from this neuron\n            if (this.connectionManager) {\n                // Delete connections where this neuron is the source\n                for (const [group, connection] of this.connectionManager.connections.entries()) {\n                    if (connection.source === neuron || connection.target === neuron) {\n                        this.connectionManager.disposeConnection(connection, group);\n                    }\n                }\n            }\n            \n            // Clean up all signal particles heading to or from this neuron\n            if (window.Neuron && window.Neuron.allParticles && neuronId) {\n                // Create a copy of the array to safely remove while iterating\n                const particles = [...window.Neuron.allParticles];\n                \n                for (const particle of particles) {\n                    // Check if this particle is heading to or from the deleted neuron\n                    if (particle.targetNeuronId === neuronId || particle.sourceNeuronId === neuronId) {\n                        // Visual feedback - briefly flash red before deletion\n                        gsap.to(particle.material.color, {\n                            r: 1, g: 0, b: 0, // Red\n                            duration: 0.1,\n                            onComplete: () => {\n                                // Remove from scene\n                                if (particle.parent) {\n                                    particle.parent.remove(particle);\n                                }\n                                \n                                // Dispose resources\n                                if (particle.material) {\n                                    particle.material.dispose();\n                                }\n                                \n                                // Remove from global particles array\n                                const index = window.Neuron.allParticles.indexOf(particle);\n                                if (index !== -1) {\n                                    window.Neuron.allParticles.splice(index, 1);\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n            \n            // Clean up the neuron's resources\n            if (neuron.neuron) {\n                neuron.neuron.cleanup();\n            }\n            \n            // Remove touch area from scene\n            if (neuron.touchArea && neuron.touchArea.parent) {\n                neuron.touchArea.parent.remove(neuron.touchArea);\n                neuron.touchArea.geometry.dispose();\n                neuron.touchArea.material.dispose();\n            }\n            \n            // Remove neuron from scene\n            if (neuron.parent) {\n                neuron.parent.remove(neuron);\n            }\n            \n            // Remove neuron from circles array\n            const index = window.circles.indexOf(neuron);\n            if (index > -1) {\n                window.circles.splice(index, 1);\n            }\n            \n            // Dispose geometry and materials\n            if (neuron.geometry) neuron.geometry.dispose();\n            if (neuron.material) neuron.material.dispose();\n            \n            // Explicitly silence any sounds associated with this neuron\n            if (window.soundManager && neuronId) {\n                try {\n                    if (typeof window.soundManager.silenceNeuron === 'function') {\n                        window.soundManager.silenceNeuron(neuronId);\n                    }\n                } catch (error) {\n                    console.warn('Error silencing neuron during deletion:', error);\n                }\n            }\n            \n            // If this was the last neuron, silence all sounds\n            if (window.circles.length === 0 && window.soundManager) {\n                try {\n                    if (typeof window.soundManager.silenceAllNeurons === 'function') {\n                        window.soundManager.silenceAllNeurons();\n                    }\n                } catch (error) {\n                    console.warn('Error silencing all sounds after deleting last neuron:', error);\n                }\n            }\n            \n            // Play deletion sound if sound manager exists\n            if (window.soundManager && typeof window.soundManager.playSmallSound === 'function') {\n                try {\n                    window.soundManager.playSmallSound(0.5, 0.3, 0.7); // Different sound for neuron deletion\n                } catch (error) {\n                    console.warn('Error playing neuron deletion sound:', error);\n                }\n            }\n            \n            // Update the neuron grid display if available\n            if (window.updateNeuronGrid) {\n                window.updateNeuronGrid();\n            }\n        }, 350); // Only wait for the two blinks to complete (0.15 + 0.15 + 0.15 = 0.45s)\n    }\n\n    // NEW - handle mouse leave event\n    onMouseLeave() {\n        // Hide the hover label when the mouse leaves the canvas\n        if (window.updateNeuronHoverLabel) {\n            window.updateNeuronHoverLabel(null);\n        }\n        \n        // Clear the hovered neuron reference\n        window.currentHoveredNeuron = null;\n    }\n\n    // Add a new method to delete signal particles\n    deleteSignalParticle(particle) {\n        if (!particle) return;\n        \n        console.log(\"Deleting signal particle\");\n        \n        // Visual feedback - briefly flash red before deletion\n        gsap.to(particle.material.color, {\n            r: 1, g: 0, b: 0, // Red\n            duration: 0.1,\n            onComplete: () => {\n                // Remove from scene\n                if (particle.parent) {\n                    particle.parent.remove(particle);\n                }\n                \n                // Dispose resources\n                if (particle.material) {\n                    particle.material.dispose();\n                }\n                \n                // Remove from global particles array\n                if (window.Neuron && window.Neuron.allParticles) {\n                    const index = window.Neuron.allParticles.indexOf(particle);\n                    if (index !== -1) {\n                        window.Neuron.allParticles.splice(index, 1);\n                    }\n                }\n                \n                // Play a soft deletion sound if sound manager exists\n                if (window.soundManager && typeof window.soundManager.playSmallSound === 'function') {\n                    try {\n                        window.soundManager.playSmallSound(0.3, 0.6, 0.2); // Different sound for particle deletion\n                    } catch (error) {\n                        console.warn('Error playing particle deletion sound:', error);\n                    }\n                }\n            }\n        });\n    }\n}","import * as Tone from 'tone';\n\n/**\n * OptimizedSoundManager class\n * Provides an optimized sound engine for SNN visualization with up to 100 neurons\n * Uses a bus-based architecture with voice allocation to maximize performance\n */\nexport class OptimizedSoundManager {\n    constructor(scene, camera, renderer) {\n        // Core references\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        \n        // Initialize audio context\n        this.ensureAudioContext();\n        \n        // Global settings\n        this.volume = -6;\n        this.volumeNormalization = 1.0; // Add volume normalization factor\n        this.baseFrequency = 440;\n        \n        // Add spatial audio settings\n        this.spatialAudioEnabled = false;\n        this.spatialAudioPanners = new Map(); // Store panners by neuron ID\n        this.spatialAudioNodes = new Map(); // Store all nodes for cleanup\n        \n        // Data structures for neuron sound parameters\n        this.neuronSoundOverrides = new Map();\n        this.neuronFrequencies = new Map();\n        this.neuronBusAssignments = new Map();\n        \n        // Keep track of the last selected neuron's parameters to apply to new neurons\n        this.lastSelectedNeuronParams = null;\n        \n        // Voice management\n        this.activeVoices = new Set();\n        this.maxVoices = 48;  // Increased from 24 to 48 maximum concurrent voices\n        this.voiceTimeout = 1000; // Reduced from 2000ms to 1000ms - voice considered active for 1s\n        this.voicePriorities = new Map(); // Neuron ID to priority score\n        this.lastPlayTime = 0;\n        this.minTimeBetweenNotes = 15; // Increased from 5ms to 15ms for more consistent timing\n        this.neuronLastPlayTime = new Map(); // Track last play time per neuron for rhythm consistency\n        \n        // Add tracking for polyphony management\n        this.lastPlayedNotes = [];\n        \n        // Added tracking for recent sound types to detect potential clipping scenarios\n        this.recentSoundTypes = {\n            bass: { lastPlayed: 0, isPlaying: false },\n            hihat: { lastPlayed: 0, isPlaying: false }\n        };\n        \n        // Add performance monitoring statistics\n        this.stats = {\n            totalOscillators: 0,\n            activeOscillators: 0,\n            oscillatorsCreated: 0,\n            oscillatorsDisposed: 0,\n            lastStatsTime: Date.now(),\n            peakOscillatorCount: 0\n        };\n        \n        // Selection state\n        this.selectedNeuronId = null;\n        this.playPreviewSounds = false;\n        \n        // Musical parameters\n        this.melodicPattern = [0, 2, 4, 7, 9, 12, 11, 9, 7, 4, 2, 0];\n        this.currentPatternIndex = 0;\n        this.lastFreqIndex = 0;\n        this.melodyDirection = 1;\n        \n        // Frequency ranges organized by bus type\n        this.frequencyRanges = {\n            low: ['C2', 'D2', 'E2', 'G2', 'A2', 'C3'],\n            mid: ['C3', 'D3', 'E3', 'G3', 'A3', 'C4'],\n            high: ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'],\n            veryHigh: ['C5', 'D5', 'E5', 'G5', 'A5', 'C6'], // High range\n            ultra: ['C6', 'D6', 'E6', 'G6', 'A6'] // Highest range\n        };\n        \n        // Last used audio time for scheduling (prevents errors)\n        this.lastAudioTime = 0;\n        \n        // Initialize bus structure and audio chain\n        this.initializeAudioBuses();\n        \n        // Available types for UI controls\n        this.oscillatorTypes = [\n            \"sine\", \"triangle\", \"sawtooth\", \"square\", \n            \"sine3\", \"triangle3\", \"sawtooth3\", \"square3\", \"noise\"\n        ];\n        \n        this.envelopeCurves = [\n            \"linear\", \"exponential\", \"sine\", \"cosine\", \"bounce\", \"ripple\", \"step\"\n        ];\n        \n        this.filterTypes = [\n            \"lowpass\", \"highpass\", \"bandpass\", \"notch\", \"lowshelf\", \"highshelf\", \"allpass\"\n        ];\n        \n        // Initialize analyzer\n        this.waveformAnalyzer = new Tone.Analyser(\"waveform\", 1024);\n        Tone.Destination.connect(this.waveformAnalyzer);\n\n        // Initialize oscillator bank with lazy loading\n        this.oscillatorBank = new Map();\n        this.pendingOscillators = new Map(); // Track oscillators scheduled for creation\n        this._cleanupScheduled = false;\n        this.initializeOscillatorBank();\n    }\n    \n    // Modified method to initialize the oscillator bank with lazy loading\n    initializeOscillatorBank() {\n        console.log(\"%c[OSCILLATOR BANK] Initializing optimized oscillator bank with lazy loading\", \"color: #00ff00; font-weight: bold;\");\n        \n        // Only pre-create a small subset of common oscillators\n        const commonNotes = ['C3', 'E3', 'G3', 'C4']; // Most common notes\n        const commonTypes = [\"sine\", \"triangle\"]; // Most common types\n        \n        // Convert notes to frequencies\n        const commonFrequencies = commonNotes.map(note => Tone.Frequency(note).toFrequency());\n        \n        // Setup all type maps first\n        this.oscillatorTypes.forEach(type => {\n            this.oscillatorBank.set(type, new Map());\n        });\n        \n        // Create only common oscillators upfront\n        commonTypes.forEach(type => {\n            commonFrequencies.forEach(freq => {\n                this._createOscillator(type, freq);\n            });\n        });\n        \n        console.log(`%c[OSCILLATOR BANK] Created initial bank with ${commonTypes.length} types × ${commonFrequencies.length} frequencies = ${commonTypes.length * commonFrequencies.length} oscillators`, \"color: #00ff00; font-weight: bold;\");\n        console.log(\"%c[OSCILLATOR BANK] Lazy oscillator creation ENABLED\", \"color: #00ff00; font-weight: bold; font-size: 14px;\");\n        \n        // Schedule periodic cleanup\n        setInterval(() => this.cleanupUnusedOscillators(), 60000); // Cleanup once per minute\n        this._cleanupScheduled = true;\n    }\n    \n    // New method to create oscillator on demand\n    _getOrCreateOscillator(type, freq) {\n        // Check if it exists\n        if (this.oscillatorBank.has(type) && this.oscillatorBank.get(type).has(freq)) {\n            const oscData = this.oscillatorBank.get(type).get(freq);\n            oscData.lastUsed = Date.now(); // Update usage timestamp\n            return oscData;\n        }\n        \n        // If not, create it\n        return this._createOscillator(type, freq);\n    }\n    \n    // New helper method to create oscillator\n    _createOscillator(type, freq) {\n        // Ensure type map exists\n        if (!this.oscillatorBank.has(type)) {\n            this.oscillatorBank.set(type, new Map());\n        }\n        \n        // Create oscillator\n        let osc;\n        if (type === 'noise') {\n            osc = new Tone.Noise('white');\n            osc.start();\n        } else {\n            osc = new Tone.Oscillator({\n                frequency: freq,\n                type: type\n            }).start();\n        }\n        \n        // Create gain node (starts at 0 - silent)\n        const gain = new Tone.Gain(0);\n        \n        // Connect oscillator -> gain\n        osc.connect(gain);\n        \n        // Store in the bank with last used timestamp\n        const oscData = {\n            oscillator: osc,\n            gain: gain,\n            activeNeurons: new Set(),\n            lastUsed: Date.now()\n        };\n        \n        // Update stats\n        this.stats.oscillatorsCreated++;\n        this.stats.totalOscillators++;\n        this.stats.peakOscillatorCount = Math.max(this.stats.peakOscillatorCount, this.stats.totalOscillators);\n        \n        this.oscillatorBank.get(type).set(freq, oscData);\n        return oscData;\n    }\n    \n    // New method to clean up unused oscillators\n    cleanupUnusedOscillators() {\n        const now = Date.now();\n        const unusedThreshold = 30000; // 30 seconds\n        let cleanupCount = 0;\n        let total = 0;\n        \n        // Iterate through all oscillator types\n        for (const [type, freqMap] of this.oscillatorBank.entries()) {\n            total += freqMap.size;\n            \n            // Check each frequency\n            for (const [freq, oscData] of freqMap.entries()) {\n                // Skip oscillators that are in use or recently used\n                if (oscData.activeNeurons.size > 0 || now - oscData.lastUsed < unusedThreshold) {\n                    continue;\n                }\n                \n                // Dispose unused oscillator\n                if (oscData.oscillator) {\n                    try {\n                        oscData.oscillator.stop();\n                        oscData.oscillator.dispose();\n                    } catch (e) {\n                        console.warn(`Error disposing oscillator: ${e}`);\n                    }\n                }\n                \n                if (oscData.gain) {\n                    try {\n                        oscData.gain.dispose();\n                    } catch (e) {\n                        console.warn(`Error disposing gain: ${e}`);\n                    }\n                }\n                \n                // Remove from map\n                freqMap.delete(freq);\n                cleanupCount++;\n                \n                // Update stats\n                this.stats.oscillatorsDisposed++;\n                this.stats.totalOscillators--;\n            }\n        }\n        \n        if (cleanupCount > 0) {\n            console.log(`Cleaned up ${cleanupCount} unused oscillators, keeping ${total - cleanupCount}/${total}`);\n        }\n    }\n    \n    // Create a simplified stereo panner with ILD and ITD effects (no high-shelf filters)\n    createSimplePanner(pan = 0) {\n        // Create channel splitting/merging for stereo processing\n        const splitter = new Tone.Split(2);\n        const merger = new Tone.Merge();\n        \n        // Create gain nodes for left and right channels (for ILD - Interaural Level Difference)\n        const leftGain = new Tone.Gain(1);\n        const rightGain = new Tone.Gain(1);\n        \n        // Create delay nodes for left and right channels (for ITD - Interaural Time Difference)\n        const leftDelay = new Tone.Delay(0);\n        const rightDelay = new Tone.Delay(0);\n        \n        // Create input/output for chaining\n        const input = new Tone.Gain(1);\n        const output = new Tone.Gain(1);\n        \n        // Connect the processing chain\n        input.connect(splitter);\n        \n        // Left channel processing chain (simplified)\n        splitter.connect(leftDelay, 0);\n        leftDelay.connect(leftGain);\n        leftGain.connect(merger, 0, 0);  // Connect to left output\n        \n        // Right channel processing chain (simplified)\n        splitter.connect(rightDelay, 1);\n        rightDelay.connect(rightGain);\n        rightGain.connect(merger, 0, 1);  // Connect to right output\n        \n        // Connect to output\n        merger.connect(output);\n        \n        // Store all nodes for cleanup\n        const allNodes = [\n            input, output, splitter, merger,\n            leftGain, rightGain, leftDelay, rightDelay\n        ];\n        \n        // Set initial position\n        const updatePanPosition = (panValue) => {\n            // Clamp to valid range (-1 to 1)\n            const pan = Math.max(-1, Math.min(1, panValue));\n            \n            // Convert pan (-1 to 1) to azimuth angle in radians\n            // pan -1 = 90° left, pan 0 = center, pan 1 = 90° right\n            const azimuth = pan * (Math.PI / 2);  // Scale to ±90° (±π/2 radians)\n            \n            // Set gain values with more conservative range (0.6-1.0) to prevent clipping\n            // These values ensure the overall volume doesn't increase significantly\n            leftGain.gain.value = 0.6 + 0.4 * Math.max(0, -pan);   // Louder when pan is negative (left)\n            rightGain.gain.value = 0.6 + 0.4 * Math.max(0, pan);   // Louder when pan is positive (right)\n            \n            // Apply subtle delay cues (ITD - Interaural Time Difference)\n            // Using a smaller max delay to prevent phasing issues\n            const maxDelay = 0.0004;  // 0.4ms maximum delay\n            \n            // Set delay times based on pan position\n            leftDelay.delayTime.value = Math.max(0, maxDelay * pan);      // Delay left when pan is positive (right)\n            rightDelay.delayTime.value = Math.max(0, -maxDelay * pan);    // Delay right when pan is negative (left)\n            \n            console.log(`Simplified panner set to ${pan.toFixed(2)}`);\n        };\n        \n        // Set initial position\n        updatePanPosition(pan);\n        \n        return {\n            input,\n            output,\n            // Method to update panning position\n            updatePosition: (newPan) => {\n                updatePanPosition(newPan);\n            },\n            // Method for cleanup\n            dispose: () => {\n                allNodes.forEach(node => {\n                    if (node && typeof node.dispose === 'function') {\n                        node.dispose();\n                    }\n                });\n            },\n            allNodes\n        };\n    }\n    \n    // Calculate spatial position for a neuron based on its 3D position\n    calculateSpatialPosition(neuronId) {\n        // Default to center if neuron doesn't exist\n        if (!window.circles) {\n            return 0; // Center (pan = 0)\n        }\n        \n        // Find the neuron in the circles array\n        const neuron = Array.from(window.circles).find(circle => \n            circle && circle.neuron && circle.neuron.id === neuronId\n        );\n        \n        if (!neuron) {\n            return 0; // Center if neuron not found\n        }\n        \n        // Get the neuron's position\n        const neuronPos = neuron.position;\n        \n        // Get the camera position\n        const cameraPos = this.camera.position;\n        \n        // Calculate the position relative to camera on X axis (left/right)\n        // This creates a direct mapping from spatial position to stereo field\n        const relativeX = neuronPos.x - cameraPos.x;\n        \n        // Normalize to -1 to 1 range with a scaling factor to prevent extreme panning\n        // Scale by 0.5 to make the panning more moderate (adjust as needed)\n        const scaleFactor = 0.8;\n        const normalizedPan = Math.max(-1, Math.min(1, relativeX * scaleFactor));\n        \n        console.log(`Neuron ${neuronId} spatial position: pan = ${normalizedPan.toFixed(2)}`);\n        return normalizedPan;\n    }\n    \n    // Enable or disable spatial audio\n    setSpatialAudio(enabled) {\n        // Skip if status isn't changing\n        if (this.spatialAudioEnabled === enabled) return;\n        \n        console.log(`${enabled ? 'Enabling' : 'Disabling'} spatial audio`);\n        this.spatialAudioEnabled = enabled;\n        \n        if (enabled) {\n            // Create spatial panners for all existing audio buses if needed\n            Object.values(this.buses).forEach(bus => {\n                // Skip if this bus already has a panner\n                if (bus.spatialPanner) return;\n                \n                // Create simple panner with center position\n                bus.spatialPanner = this.createSimplePanner(0);\n                \n                // Store for cleanup\n                this.spatialAudioNodes.set(bus.id, bus.spatialPanner);\n                \n                // Insert panner in the signal chain\n                if (!bus.gain) {\n                    console.warn(`No gain node for bus ${bus.id}, skipping panner setup`);\n                    return;\n                }\n                \n                try {\n                    // Disconnect gain from the previous destination\n                    const originalDestination = bus.originalDestination || this.finalMixer || Tone.Destination;\n                    bus.gain.disconnect();\n                    \n                    // Connect through the panner\n                    bus.gain.connect(bus.spatialPanner.input);\n                    bus.spatialPanner.output.connect(originalDestination);\n                    \n                    // Store original destination for later reconnection\n                    bus.originalDestination = originalDestination;\n                    \n                    console.log(`Successfully connected spatial panner for bus ${bus.id}`);\n                } catch (error) {\n                    console.error(`Error setting up panner for bus ${bus.id}:`, error);\n                }\n            });\n            \n            // Force update any currently playing neurons\n            if (window.circles) {\n                window.circles.forEach(circle => {\n                    if (circle && circle.neuron) {\n                        const neuronId = circle.neuron.id;\n                        this.updateNeuronSpatialPosition(neuronId);\n                    }\n                });\n            }\n        } else {\n            // Disconnect panners and restore original connections\n            Object.values(this.buses).forEach(bus => {\n                if (bus.spatialPanner) {\n                    try {\n                        // Disconnect from the signal chain\n                        bus.gain.disconnect();\n                        \n                        // Reconnect directly to original destination\n                        const originalDestination = bus.originalDestination || this.finalMixer || Tone.Destination;\n                        bus.gain.connect(originalDestination);\n                        \n                        // Dispose panner\n                        bus.spatialPanner.dispose();\n                        bus.spatialPanner = null;\n                    } catch (error) {\n                        console.error(`Error disconnecting panner for bus ${bus.id}:`, error);\n                    }\n                }\n            });\n            \n            // Cleanup all stored nodes\n            this.spatialAudioNodes.forEach(panner => {\n                if (panner && typeof panner.dispose === 'function') {\n                    panner.dispose();\n                }\n            });\n            this.spatialAudioNodes.clear();\n            this.spatialAudioPanners.clear();\n        }\n    }\n    \n    // Update spatial position for a neuron's audio\n    updateNeuronSpatialPosition(neuronId) {\n        // Skip if spatial audio is disabled\n        if (!this.spatialAudioEnabled) return;\n        \n        // Calculate the spatial position (pan value)\n        const pan = this.calculateSpatialPosition(neuronId);\n        \n        // Get the bus for this neuron\n        const busId = this.neuronBusAssignments.get(neuronId);\n        if (!busId || !this.buses[busId] || !this.buses[busId].spatialPanner) {\n            return;\n        }\n        \n        try {\n            // Update the panner position\n            this.buses[busId].spatialPanner.updatePosition(pan);\n            \n            // Store this position for future reference\n            this.spatialAudioPanners.set(neuronId, pan);\n        } catch (error) {\n            console.error(`Error updating spatial position for neuron ${neuronId}:`, error);\n        }\n    }\n\n    // New method to log performance statistics\n    logPerformanceStats() {\n        console.log(\n            `%c[OSCILLATOR STATS] Total: ${this.stats.totalOscillators} | ` +\n            `Active: ${this.stats.activeOscillators} | ` + \n            `Created: ${this.stats.oscillatorsCreated} | ` +\n            `Disposed: ${this.stats.oscillatorsDisposed} | ` +\n            `Peak: ${this.stats.peakOscillatorCount}`,\n            \"color: #00cc00; background: #111; padding: 3px; border-radius: 2px;\"\n        );\n        \n        // Calculate memory savings\n        const originalApproach = this.oscillatorTypes.length * 30; // Approx frequencies in original approach\n        const currentCount = this.stats.totalOscillators;\n        const savedOscillators = originalApproach - currentCount;\n        const savingsPercent = Math.round((savedOscillators / originalApproach) * 100);\n        \n        if (savingsPercent > 0) {\n            console.log(\n                `%c[OPTIMIZATION] Using ${currentCount} oscillators instead of ~${originalApproach} (${savingsPercent}% reduction)`,\n                \"color: #00ffaa; background: #111; padding: 3px; border-radius: 2px;\"\n            );\n        }\n    }\n    \n    // Add method to monitor active oscillator creation/usage in realtime\n    startPerformanceMonitoring(intervalMs = 30000) {\n        if (this._perfMonitoringInterval) {\n            clearInterval(this._perfMonitoringInterval);\n        }\n        \n        this._perfMonitoringInterval = setInterval(() => {\n            this.logPerformanceStats();\n        }, intervalMs);\n        \n        console.log(`%c[OSCILLATOR BANK] Performance monitoring started (${intervalMs/1000}s interval)`, \"color: #00cc00;\");\n        return this;\n    }\n    \n    // Method to get oscillator usage statistics for UI display\n    getOscillatorStats() {\n        return { ...this.stats }; // Return a copy of stats\n    }\n    \n    // Modified method to get closest frequency with quantization\n    getClosestFrequency(targetFreq) {\n        // Implement frequency quantization - round to nearest semitone\n        // This reduces the total number of oscillators needed\n        const semitone = Math.round(12 * Math.log2(targetFreq/440)) + 49; // A4 = 49\n        const quantizedFreq = 440 * Math.pow(2, (semitone - 49) / 12);\n        \n        return quantizedFreq;\n    }\n    \n    // Ensures audio context is running\n    ensureAudioContext() {\n        // Start Tone.js context if needed\n        if (Tone.context.state !== \"running\") {\n            Tone.start().then(() => {\n                console.log(\"Audio context started successfully\");\n                Tone.Transport.start();\n            }).catch(e => {\n                console.warn(\"Error starting audio context:\", e);\n            });\n        }\n    }\n    \n    /**\n     * Initialize the optimized audio bus architecture\n     * Creates a multi-bus system with different effects chains for different neuron groups\n     */\n    initializeAudioBuses() {\n        console.log(\"Initializing audio buses with compression and limiter for improved sound quality\");\n        \n        try {\n            // Create master limiter (final stage before output)\n            this.masterLimiter = new Tone.Limiter(-2.0); // Changed from -0.5 to -2.0 for more headroom\n            this.masterLimiter.toDestination();\n            \n            // Create master compressor that feeds into the limiter\n            this.masterCompressor = new Tone.Compressor({\n                threshold: -22, // Changed from -28 to -22 for less aggressive compression\n                ratio: 4,       // Changed from 6 to 4 for more natural compression\n                attack: 0.005,  // Slightly increased from 0.003 to 0.005\n                release: 0.15,  // Increased from 0.1 to 0.15 to prevent pumping with bass\n                knee: 12        // Kept the same knee value for smooth compression\n            });\n            this.masterCompressor.connect(this.masterLimiter);\n            \n            // Create final mixer that feeds into the master compressor\n            this.finalMixer = new Tone.Gain(0.92); // Reduced from 1.0 to 0.92 (slight overall reduction)\n            this.finalMixer.connect(this.masterCompressor);\n            \n            // Create splitter to separate signals\n            this.splitter = new Tone.Split(2);\n            \n            // Connect to finalMixer\n            this.splitter.connect(this.finalMixer, 0);\n            \n            // Create hi-hat path components\n            this.hiHatFilter = new Tone.Filter({\n                type: \"highpass\",\n                frequency: 3800, // Increased from 2800 to 3800 for better separation from bass\n                rolloff: -24,\n                Q: 0.7 // Reduced from 0.8 to 0.7 for smoother response\n            });\n            \n            this.hiHatCompressor = new Tone.Compressor({\n                threshold: -20, // Changed from -22 to -20 (less aggressive)\n                ratio: 4,       // Changed from 6 to 4 (less aggressive)\n                attack: 0.001,  // Kept ultra-fast attack for transients\n                release: 0.08,  // Increased from 0.05 to 0.08\n                knee: 8         // Increased from 6 to 8 for smoother compression\n            });\n            \n            // Connect hi-hat parallel path with blending\n            this.splitter.connect(this.hiHatFilter, 1);\n            \n            // Create a splitter for hi-hat path to create parallel processing\n            this.hiHatSplitter = new Tone.Split(2);\n            this.hiHatFilter.connect(this.hiHatSplitter);\n            \n            // Mix control to blend compressed hi-hat with main signal\n            this.hiHatWet = new Tone.Gain(0.5); // Changed from 0.6 to 0.5 (50% wet)\n            this.hiHatDry = new Tone.Gain(0.5); // Changed from 0.4 to 0.5 (50% dry)\n            \n            // Process one path through the compressor (wet)\n            this.hiHatSplitter.connect(this.hiHatCompressor, 0);\n            this.hiHatCompressor.connect(this.hiHatWet);\n            this.hiHatWet.connect(this.finalMixer);\n            \n            // Send the other path directly (dry)\n            this.hiHatSplitter.connect(this.hiHatDry, 1);\n            this.hiHatDry.connect(this.finalMixer);\n            \n            // Define helper function to detect hi-hat-like sounds\n            this.isHiHatSound = (params) => {\n                return params && \n                      (params.filterType === \"highpass\" && params.filterFrequency > 2000) ||\n                      (params.name && params.name.toLowerCase().includes(\"hi-hat\")) ||\n                      (params.oscillatorType === \"triangle\" && params.decay < 0.15 && params.sustain === 0) ||\n                      (params.oscillatorType === \"noise\");\n            };\n            \n            // Now create the buses for regular audio routing\n            this.buses = {};\n\n            // Create buses for different frequency ranges and types - use try/catch for each\n            try {\n            this.buses.low = this.createAudioBus('low', {\n                eq: {\n                    low: 0,\n                    mid: -3,\n                    high: -6\n                },\n                reverb: {\n                    decay: 2.0,\n                    wet: 0.15\n                },\n                delay: {\n                    delayTime: 0.25,\n                    feedback: 0.2,\n                    wet: 0.1\n                }\n            });\n            } catch (e) {\n                console.error(`Failed to create low bus:`, e);\n                // Create minimal fallback bus\n                this.buses.low = {\n                    id: 'low',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n\n            try {\n            this.buses.mid = this.createAudioBus('mid', {\n                eq: {\n                    low: -3,\n                    mid: 0,\n                    high: -3\n                },\n                reverb: {\n                    decay: 1.5,\n                    wet: 0.12\n                },\n                delay: {\n                    delayTime: 0.2,\n                    feedback: 0.15,\n                    wet: 0.08\n                }\n            });\n            } catch (e) {\n                console.error(`Failed to create mid bus:`, e);\n                // Create minimal fallback bus\n                this.buses.mid = {\n                    id: 'mid',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n\n            try {\n            this.buses.high = this.createAudioBus('high', {\n                eq: {\n                    low: -6,\n                    mid: -3,\n                    high: 0\n                },\n                reverb: {\n                    decay: 1.0,\n                    wet: 0.1\n                },\n                delay: {\n                    delayTime: 0.15,\n                    feedback: 0.1,\n                    wet: 0.06\n                }\n            });\n            } catch (e) {\n                console.error(`Failed to create high bus:`, e);\n                // Create minimal fallback bus\n                this.buses.high = {\n                    id: 'high',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n\n            try {\n            this.buses.highPerc = this.createAudioBus('highPerc', {\n                eq: {\n                    low: -2,\n                    mid: 0,\n                    high: +2\n                },\n                reverb: {\n                    decay: 1.2,\n                    wet: 0.18\n                },\n                delay: {\n                    delayTime: 0.18,\n                    feedback: 0.25,\n                    wet: 0.15\n                }\n            });\n            } catch (e) {\n                console.error(`Failed to create highPerc bus:`, e);\n                // Create minimal fallback bus\n                this.buses.highPerc = {\n                    id: 'highPerc',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n            \n            // Create specialized bus for hi-hat sounds\n            try {\n            this.buses.hiHat = this.createAudioBus('hiHat', {\n                eq: {\n                    low: -12, // Changed from -10 to -12 (stronger low cut for hi-hats)\n                    mid: -2,  // Changed from -3 to -2 (slightly less mid reduction)\n                    high: +2  // Changed from +3 to +2 (slightly less high boosting)\n                },\n                filterType: 'highpass',\n                filterFrequency: 1200, // Changed from 800 to 1200 for cleaner separation from bass\n                reverb: {\n                    decay: 0.8,\n                    wet: 0.1  // Reduced from 0.12 to 0.1 (less reverb to avoid buildup)\n                },\n                delay: {\n                    delayTime: 0.08,\n                    feedback: 0.05,\n                    wet: 0.04 // Reduced from 0.06 to 0.04 (less delay to avoid buildup)\n                },\n                useParallelCompression: true\n                });\n            } catch (e) {\n                console.error(`Failed to create hiHat bus:`, e);\n                // Create minimal fallback bus\n                this.buses.hiHat = {\n                    id: 'hiHat',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n            \n            // Create specialized bus for organ and sustained sounds\n            try {\n                this.buses.organ = this.createAudioBus('organ', {\n                    eq: {\n                        low: -2,     // Slightly reduce low end to prevent muddiness\n                        mid: +2,     // Boost mids for pipe organ character\n                        high: +1     // Slight high boost for harmonics\n                    },\n                    filterType: 'lowpass',\n                    filterFrequency: 3500, // Let harmonics through but control harshness\n                    filterQ: 0.7,    // Low resonance for smooth sound\n                    reverb: {\n                        decay: 3.0,  // Long decay for church-like space\n                        wet: 0.35    // More reverb for realistic church organ sound\n                    },\n                    delay: {\n                        delayTime: 0.15,\n                        feedback: 0.1,\n                        wet: 0.05    // Minimal delay for clarity\n                    },\n                    compression: {   // Special compression settings for organ\n                        threshold: -20,\n                        ratio: 2.5,\n                        attack: 0.03,\n                        release: 0.3,\n                        knee: 10\n                    },\n                    useOrganism: true // Flag to use specialized organ processing\n                });\n            } catch (e) {\n                console.error(`Failed to create organ bus:`, e);\n                // Create minimal fallback bus\n                this.buses.organ = {\n                    id: 'organ',\n                    gain: new Tone.Gain(1).toDestination()\n                };\n            }\n            \n            // Make sure all buses have at least the minimal required components\n            Object.keys(this.buses).forEach(busId => {\n                const bus = this.buses[busId];\n                \n                // Add minimal components if missing\n                if (!bus.filter) {\n                    bus.filter = new Tone.Filter(1000, \"allpass\").connect(bus.gain || Tone.Destination);\n                }\n                \n                if (!bus.eq) {\n                    bus.eq = new Tone.EQ3(0, 0, 0).connect(bus.filter);\n                }\n            });\n        \n        // Create synths for each bus\n        this.synths = {};\n        this.createSynthsForBuses();\n        } catch (error) {\n            console.error(`Error initializing audio buses:`, error);\n            \n            // Create at least one minimal working bus as fallback\n            if (!this.buses || Object.keys(this.buses).length === 0) {\n                this.buses = {\n                    fallback: {\n                        id: 'fallback',\n                        gain: new Tone.Gain(1).toDestination(),\n                        filter: new Tone.Filter(1000, \"allpass\").toDestination(),\n                        eq: new Tone.EQ3(0, 0, 0).toDestination()\n                    }\n                };\n                \n                // Connect minimal fallback chain\n                try {\n                    this.buses.fallback.eq.connect(this.buses.fallback.filter);\n                    this.buses.fallback.filter.connect(this.buses.fallback.gain);\n                } catch (e) {\n                    console.error(\"Failed to connect fallback bus:\", e);\n                }\n                \n                console.warn(\"Created emergency fallback audio bus\");\n            }\n            \n            // Create at least one synth\n            this.synths = {};\n            this.createSynthsForBuses();\n        }\n    }\n    \n    /**\n     * Create an audio processing bus with specific characteristics\n     * @param {string} id - Bus identifier\n     * @param {object} options - Bus configuration options\n     * @returns {object} Bus with effects chain\n     */\n    createAudioBus(id, options = {}) {\n        console.log(`Creating audio bus: ${id} with options:`, options);\n        \n        // Initialize bus components with error handling\n        try {\n        const bus = {\n            id: id,\n                eq: new Tone.EQ3(\n                    options.eq?.low || 0,\n                    options.eq?.mid || 0,\n                    options.eq?.high || 0\n                ),\n            filter: new Tone.Filter({\n                    type: options.filterType || \"allpass\",\n                    frequency: options.filterFrequency || 1000,\n                    rolloff: -12,\n                    Q: options.filterQ || 1\n                }),\n                gain: new Tone.Gain(1)\n            };\n            \n            // Create reverb with pre-generated impulse\n            bus.reverb = new Tone.Reverb({\n                decay: options.reverb?.decay || 1.5,\n                wet: options.reverb?.wet || 0.2,\n                preDelay: 0.01\n            });\n            \n            // Use immediate value for wet parameter instead of the object setter\n            if (bus.reverb && bus.reverb.wet) {\n                bus.reverb.wet.value = options.reverb?.wet || 0.2;\n            }\n            \n            try {\n                // Generate impulse response but don't wait\n                bus.reverb.generate();\n            } catch (err) {\n                console.warn(`Error generating reverb impulse for bus ${id}:`, err);\n            }\n            \n            // Create delay with safer connection\n            bus.delay = new Tone.FeedbackDelay({\n                delayTime: options.delay?.delayTime || 0.2,\n                feedback: options.delay?.feedback || 0.2,\n                wet: options.delay?.wet || 0.15,\n                maxDelay: 1\n            });\n            \n            // Set wet value directly to avoid connection issues\n            if (bus.delay && bus.delay.wet) {\n                bus.delay.wet.value = options.delay?.wet || 0.15;\n            }\n            \n            // Add compression for certain buses (like organ)\n            if (options.compression) {\n                bus.compressor = new Tone.Compressor({\n                    threshold: options.compression.threshold || -20,\n                    ratio: options.compression.ratio || 3,\n                    attack: options.compression.attack || 0.02,\n                    release: options.compression.release || 0.3,\n                    knee: options.compression.knee || 10\n                });\n                console.log(`Added compressor to bus ${id}`);\n            }\n            \n            // Add soft saturation for warmth (especially for organ sounds)\n            if (options.useOrganism) {\n                bus.saturation = new Tone.Distortion({\n                    distortion: 0.08, // Very subtle distortion for warmth\n                    wet: 0.3         // Blend with clean signal\n                });\n                \n                // Add chorusing for organ sound movement\n                bus.chorus = new Tone.Chorus({\n                    frequency: 0.6,  // Slow movement\n                    delayTime: 4,    // Slight depth\n                    depth: 0.3,      // Moderate depth\n                    type: \"sine\",\n                    spread: 40,      // Stereo spread\n                    wet: 0.15        // Subtle effect\n                });\n                \n                // Start the chorus LFO (safe even without audio running)\n                try {\n                    bus.chorus.start();\n                } catch (err) {\n                    console.warn(`Error starting chorus for bus ${id}:`, err);\n                }\n                \n                console.log(`Added organ-specific processing to bus ${id}`);\n            }\n            \n            // Connect effects chain with verification at each step and error handling for each connection\n            try {\n                if (options.useOrganism && bus.saturation && bus.chorus) {\n                    // Specialized organ chain with safer connections\n                    // filter -> saturation -> eq -> compressor -> chorus -> delay -> reverb -> gain\n                    try { bus.filter.connect(bus.saturation); } catch (e) { console.warn(\"Connection error 1:\", e); }\n                    \n                    try { bus.saturation.connect(bus.eq); } catch (e) { console.warn(\"Connection error 2:\", e); }\n                    \n                    if (bus.compressor) {\n                        try { bus.eq.connect(bus.compressor); } catch (e) { console.warn(\"Connection error 3:\", e); }\n                        try { bus.compressor.connect(bus.chorus); } catch (e) { console.warn(\"Connection error 4:\", e); }\n                    } else {\n                        try { bus.eq.connect(bus.chorus); } catch (e) { console.warn(\"Connection error 5:\", e); }\n                    }\n                    \n                    try { bus.chorus.connect(bus.delay); } catch (e) { console.warn(\"Connection error 6:\", e); }\n                    \n                    console.log(`Connected specialized organ chain for bus ${id}`);\n                } else {\n                    // Standard chain with safer connections\n                    // filter -> eq -> compressor -> delay -> reverb -> gain\n                    try { bus.filter.connect(bus.eq); } catch (e) { console.warn(\"Connection error 7:\", e); }\n                    \n                    if (bus.compressor) {\n                        try { bus.eq.connect(bus.compressor); } catch (e) { console.warn(\"Connection error 8:\", e); }\n                        try { bus.compressor.connect(bus.delay); } catch (e) { console.warn(\"Connection error 9:\", e); }\n                    } else {\n                        try { bus.eq.connect(bus.delay); } catch (e) { console.warn(\"Connection error 10:\", e); }\n                    }\n                    \n                    console.log(`Connected standard chain for bus ${id}`);\n                }\n                \n                // Connect final stages of the chain with individual error handling\n                try { \n        bus.delay.connect(bus.reverb);\n            console.log(`Connected delay to reverb for bus ${id}`);\n                } catch (e) { \n                    console.warn(\"Error connecting delay to reverb:\", e);\n                    // Try direct connection to gain on failure\n                    try { bus.delay.connect(bus.gain); } catch (err) { \n                        console.warn(\"Fallback connection failed:\", err);\n                    }\n                }\n                \n                try { \n        bus.reverb.connect(bus.gain);\n            console.log(`Connected reverb to gain for bus ${id}`);\n                } catch (e) { \n                    console.warn(\"Error connecting reverb to gain:\", e); \n                }\n            \n            // Direct connection to output chain\n            if (options.useParallelCompression) {\n                console.log(`Using parallel compression for ${id} bus`);\n                if (!this.hiHatFilter) {\n                        console.warn(`hiHatFilter not available for bus ${id}, connecting to main output`);\n                        try { bus.gain.connect(this.finalMixer || Tone.Destination); } catch (e) { \n                            console.warn(\"Error connecting to finalMixer:\", e); \n                            // Last resort fallback\n                            try { bus.gain.toDestination(); } catch (err) { console.error(\"Emergency connection failed:\", err); }\n                        }\n                } else {\n                        try { \n                    bus.gain.connect(this.hiHatFilter);\n                    console.log(`Connected ${id} bus to hiHatFilter for parallel processing`);\n                        } catch (e) { \n                            console.warn(\"Error connecting to hiHatFilter:\", e);\n                            // Fallback to main mixer on error \n                            try { bus.gain.connect(this.finalMixer || Tone.Destination); } catch (err) { \n                                console.warn(\"Fallback connection failed:\", err); \n                                // Last resort\n                                try { bus.gain.toDestination(); } catch (lastErr) { console.error(\"Emergency connection failed:\", lastErr); }\n                            }\n                        }\n                }\n            } else {\n                // Safer direct connection to main mixer\n                console.log(`Using standard routing for ${id} bus`);\n                    try {\n                        bus.gain.connect(this.finalMixer || Tone.Destination);\n                console.log(`Connected ${id} bus gain directly to finalMixer`);\n                    } catch (e) {\n                        console.warn(\"Error connecting to finalMixer:\", e);\n                        // Last resort fallback\n                        try { \n                            bus.gain.toDestination(); \n                            console.log(\"Emergency connection to destination successful\");\n                        } catch (err) { \n                            console.error(\"Emergency connection failed:\", err);\n                        }\n                    }\n                }\n            } catch (connectionError) {\n                console.error(`Error in connecting audio nodes for bus ${id}:`, connectionError);\n                \n                // Emergency direct connections to ensure something works\n                try {\n                    bus.filter.toDestination();\n                    console.log(\"Emergency direct connection established\");\n                } catch (e) {\n                    console.error(\"Failed all connection attempts:\", e);\n                }\n            }\n        \n        return bus;\n        } catch (error) {\n            console.error(`Error creating audio bus ${id}:`, error);\n            \n            // Fallback minimal bus to avoid crashes\n            const fallbackBus = {\n                id: id,\n                eq: new Tone.EQ3(0, 0, 0),\n                gain: new Tone.Gain(1)\n            };\n            \n            // Direct connection to output\n            try {\n            fallbackBus.eq.connect(fallbackBus.gain);\n            fallbackBus.gain.connect(this.finalMixer || Tone.Destination);\n            } catch (e) {\n                console.error(\"Failed to connect fallback bus:\", e);\n                try {\n                    fallbackBus.eq.toDestination();\n                } catch (err) {\n                    console.error(\"Failed all fallback connection attempts:\", err);\n                }\n            }\n            \n            console.log(`Created fallback bus for ${id} due to error`);\n            return fallbackBus;\n        }\n    }\n    \n    /**\n     * Create synths for each audio bus\n     */\n    createSynthsForBuses() {\n        // Create synths for each bus\n        console.log(\"Creating synths for audio buses with error handling...\");\n        \n        try {\n            this.synths = {};\n            \n            // Make sure we have at least one fallback synth\n            const fallbackOutputNode = this.finalMixer || Tone.Destination;\n            this.synths['defaultTone'] = new Tone.PolySynth(Tone.Synth, {\n                maxPolyphony: 8,\n                oscillator: {\n                    type: \"triangle\"\n                },\n                envelope: {\n                    attack: 0.002,\n                    decay: 0.3,\n                    sustain: 0.2,\n                    release: 0.8\n                },\n                volume: this.volume || -6\n            }).toDestination();\n            \n            // Process each bus\n        Object.keys(this.buses).forEach(busId => {\n                try {\n            const bus = this.buses[busId];\n                    \n                    // Skip if bus is invalid\n                    if (!bus || !bus.id) {\n                        console.warn(`Skipping invalid bus: ${busId}`);\n                        return;\n                    }\n                    \n                    // Determine destination node for the synth\n                    let destinationNode;\n                    if (bus.filter && typeof bus.filter.input !== 'undefined') {\n                        destinationNode = bus.filter;\n                    } else if (bus.eq && typeof bus.eq.input !== 'undefined') {\n                        destinationNode = bus.eq;\n                    } else if (bus.gain && typeof bus.gain.input !== 'undefined') {\n                        destinationNode = bus.gain;\n                    } else {\n                        destinationNode = fallbackOutputNode;\n                        console.warn(`Using fallback output for ${busId} synths`);\n                    }\n                    \n                    const isHighQuality = bus.highQuality || false;\n            const polyphony = isHighQuality ? 16 : 8; // Increased polyphony for all synths (was 8:4)\n                    \n                    console.log(`Creating synths for bus ${busId} with destination:`, destinationNode);\n            \n            // Use different synth configurations based on bus type\n                    if (busId === 'organ') {\n                        try {\n                            // Create specialized organ synth with layered harmonics\n                            this.synths[busId + \"Tone\"] = new Tone.PolySynth(Tone.Synth, {\n                                maxPolyphony: 24, // Increased from 12 to 24 to prevent \"Max polyphony exceeded\" errors\n                                oscillator: {\n                                    type: \"sine\" // Pure sine for fundamental tone\n                                },\n                                envelope: {\n                                    attack: 0.1,     // Slow attack for pipe organ swell\n                                    decay: 0.4,      // Moderate decay\n                                    sustain: 0.8,    // High sustain for organ-like tone\n                                    release: 2.5,    // Long release for natural decay\n                                    attackCurve: \"linear\" // Linear attack for more natural swell\n                                },\n                                volume: this.volume - 4 // Lower volume to allow for layering\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Tone\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Tone\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Tone\"].toDestination();\n                            }\n                            \n                            // Create second organ synth for harmonics (octave up)\n                            this.synths[busId + \"OctaveUp\"] = new Tone.PolySynth(Tone.Synth, {\n                                maxPolyphony: 24, // Increased from 12 to 24 to prevent \"Max polyphony exceeded\" errors\n                                oscillator: {\n                                    type: \"sine\"\n                                },\n                                envelope: {\n                                    attack: 0.15,    // Slightly slower attack\n                                    decay: 0.3,\n                                    sustain: 0.7,    // Slightly lower sustain\n                                    release: 2.2,    \n                                    attackCurve: \"linear\"\n                                },\n                                volume: this.volume - 10 // Much quieter for proper harmonic mix\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"OctaveUp\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"OctaveUp\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"OctaveUp\"].toDestination();\n                            }\n                            \n                            // Create third organ synth for sub-harmonic (fifth)\n                            this.synths[busId + \"Fifth\"] = new Tone.PolySynth(Tone.Synth, {\n                                maxPolyphony: 24, // Increased from 12 to 24 to prevent \"Max polyphony exceeded\" errors\n                                oscillator: {\n                                    type: \"sine\"\n                                },\n                                envelope: {\n                                    attack: 0.12,\n                                    decay: 0.35,\n                                    sustain: 0.75,\n                                    release: 2.3,\n                                    attackCurve: \"linear\"\n                                },\n                                volume: this.volume - 12 // Even quieter\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Fifth\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Fifth\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Fifth\"].toDestination();\n                            }\n                            \n                            // Create subtle noise component for air/breath sound\n                            this.synths[busId + \"Air\"] = new Tone.Noise({\n                                type: \"pink\",\n                                volume: this.volume - 24 // Very quiet, just for air movement\n                            });\n                            \n                            // Don't connect the air noise yet - it gets connected dynamically when used\n                            try {\n                                this.synths[busId + \"Air\"].start();\n                            } catch (e) {\n                                console.warn(`Failed to start ${busId + \"Air\"} noise:`, e);\n                            }\n                            \n                            console.log(`Created specialized organ synths for ${busId} bus`);\n                        } catch (e) {\n                            console.error(`Failed to create organ synths for ${busId}:`, e);\n                        }\n                    } else if (busId.includes(\"Perc\")) {\n                        try {\n                // Percussion synths\n                this.synths[busId + \"Membrane\"] = new Tone.MembraneSynth({\n                    pitchDecay: 0.05,\n                    octaves: 2,\n                    envelope: {\n                        attack: 0.002,\n                        decay: 0.3,\n                        sustain: 0.2,\n                        release: 0.8,\n                        attackCurve: \"exponential\"\n                    },\n                    volume: this.volume\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Membrane\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Membrane\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Membrane\"].toDestination();\n                            }\n                \n                this.synths[busId + \"Tone\"] = new Tone.PolySynth(Tone.Synth, {\n                    maxPolyphony: polyphony,\n                    oscillator: {\n                        type: \"sine\",\n                        partials: [1, 0.3, 0.1]\n                    },\n                    envelope: {\n                        attack: 0.002,\n                        decay: 0.3,\n                        sustain: 0.2,\n                        release: 0.8\n                    },\n                    volume: this.volume - 5\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Tone\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Tone\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Tone\"].toDestination();\n                            }\n                        } catch (e) {\n                            console.error(`Failed to create percussion synths for ${busId}:`, e);\n                        }\n            } else {\n                        try {\n                // Tonal synths\n                this.synths[busId + \"Tone\"] = new Tone.PolySynth(Tone.Synth, {\n                    maxPolyphony: polyphony,\n                    oscillator: {\n                        type: \"triangle\",\n                        count: isHighQuality ? 3 : 2,\n                        spread: isHighQuality ? 10 : 5\n                    },\n                    envelope: {\n                        attack: 0.002,\n                        decay: 0.3,\n                        sustain: 0.2,\n                        release: 0.8\n                    },\n                    volume: this.volume\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Tone\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Tone\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Tone\"].toDestination();\n                            }\n                \n                this.synths[busId + \"Sustain\"] = new Tone.PolySynth(Tone.Synth, {\n                    maxPolyphony: Math.max(4, Math.floor(polyphony / 2)), // Increased from 2 to 4 minimum\n                    oscillator: {\n                        type: \"sine\",\n                        partials: [1, 0.5, 0.2]\n                    },\n                    envelope: {\n                        attack: 0.4,\n                        decay: 0.8,\n                        sustain: 0.8,\n                        release: 2.0\n                    },\n                    volume: this.volume - 8\n                            });\n                            \n                            // Connect to destination node safely\n                            try {\n                                this.synths[busId + \"Sustain\"].connect(destinationNode);\n                            } catch (e) {\n                                console.warn(`Failed to connect ${busId + \"Sustain\"} to bus, using fallback:`, e);\n                                this.synths[busId + \"Sustain\"].toDestination();\n                            }\n                        } catch (e) {\n                            console.error(`Failed to create tonal synths for ${busId}:`, e);\n                        }\n                    }\n                } catch (busError) {\n                    console.error(`Error processing bus ${busId}:`, busError);\n                }\n            });\n            \n            console.log(`Created synths for ${Object.keys(this.buses).length} buses`);\n        } catch (error) {\n            console.error(`Error initializing synths:`, error);\n            \n            // Create emergency fallback synth if something goes wrong\n            if (!this.synths || Object.keys(this.synths).length === 0) {\n                console.warn(\"Creating emergency fallback synth\");\n                this.synths = {\n                    'emergencyTone': new Tone.PolySynth(Tone.Synth, {\n                        maxPolyphony: 8,\n                        volume: -10\n                    }).toDestination()\n                };\n            }\n        }\n    }\n    \n    /**\n     * Get the best bus for a neuron based on its characteristics\n     * @param {number} neuronId - Neuron ID\n     * @param {boolean} isSelected - Whether the neuron is currently selected\n     * @param {boolean} hasDC - Whether the neuron has DC input\n     * @param {object} params - Neuron sound parameters\n     * @returns {string} Bus ID\n     */\n    getBusForNeuron(neuronId, isSelected, hasDC, params = {}) {\n        // Check if this sound matches hi-hat characteristics - route to special processing\n        const isHiHatSound = this.isHiHatSound(params);\n        \n        // Add detection for organ sounds\n        const isOrganSound = this.isOrganSound(params);\n        \n        // Always use high-quality bus for DC input, selected neurons, or hi-hat sounds\n        if (hasDC || isSelected) {\n            // If it's an organ sound and selected, use organ bus for better sound\n            if (isOrganSound) {\n                console.log(`Routing selected organ sound for neuron ${neuronId} through organ bus`);\n                return this.buses.organ;\n            }\n            return this.buses.highPerc;\n        }\n        \n        // Use organ bus for organ-like sounds\n        if (isOrganSound) {\n            console.log(`Routing organ sound for neuron ${neuronId} through specialized organ bus`);\n            return this.buses.organ;\n        }\n        \n        // Use hi-hat bus for hi-hat sounds to go through the parallel compression path\n        if (isHiHatSound) {\n            console.log(`Routing hi-hat sound for neuron ${neuronId} through special hi-hat bus`);\n            return this.buses.hiHat; // This will connect to the parallel processing path\n        }\n\n        // Use appropriate bus based on neuron ID\n        const busIndex = neuronId % 3; // Simple round-robin approach for bus distribution\n        \n        switch (busIndex) {\n            case 0:\n                return this.buses.low;\n            case 1:\n                return this.buses.mid;\n            case 2:\n                return this.buses.high;\n            default:\n                return this.buses.mid;\n        }\n    }\n    \n    /**\n     * Detect if a sound has organ-like characteristics\n     * @param {object} params - Sound parameters\n     * @returns {boolean} True if sound has organ-like characteristics\n     */\n    isOrganSound(params) {\n        if (!params) return false;\n        \n        // Check if the preset name contains organ but NOT synth lead\n        if (params.name) {\n            // Only consider actual organ sounds as organs, not synth leads\n            if (params.name.toLowerCase().includes('organ')) {\n                return true;\n            }\n            // Explicitly avoid treating synth lead as an organ sound\n            if (params.name.toLowerCase().includes('synth lead')) {\n                return false;\n            }\n        }\n        \n        // Check for organ-like parameter combinations\n        const hasOrganEnvelope = params.attack > 0.05 && params.sustain > 0.7 && params.release > 1.5;\n        const hasOrganOscillator = params.oscillatorType === 'sine';\n        const useSustainedTone = params.useSustainedTone === true;\n        \n        // If it has organ-like envelope and either uses sine wave or sustained tone, consider it an organ\n        return hasOrganEnvelope && (hasOrganOscillator || useSustainedTone);\n    }\n    \n    /**\n     * Helper method to detect if a sound has hi-hat characteristics\n     */\n    isHiHatSound(params) {\n        if (!params) return false;\n        \n        // Check multiple characteristics that indicate a hi-hat sound\n        return (params.name && params.name.toLowerCase().includes('hi-hat')) ||\n               (params.filterType === 'highpass' && params.filterFrequency > 2000) ||\n               (params.oscillatorType === 'noise') || // Added detection for noise oscillator\n               (params.oscillatorType === 'triangle' && params.decay < 0.15 && params.sustain === 0);\n    }\n    \n    /**\n     * Creates a realistic hi-hat sound using noise rather than oscillators\n     * @param {number} velocity - Volume of the hi-hat (0-1)\n     * @param {object} params - Sound parameters\n     * @param {string} busId - Bus ID to use for the sound\n     * @param {number} duration - Duration of the sound\n     * @returns {void}\n     */\n    createNoisyHiHat(velocity, params, busId, duration) {\n        try {\n            // Get appropriate bus for hi-hat\n            const bus = this.buses[busId] || this.buses.hiHat || this.buses.highPerc;\n            if (!bus) return;\n            \n            // Create a noise source for the hi-hat\n            const noise = new Tone.Noise({\n                type: \"white\", // White noise for sharpness\n                volume: -12 // Changed from -10 to -12 (start even quieter)\n            }).start();\n            \n            // Create a bandpass filter to shape the noise into hi-hat sound\n            const filter = new Tone.Filter({\n                type: \"bandpass\",\n                frequency: params.filterFrequency || 8000, // Very high frequency for hi-hats\n                Q: params.filterQ || 1\n            });\n            \n            // Add a high-pass filter to remove low frequencies\n            const highpass = new Tone.Filter({\n                type: \"highpass\",\n                frequency: 7000, // Changed from 6000 to 7000 (cut even more lows)\n                rolloff: -48 // Steeper rolloff\n            });\n            \n            // Create mid-scoop EQ to prevent interference with bass frequencies\n            const midScoopEQ = new Tone.Filter({\n                type: \"notch\", // Add notch filter to create a mid-scoop\n                frequency: 500, // Center frequency in the mid-bass range\n                Q: 1.2,       // Wider Q for broader cut\n                gain: -12     // Deep cut to ensure no bass interference\n            });\n            \n            // Add a resonant peak for metallic character\n            const peakEQ = new Tone.Filter({\n                type: \"peaking\",\n                frequency: 9000, // Metallic resonance\n                Q: 2,\n                gain: 5 // Changed from 6 to 5 (slightly less boost)\n            });\n            \n            // Envelope for the hi-hat\n            const envelope = new Tone.AmplitudeEnvelope({\n                attack: params.attack || 0.001, // Ultra-fast attack\n                decay: params.decay || 0.08,    // Short decay\n                sustain: 0,                     // No sustain for hi-hats\n                release: params.release || 0.05, // Very short release\n            });\n            \n            // Connect the enhanced chain with mid-scoop\n            noise.connect(filter);\n            filter.connect(highpass);\n            highpass.connect(midScoopEQ);       // Add midScoopEQ to the chain\n            midScoopEQ.connect(peakEQ);         // Connect to peakEQ\n            peakEQ.connect(envelope);\n            \n            // Connect to destination\n            envelope.connect(bus.filter || bus.gain || Tone.Destination);\n            \n            // Get current time\n            const now = Tone.now();\n            \n            // Set velocity-dependent volume\n            envelope.attackCurve = \"exponential\";\n            envelope.releaseCurve = \"exponential\";\n            noise.volume.value = -17 + (velocity * 14); // Changed from -15 + (velocity * 15) to -17 + (velocity * 14)\n            \n            // Trigger the envelope\n            envelope.triggerAttackRelease(duration, now);\n            \n            // Clean up after sound is done\n            setTimeout(() => {\n                noise.stop();\n                noise.dispose();\n                filter.dispose();\n                highpass.dispose();\n                midScoopEQ.dispose();           // Dispose of the new filter\n                peakEQ.dispose();\n                envelope.dispose();\n            }, (duration * 1000) + 200);\n            \n            return true;\n        } catch (error) {\n            console.error(\"Error creating hi-hat sound:\", error);\n            return false;\n        }\n    }\n    \n    /**\n     * Determines if a neuron is allowed to play sound\n     * @param {number} neuronId - Neuron ID\n     * @param {boolean} hasDC - Whether the neuron has DC input\n     * @param {boolean} isIsolated - Whether the neuron is isolated\n     * @returns {boolean} Whether the neuron can play\n     */\n    canPlaySound(neuronId, hasDC, isIsolated) {\n        // Always allow selected neuron to play\n        if (neuronId === this.selectedNeuronId) {\n            return true;\n        }\n        \n        // If preview mode is active, only allow selected neuron to play\n        if (this.playPreviewSounds && this.selectedNeuronId !== null) {\n            return false;\n        }\n        \n        // Check if we're already at the maximum number of voices\n        if (this.activeVoices.size >= this.maxVoices) {\n            // Calculate priority (0-100)\n            const priority = this.calculateNeuronPriority(neuronId, hasDC, isIsolated);\n            \n            // Lower priority threshold from 70 to 50 to allow more neurons to play\n            return priority >= 50;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Calculate neuron priority for voice allocation\n     * @param {number} neuronId - Neuron ID\n     * @param {boolean} hasDC - Whether the neuron has DC input\n     * @param {boolean} isIsolated - Whether the neuron is isolated\n     * @returns {number} Priority value (0-100)\n     */\n    calculateNeuronPriority(neuronId, hasDC, isIsolated) {\n        let priority = 50; // Default priority\n        \n        // DC input neurons are more important - but slightly less boost\n        if (hasDC) {\n            priority += 25; // Reduced from 30 to 25\n        }\n        \n        // Isolated neurons are less important - but not as penalized\n        if (isIsolated) {\n            priority -= 15; // Reduced penalty from 20 to 15\n        }\n        \n        // Neurons that have just played are less important to avoid repetition\n        if (this.activeVoices.has(neuronId)) {\n            priority -= 20; // Reduced penalty from 30 to 20\n        }\n        \n        // Clamp priority to 0-100 range\n        return Math.max(0, Math.min(100, priority));\n    }\n    \n    /**\n     * Track active voice in the voice allocation system\n     * @param {number} neuronId - Neuron ID\n     */\n    trackActiveVoice(neuronId) {\n        // Add neuron to active voices\n        this.activeVoices.add(neuronId);\n        \n        // Remove after timeout - using the adjusted voiceTimeout of 1000ms\n        setTimeout(() => {\n            this.activeVoices.delete(neuronId);\n        }, this.voiceTimeout);\n    }\n    \n    /**\n     * Play sound when a neuron fires\n     * @param {number} weight - Connection weight (0-1)\n     * @param {number} speed - Connection speed (0-1)\n     * @param {number} neuronId - Neuron ID\n     * @param {boolean} isIsolated - Whether the neuron is isolated\n     * @param {boolean} hasDC - Whether the neuron has DC input\n     * @param {number} distance - Distance to target neuron\n     */\n    playNeuronFiring(weight = 0.5, speed = 0.5, neuronId, isIsolated = false, hasDC = false, distance = 0) {\n        // Update spatial position if spatial audio is enabled\n        if (this.spatialAudioEnabled && neuronId) {\n            this.updateNeuronSpatialPosition(neuronId);\n        }\n        \n        // Check if we can play a sound for this neuron (voice management)\n        if (!this.canPlaySound(neuronId, hasDC, isIsolated)) {\n            return false;\n        }\n        \n        // Check audio context\n        if (!Tone.context || Tone.context.state !== 'running') {\n            console.warn(\"Audio context not running, can't play sound\");\n            return;\n        }\n        \n        try {\n            // Get current time for timing calculations\n            const currentTime = performance.now();\n        \n            // Check global minimum time between sounds first\n            const timeSinceLastPlay = currentTime - this.lastPlayTime;\n            if (timeSinceLastPlay < this.minTimeBetweenNotes) {\n                return;\n            }\n            \n            // Check neuron-specific timing for consistency (especially important for DC neurons)\n            if (hasDC && neuronId) {\n                const neuronTimeSinceLastPlay = currentTime - (this.neuronLastPlayTime.get(neuronId) || 0);\n                \n                // For DC neurons, enforce a minimum time between firings to prevent double-firing\n                // This is crucial for rhythm consistency\n                const minNeuronPlayInterval = hasDC ? 50 : 25; // 50ms minimum between sounds from same DC neuron\n                \n                if (neuronTimeSinceLastPlay < minNeuronPlayInterval) {\n                    console.log(`Skipping too-frequent sound for neuron ${neuronId} (${neuronTimeSinceLastPlay.toFixed(1)}ms)`);\n                    return;\n                }\n                \n                // Update neuron-specific last play time\n                this.neuronLastPlayTime.set(neuronId, currentTime);\n            }\n            \n            // Update global last play time\n            this.lastPlayTime = currentTime;\n        \n            // Get neuron parameters\n            const params = this.getNeuronSynthParams(neuronId);\n            if (!params) {\n                console.error(`No parameters found for neuron ${neuronId}`);\n                return;\n            }\n        \n            // Check if volume is at minimum - if so, completely silence this neuron\n            if (params.neuronVolume !== undefined && params.neuronVolume <= -12) {\n                // Simply return without playing any sound to completely silence the neuron\n                console.log(`Neuron ${neuronId} is muted (volume at minimum)`);\n                return;\n            }\n            \n            // Check if this is a hi-hat sound\n            const isHiHatSound = this.isHiHatSound(params);\n        \n            // Check if this is an organ-type sound\n            const isOrganSound = this.isOrganSound(params);\n        \n            // Check if this is a bass sound\n            const isBassSound = params && \n                (params.name && params.name.toLowerCase().includes('bass')) || \n                (params.filterType === 'lowpass' && params.filterFrequency < 400);\n        \n            // Track sound type activity for dynamic processing\n            if (isHiHatSound) {\n                this.recentSoundTypes.hihat.lastPlayed = performance.now();\n            }\n            if (isBassSound) {\n                this.recentSoundTypes.bass.lastPlayed = performance.now();\n            }\n            // Update sound type tracking\n            this.trackSoundTypeActivity();\n        \n            // Get appropriate bus for this neuron\n            const bus = this.getBusForNeuron(neuronId, neuronId === this.selectedNeuronId, hasDC, params);\n            if (!bus) {\n                console.error(`No bus found for neuron ${neuronId}`);\n                return;\n            }\n        \n            const busId = bus.id;\n            \n            // Store bus assignment for spatial audio\n            this.neuronBusAssignments.set(neuronId, busId);\n            \n            // Track voice\n            this.trackActiveVoice(neuronId);\n            \n            // Apply sound parameters to bus\n            this.applyNeuronParametersToBus(neuronId, bus, params);\n            \n            // Get frequency data\n            let noteFreq = params.note; // Already set in params\n            \n            // Adjust based on weight and neuron volume\n            let velocity = Math.min(0.9, Math.max(0.3, weight * 0.8));\n            \n            // Apply instrument-specific volume adjustments for better bass/hi-hat balance\n            if (isBassSound) {\n                // Reduce bass velocity slightly to prevent clipping when mixed with hi-hats\n                velocity *= 0.75; // Additional 25% reduction for bass sounds\n            }\n            \n            if (isHiHatSound) {\n                // Further reduce hi-hat volume for better balance\n                velocity *= 0.85; // Additional 15% reduction for hi-hat sounds\n            }\n            \n            // Apply neuron volume with extra attenuation for low volumes\n            if (params.neuronVolume !== undefined) {\n                // Check if this is a sustained sound\n                const isSustainedSound = params.useSustainedTone || (params.sustain > 0.5) || \n                                        params.name?.toLowerCase().includes('pad') || \n                                        params.name?.toLowerCase().includes('organ') || \n                                        params.name?.toLowerCase().includes('synth');\n                \n                // Check specifically for pad sounds which need more aggressive attenuation\n                const isPadSound = params.name?.toLowerCase().includes('pad');\n                \n                // Calculate base volume factor using a smoother curve for all sounds\n                // Use a consistent logarithmic curve with a slight bend for more natural feeling\n                let volumeFactor;\n                \n                if (params.neuronVolume >= 0) {\n                    // For positive values, use standard dB conversion\n                    volumeFactor = Math.pow(10, params.neuronVolume / 20);\n                } else {\n                    // For negative values, use a smooth exponential curve\n                    // This creates a natural-feeling taper without special thresholds at -10dB\n                    const curve = 1 - Math.min(1, Math.abs(params.neuronVolume) / 12);\n                    volumeFactor = Math.pow(10, params.neuronVolume / 20) * (0.3 + 0.7 * curve);\n                }\n                \n                // Apply the volume factor\n                velocity *= volumeFactor;\n                \n                // Apply consistent reductions for sustained sounds and pads\n                // Apply reduction for pad sounds regardless of volume level\n                if (isPadSound) {\n                    // The volumeScaling parameter in the preset will handle most of the pad reduction\n                    velocity *= 0.7; // 30% reduction for all pad sounds\n                }\n                \n                // Apply less aggressive reduction for sustained sounds\n                if (isSustainedSound && !isPadSound) { // Don't double-apply for pads\n                    velocity *= 0.8; // 20% reduction for all sustained sounds\n                }\n                \n                // Final safety check - use a more gradual curve that starts fading earlier\n                if (params.neuronVolume <= -9) {\n                    // Create a smooth fade from -9 to -12 (instead of sharp cutoff at -11)\n                    const fadeOutFactor = Math.max(0, (params.neuronVolume + 12) / 3); // Linear fade over 3dB\n                    velocity *= fadeOutFactor;\n                }\n            }\n            \n            // Apply volume normalization\n            velocity *= this.volumeNormalization;\n            \n            // Apply instrument-specific volume scaling if defined\n            if (params.volumeScaling !== undefined) {\n                velocity *= params.volumeScaling;\n            }\n            \n            // Get oscillator type for our optimized oscillator bank\n            const oscillatorType = params.oscillator?.type || params.oscillatorType || 'triangle';\n            \n            // Get quantized frequency using our improved method\n            const quantizedFreq = this.getClosestFrequency(noteFreq);\n            \n            // Get or create the oscillator (lazy initialization)\n            const oscData = this._getOrCreateOscillator(oscillatorType, quantizedFreq);\n            \n            // Track this neuron with the oscillator\n            oscData.activeNeurons.add(neuronId);\n            \n            // Schedule cleanup after the sound should be done\n            setTimeout(() => {\n                oscData.activeNeurons.delete(neuronId);\n            }, 2000); // After sound should be done\n            \n            // Get envelope parameters\n            const attack = params.envelope?.attack || params.attack || 0.002;\n            const decay = params.envelope?.decay || params.decay || 0.3;\n            const sustain = params.envelope?.sustain || params.sustain || 0.2;\n            const release = params.envelope?.release || params.release || 0.8;\n            \n            // Calculate note duration based on envelope and speed\n            const noteDuration = Math.max(0.1, attack + decay + (sustain > 0.01 ? release * 0.8 : 0));\n            \n            // Schedule the audio (with slight delay to avoid scheduling errors)\n            const now = Tone.now();\n            const noteTime = now + 0.01;\n            \n            // For hi-hat sounds, use the specialized noise-based hi-hat\n            if (isHiHatSound) {\n                // Use our noisy hi-hat generator for more realistic hi-hats\n                const success = this.createNoisyHiHat(velocity, params, busId, noteDuration);\n                if (success) {\n                    return; // Exit early if hi-hat was successfully created\n                }\n                // Otherwise fall back to standard synth\n            }\n            \n            // Determine which synth to use based on bus and parameters\n            let synthToUse = null;\n            \n            if (isOrganSound && busId === 'organ') {\n                // Handle organ sound (layered synths)\n                const baseSynth = this.synths[busId + 'Tone'];\n                const octaveSynth = this.synths[busId + 'OctaveUp'];\n                const fifthSynth = this.synths[busId + 'Fifth'];\n                const airSynth = this.synths[busId + 'Air'];\n                \n                if (baseSynth && octaveSynth && fifthSynth) {\n                    // Check and manage polyphony before playing new notes\n                    this.managePolyphonyOverflow(baseSynth);\n                    this.managePolyphonyOverflow(octaveSynth);\n                    this.managePolyphonyOverflow(fifthSynth);\n                    \n                    // Calculate harmonic frequencies\n                    const octaveFreq = quantizedFreq * 2; // One octave up\n                    const fifthFreq = quantizedFreq * 1.5; // Perfect fifth\n                    \n                    // Use slightly different velocities for harmonics to add complexity\n                    const octaveVelocity = velocity * 0.6; // Quieter octave\n                    const fifthVelocity = velocity * 0.4; // Even quieter fifth\n                    \n                    // Handle potential \"Max polyphony exceeded\" errors - prioritize base notes\n                    try {\n                        // First, monitor the active voices count to detect potential polyphony issues\n                        const organActiveVoices = Object.values(this.synths)\n                            .filter(synth => synth && synth._activeVoices && synth._activeVoices.size)\n                            .reduce((total, synth) => total + synth._activeVoices.size, 0);\n                        \n                        // If we're approaching polyphony limits, prioritize base notes and drop some harmonics\n                        const isApproachingLimit = organActiveVoices > 15; // Getting close to our limit\n                        \n                        // Base note - always play this with highest priority\n                        baseSynth.triggerAttackRelease(quantizedFreq, noteDuration, noteTime, velocity);\n                        \n                        // Octave up - play only if we're not at risk of exceeding polyphony\n                        if (!isApproachingLimit) {\n                            octaveSynth.triggerAttackRelease(octaveFreq, noteDuration * 0.9, noteTime + 0.02, octaveVelocity);\n                        }\n                        \n                        // Fifth - lowest priority, play only if we have plenty of polyphony available\n                        if (organActiveVoices < 12) {\n                            fifthSynth.triggerAttackRelease(fifthFreq, noteDuration * 0.85, noteTime + 0.03, fifthVelocity);\n                        }\n                    } catch (err) {\n                        // Fallback in case of any errors - just play the base note\n                        console.warn(`Organ harmonics error, falling back to base note: ${err.message}`);\n                        try {\n                            baseSynth.triggerAttackRelease(quantizedFreq, noteDuration, noteTime, velocity);\n                        } catch (baseErr) {\n                            console.error(`Failed to play even base organ note: ${baseErr.message}`);\n                        }\n                    }\n                    \n                    // Add air noise for realism if available\n                    if (airSynth) {\n                        // Create a gain envelope for the noise\n                        const airGain = new Tone.Gain(0).connect(bus.filter);\n                        airSynth.connect(airGain);\n                        \n                        // Schedule envelope for the air noise\n                        airGain.gain.cancelScheduledValues(noteTime);\n                        airGain.gain.setValueAtTime(0, noteTime);\n                        airGain.gain.linearRampToValueAtTime(0.02 * velocity, noteTime + attack * 0.5);\n                        airGain.gain.linearRampToValueAtTime(0.01 * velocity, noteTime + attack + decay);\n                        airGain.gain.linearRampToValueAtTime(0, noteTime + noteDuration);\n                        \n                        // Clean up gain node after use\n                        setTimeout(() => {\n                            airGain.dispose();\n                        }, (noteDuration + 0.1) * 1000);\n                    }\n                    \n                    console.log(`Played layered organ sound for neuron ${neuronId} - base: ${quantizedFreq.toFixed(1)}Hz, octave: ${octaveFreq.toFixed(1)}Hz, fifth: ${fifthFreq.toFixed(1)}Hz`);\n                } else {\n                    // Fallback to standard synth if organ synths not available\n                    synthToUse = this.synths[busId + 'Tone'] || this.synths['midTone'];\n                    if (synthToUse) {\n                        // Manage polyphony for this synth too\n                        this.managePolyphonyOverflow(synthToUse);\n                        synthToUse.triggerAttackRelease(quantizedFreq, noteDuration, noteTime, velocity);\n                    } else {\n                        console.error(`No synth available for neuron ${neuronId}`);\n                    }\n                }\n            } else {\n                // Use membrane synth for percussion sounds\n                if (params.useMembrane || (attack < 0.01 && decay < 0.1 && sustain < 0.1)) {\n                    synthToUse = this.synths[busId + 'Membrane'] || this.synths['midMembrane'] || this.synths[busId + 'Tone'];\n                } \n                // Use sustain synth for sustained sounds\n                else if (params.useSustainedTone || sustain > 0.5) {\n                    synthToUse = this.synths[busId + 'Sustain'] || this.synths['midSustain'] || this.synths[busId + 'Tone'];\n                } \n                // Default to tone synth\n                else {\n                    synthToUse = this.synths[busId + 'Tone'] || this.synths['midTone'];\n                }\n                \n                // Play the sound if synth is available\n                if (synthToUse) {\n                    // Manage polyphony before playing\n                    this.managePolyphonyOverflow(synthToUse);\n                    synthToUse.triggerAttackRelease(quantizedFreq, noteDuration, noteTime, velocity);\n                } else {\n                    console.error(`No synth available for neuron ${neuronId}`);\n                }\n            }\n        } catch (error) {\n            console.error(`Error playing neuron firing sound:`, error);\n        }\n    }\n    \n    /**\n     * Configure membrane synth parameters\n     */\n    setMembraneSynthParams(synth, params, hardness, speed, baseVolume) {\n        // Make membrane synths more responsive to volume changes\n        let adjustedVolume = baseVolume;\n        \n        // Apply gradual reduction as volume decreases without hard thresholds\n        const reductionAmount = Math.max(0, Math.min(8, Math.abs(baseVolume) / 1.5));\n        adjustedVolume -= reductionAmount;\n        \n        synth.set({\n            pitchDecay: (params.pitchDecay || 0.05) * (1 + (1-speed)), // More pitch decay for slower hits\n            oscillator: {\n                type: params.oscillator?.type || 'triangle'\n            },\n            envelope: {\n                attack: params.envelope?.attack || 0.002,\n                decay: (params.envelope?.decay || 0.3) * hardness, // Harder hits decay faster\n                sustain: Math.min(1, Math.max(0, params.envelope?.sustain || 0.2)),\n                release: params.envelope?.release || 0.8,\n                attackCurve: params.envelope?.attackCurve || 'exponential'\n            },\n            volume: adjustedVolume // Modified volume\n        });\n    }\n    \n    /**\n     * Configure tonal synth parameters\n     */\n    setTonalSynthParams(synth, params, hardness, baseVolume) {\n        // Calculate volume adjustment using a smooth curve\n        let adjustedVolume = baseVolume;\n        \n        // Apply a gradual reduction based on volume without hard thresholds\n        const reductionAmount = Math.max(0, Math.min(6, Math.abs(baseVolume) / 2));\n        adjustedVolume -= reductionAmount;\n        \n        // Check if this is a Synth Lead sound specifically\n        const isSynthLead = params.name?.toLowerCase().includes('synth lead');\n        \n        // Apply instrument-specific adjustments\n        if (isSynthLead) {\n            // Use a smaller baseline reduction for Synth Lead (-3 instead of -5)\n            adjustedVolume -= 3;\n        } else {\n            // Standard reduction for other instruments\n            adjustedVolume -= 5;\n        }\n        \n        synth.set({\n            detune: params.detune || 0,\n            oscillator: {\n                type: params.oscillator?.type || 'sine'\n            },\n            envelope: {\n                attack: params.envelope?.attack || 0.002,\n                decay: (params.envelope?.decay || 0.3) * (1 + (1-hardness)*0.5), // Softer hits decay slower\n                sustain: Math.min(1, Math.max(0, params.envelope?.sustain || 0.2)),\n                release: params.envelope?.release || 0.8,\n                attackCurve: params.envelope?.attackCurve || 'exponential',\n                decayCurve: params.envelope?.decayCurve || 'exponential',\n                releaseCurve: params.envelope?.releaseCurve || 'exponential'\n            },\n            volume: adjustedVolume // Now uses the instrument-specific adjusted volume\n        });\n    }\n    \n    /**\n     * Configure sustain synth parameters\n     */\n    setSustainSynthParams(synth, params, baseVolume) {\n        // Calculate adjusted volume with a moderate, consistent reduction\n        let adjustedVolume = baseVolume - 6; // Changed from -8 to -6 for less aggressive base reduction\n        \n        // Check if this is specifically a pad sound\n        const isPadSound = params.name?.toLowerCase().includes('pad');\n        \n        // Apply a small additional reduction for pad sounds (instead of volume-dependent reductions)\n        if (isPadSound) {\n            adjustedVolume -= 2; // Consistent -2dB reduction for pad sounds\n        }\n        \n        synth.set({\n            oscillator: {\n                type: params.oscillator?.type || 'sine'\n            },\n            envelope: {\n                attack: (params.envelope?.attack || 0.002) * 2,     // Slower attack for pad sound\n                decay: (params.envelope?.decay || 0.3) * 2,       // Longer decay\n                sustain: Math.min(1, Math.max(0, (params.envelope?.sustain || 0.2) * 1.2)),\n                release: (params.envelope?.release || 0.8) * 2.5  // Much longer release\n            },\n            volume: adjustedVolume // Use the adjusted volume with moderate attenuation\n        });\n    }\n    \n    /**\n     * Apply neuron parameters to a bus's effects\n     */\n    applyNeuronParametersToBus(neuronId, bus, params) {\n        // Only apply parameters if not in the middle of a sound\n        if (this.activeVoices.has(neuronId)) {\n            return;\n        }\n        \n        // Safety check for bus\n        if (!bus || !bus.eq) {\n            console.warn('Cannot apply parameters to bus - invalid bus or missing components');\n            return;\n        }\n        \n        let now = Tone.now();\n        if (now <= this.lastAudioTime) {\n            now = this.lastAudioTime + 0.01;\n        }\n        this.lastAudioTime = now;\n        \n        try {\n        // Apply filter parameters (with smoothing)\n            if (params.filter || (params.filterType && params.filterFrequency)) {\n                // Get filter parameters from either nested object or top-level properties\n                const filterType = params.filter?.type || params.filterType || \"lowpass\";\n                const filterFreq = params.filter?.frequency || params.filterFrequency || 5000;\n                const filterQ = params.filter?.q || params.filterQ || 1;\n                \n                // Update filter\n                bus.filter.type = filterType;\n                bus.filter.frequency.cancelScheduledValues(now);\n                bus.filter.frequency.setValueAtTime(bus.filter.frequency.value, now);\n                bus.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.05);\n            \n                bus.filter.Q.cancelScheduledValues(now);\n                bus.filter.Q.setValueAtTime(bus.filter.Q.value, now);\n                bus.filter.Q.linearRampToValueAtTime(filterQ, now + 0.05);\n            }\n            \n            // Apply EQ (if provided)\n            if (params.eq && bus.eq) {\n                bus.eq.low.value = params.eq.low || 0;\n                bus.eq.mid.value = params.eq.mid || 0;\n                bus.eq.high.value = params.eq.high || 0;\n            }\n            \n            // Apply effect sends (with smoothing)\n            if (params.effects || (params.reverbSend !== undefined || params.delaySend !== undefined)) {\n                // Get effect parameters from either nested object or top-level properties\n                const reverbSend = params.effects?.reverbSend ?? params.reverbSend ?? 0.2;\n                const delaySend = params.effects?.delaySend ?? params.delaySend ?? 0.15;\n                \n                // Update reverb send\n                if (bus.reverb && bus.reverb.wet) {\n                    bus.reverb.wet.cancelScheduledValues(now);\n                    bus.reverb.wet.setValueAtTime(bus.reverb.wet.value, now);\n                    bus.reverb.wet.linearRampToValueAtTime(reverbSend, now + 0.05);\n                }\n                \n                // Update delay send\n                if (bus.delay && bus.delay.wet) {\n                    bus.delay.wet.cancelScheduledValues(now);\n                    bus.delay.wet.setValueAtTime(bus.delay.wet.value, now);\n                    bus.delay.wet.linearRampToValueAtTime(delaySend, now + 0.05);\n                }\n            }\n            \n            // Apply modulation parameters (with smoothing)\n            if (params.modulation || \n                (params.tremoloFreq !== undefined || params.tremoloDepth !== undefined || \n                 params.vibratoFreq !== undefined || params.vibratoDepth !== undefined)) {\n                \n                // Get modulation parameters from either nested object or top-level properties\n                const tremoloFreq = params.modulation?.tremoloFreq ?? params.tremoloFreq ?? 4;\n                const tremoloDepth = params.modulation?.tremoloDepth ?? params.tremoloDepth ?? 0;\n                const vibratoFreq = params.modulation?.vibratoFreq ?? params.vibratoFreq ?? 5;\n                const vibratoDepth = params.modulation?.vibratoDepth ?? params.vibratoDepth ?? 0;\n                \n                // Update tremolo\n                if (bus.tremolo) {\n                    bus.tremolo.frequency.value = tremoloFreq;\n                    bus.tremolo.depth.value = tremoloDepth;\n                    bus.tremolo.wet.value = tremoloDepth > 0 ? 1 : 0;\n                }\n                \n                // Update vibrato\n                if (bus.vibrato) {\n                    bus.vibrato.frequency.value = vibratoFreq;\n                    bus.vibrato.depth.value = vibratoDepth;\n                    bus.vibrato.wet.value = vibratoDepth > 0 ? 1 : 0;\n                }\n            }\n        } catch (err) {\n            console.error('Error applying parameters to bus:', err);\n        }\n    }\n    \n    /**\n     * Assign a frequency range to a neuron\n     */\n    assignFrequencyRange(neuronId) {\n        // Special handling for the first neuron (ID 1)\n        if (neuronId === 1) {\n            // Use F2 note for the bass\n            const bassNote = 'F2'; // Changed from C2 to F2\n            const baseFreq = Tone.Frequency(bassNote).toFrequency();\n            \n            // Store frequency information\n            this.neuronFrequencies.set(neuronId, {\n                range: 'low',\n                freqIndex: 0,\n                baseFreq: baseFreq,\n                customFreq: null\n            });\n\n            console.log(`%c[OSCILLATOR BANK] Assigned ${bassNote} (${baseFreq.toFixed(2)}Hz) in low range to first neuron`, \"color: #00ff00;\");\n            return this.neuronFrequencies.get(neuronId);\n        }\n\n        // Original frequency assignment logic for other neurons\n        const ranges = Object.keys(this.frequencyRanges);\n        const rangeIndex = neuronId % ranges.length;\n        let range = ranges[rangeIndex];\n        \n        // Use melodic pattern for frequency selection\n        const freqIndex = this.melodicPattern[this.currentPatternIndex];\n        this.currentPatternIndex = (this.currentPatternIndex + 1) % this.melodicPattern.length;\n\n        // Get note from the selected range and index\n        const notesInRange = this.frequencyRanges[range];\n        \n        // Add error checking to prevent undefined access\n        if (!notesInRange || !notesInRange.length) {\n            console.error(`No notes found for range \"${range}\". Falling back to mid range.`);\n            // Fallback to mid range if the selected range doesn't exist\n            range = 'mid';\n            if (!this.frequencyRanges[range]) {\n                // Last resort fallback\n                console.error(`Critical error: No mid range found. Check frequencyRanges configuration.`);\n                return { range: 'mid', freqIndex: 0, baseFreq: 440, customFreq: null };\n            }\n        }\n        \n        const noteInRange = notesInRange[freqIndex % notesInRange.length];\n        \n        // Calculate base frequency for the note\n        let baseFreq = 440; // Default A4\n        if (noteInRange) {\n            // Convert note name to frequency using Tone.js\n            try {\n                baseFreq = Tone.Frequency(noteInRange).toFrequency();\n            } catch (e) {\n                console.warn(`Could not convert note ${noteInRange} to frequency, using default`);\n            }\n        }\n\n        // Store frequency information\n        this.neuronFrequencies.set(neuronId, {\n            range: range,\n            freqIndex: freqIndex,\n            baseFreq: baseFreq,\n            customFreq: null // Default to no custom frequency\n        });\n\n        console.log(`%c[OSCILLATOR BANK] Assigned ${noteInRange} (${baseFreq.toFixed(2)}Hz) in ${range} range to neuron ${neuronId}`, \"color: #00ff00;\");\n\n        // Update melody direction for variety\n        if (this.lastFreqIndex >= notesInRange.length - 1) {\n            this.melodyDirection = -1;\n        } else if (this.lastFreqIndex <= 0) {\n            this.melodyDirection = 1;\n        }\n        this.lastFreqIndex = (this.lastFreqIndex + this.melodyDirection) % notesInRange.length;\n\n        return this.neuronFrequencies.get(neuronId);\n    }\n    \n    /**\n     * Get the sound parameters for a neuron\n     */\n    getNeuronSoundParameters(neuronId) {\n        // Get the neuron's current parameters from the overrides\n        const overrides = this.neuronSoundOverrides.get(neuronId) || {};\n        \n        // Get frequency data if available\n        let noteFreq = 440; // Default to A4\n        if (this.neuronFrequencies.has(neuronId)) {\n            const freqData = this.neuronFrequencies.get(neuronId);\n            noteFreq = freqData.customFreq || freqData.baseFreq || noteFreq;\n        } else {\n            // Assign a new frequency if none exists\n            const freqData = this.assignFrequencyRange(neuronId);\n            noteFreq = freqData.customFreq || freqData.baseFreq || noteFreq;\n        }\n        \n        // Get the base parameters\n        const baseParams = {\n            attack: 0.002,\n            decay: 0.3,\n            sustain: 0.2,\n            release: 0.8,\n            pitchDecay: 0.05,\n            detune: 0,\n            neuronVolume: 0,\n            note: noteFreq,\n            oscillatorType: 'triangle',\n            filterType: \"lowpass\",\n            filterFrequency: 5000,\n            filterQ: 1,\n            reverbSend: 0.2,\n            delaySend: 0.15,\n            tremoloFreq: 4,\n            tremoloDepth: 0,\n            vibratoFreq: 5,\n            vibratoDepth: 0,\n            useSustainedTone: false\n        };\n\n        // Combine parameters\n        const params = {\n            ...baseParams,\n            ...overrides,\n            note: Number(overrides.note || baseParams.note)\n        };\n        \n        // Ensure proper structure\n        if (!params.envelope) {\n            params.envelope = {\n                attack: params.attack || baseParams.attack,\n                decay: params.decay || baseParams.decay,\n                sustain: params.sustain || baseParams.sustain,\n                release: params.release || baseParams.release,\n                attackCurve: params.attackCurve || 'exponential',\n                decayCurve: params.decayCurve || 'exponential',\n                releaseCurve: params.releaseCurve || 'exponential'\n            };\n        }\n        \n        if (!params.oscillator) {\n            params.oscillator = {\n                type: params.oscillatorType || baseParams.oscillatorType\n            };\n        }\n        \n        if (!params.filter) {\n            params.filter = {\n                type: params.filterType || baseParams.filterType,\n                frequency: params.filterFrequency || baseParams.filterFrequency,\n                Q: params.filterQ || baseParams.filterQ\n            };\n        }\n        \n        if (!params.effects) {\n            params.effects = {\n                reverbSend: params.reverbSend ?? baseParams.reverbSend,\n                delaySend: params.delaySend ?? baseParams.delaySend\n            };\n        }\n        \n        if (!params.modulation) {\n            params.modulation = {\n                tremoloFreq: params.tremoloFreq ?? baseParams.tremoloFreq,\n                tremoloDepth: params.tremoloDepth ?? baseParams.tremoloDepth,\n                vibratoFreq: params.vibratoFreq ?? baseParams.vibratoFreq,\n                vibratoDepth: params.vibratoDepth ?? baseParams.vibratoDepth\n            };\n        }\n        \n        return params;\n    }\n    \n    /**\n     * Alias for getNeuronSoundParameters - fixes the naming inconsistency error\n     * @param {number} neuronId - Neuron ID\n     * @returns {object} Sound parameters for the neuron\n     */\n    getNeuronSynthParams(neuronId) {\n        // Call the correctly named method\n        return this.getNeuronSoundParameters(neuronId);\n    }\n    \n    /**\n     * Select a neuron for editing\n     * @param {number} neuronId - Neuron ID\n     */\n    selectNeuron(neuronId) {\n        if (neuronId === null) {\n            this.deselectNeuron();\n            return;\n        }\n\n        console.log(`SoundManager: Selecting neuron ${neuronId}`);\n        \n        // Store the previous neuron ID before updating\n        const previousNeuronId = this.selectedNeuronId;\n        this.selectedNeuronId = neuronId;\n        \n        // Initialize settings for this neuron if they don't exist yet\n        if (!this.neuronSoundOverrides.has(neuronId)) {\n            console.log(`Creating initial sound settings for neuron ${neuronId}`);\n            \n            // If we have previously selected neuron parameters, use those instead of defaults\n            if (this.lastSelectedNeuronParams) {\n                console.log(`Applying sound settings from previous neuron to neuron ${neuronId}`);\n                this.neuronSoundOverrides.set(neuronId, JSON.parse(JSON.stringify(this.lastSelectedNeuronParams)));\n            } else {\n            // Create initial sound settings with default values\n            const defaultParams = this.getDefaultSynthParams();\n            this.neuronSoundOverrides.set(neuronId, {\n                pitchDecay: defaultParams.pitchDecay,\n                detune: defaultParams.detune,\n                neuronVolume: defaultParams.neuronVolume,\n                useSustainedTone: defaultParams.useSustainedTone,\n                envelope: {\n                    attack: defaultParams.attack,\n                    decay: defaultParams.decay,\n                    sustain: defaultParams.sustain,\n                    release: defaultParams.release\n                },\n                oscillator: {\n                    type: defaultParams.oscillatorType\n                },\n                filter: {\n                    type: defaultParams.filterType,\n                    frequency: defaultParams.filterFrequency,\n                    Q: defaultParams.filterQ\n                },\n                effects: {\n                    reverbSend: defaultParams.reverbSend,\n                    delaySend: defaultParams.delaySend\n                },\n                modulation: {\n                    tremoloFreq: defaultParams.tremoloFreq,\n                    tremoloDepth: defaultParams.tremoloDepth,\n                    vibratoFreq: defaultParams.vibratoFreq,\n                    vibratoDepth: defaultParams.vibratoDepth\n                }\n            });\n            }\n        } else {\n            // Store the current neuron's parameters to apply to future new neurons\n            this.lastSelectedNeuronParams = JSON.parse(JSON.stringify(this.neuronSoundOverrides.get(neuronId)));\n            console.log(`Stored sound settings from neuron ${neuronId} for future new neurons`);\n        }\n        \n        // Initialize frequency data if it doesn't exist yet\n        if (!this.neuronFrequencies.has(neuronId)) {\n            console.log(`Assigning frequency data for neuron ${neuronId}`);\n            this.assignFrequencyRange(neuronId);\n        }\n\n        // Find neuron position for the selection ring\n        let neuronPosition = null;\n        let neuronScale = null;\n        for (const circle of window.circles || []) {\n            if (circle && circle.neuron && circle.neuron.id === neuronId) {\n                neuronPosition = {\n                    x: circle.position.x,\n                    y: circle.position.y,\n                    z: circle.position.z\n                };\n                neuronScale = circle.scale.x;\n                break;\n            }\n        }\n\n        // Selection ring has been removed - no need to update\n    }\n    \n    /**\n     * Deselect the currently selected neuron\n     */\n    deselectNeuron() {\n        this.selectedNeuronId = null;\n        \n        // Selection ring has been removed - no deselection needed\n    }\n    \n    /**\n     * Get default synth parameters for UI initialization\n     */\n    getDefaultSynthParams() {\n        return {\n            attack: 0.002,\n            decay: 0.3,\n            sustain: 0.2,\n            release: 0.8,\n            pitchDecay: 0.05,\n            detune: 0,\n            neuronVolume: 0,\n            note: this.baseFrequency,\n            oscillatorType: \"triangle\",\n            attackCurve: \"exponential\",\n            useSustainedTone: false,\n            filterType: \"lowpass\",\n            filterFrequency: 5000,\n            filterQ: 1,\n            reverbSend: 0.2,\n            delaySend: 0.15,\n            tremoloFreq: 4,\n            tremoloDepth: 0,\n            vibratoFreq: 5,\n            vibratoDepth: 0\n        };\n    }\n    \n    /**\n     * Update parameters for the selected neuron\n     */\n    updateSelectedSynthParam(paramName, value) {\n        if (this.selectedNeuronId === null) return; // No neuron selected\n\n        console.log(`%c[OSCILLATOR BANK] Updating parameter ${paramName} to ${value}`, \"color: #00aaff;\");\n        \n        // Get the current overrides for this neuron\n        if (!this.neuronSoundOverrides.has(this.selectedNeuronId)) {\n            this.neuronSoundOverrides.set(this.selectedNeuronId, {});\n        }\n        \n        const overrides = this.neuronSoundOverrides.get(this.selectedNeuronId);\n        \n        // Handle note frequency change separately\n        if (paramName === 'note') {\n            // Make sure neuronFrequencies has this neuron\n            if (!this.neuronFrequencies.has(this.selectedNeuronId)) {\n                this.assignFrequencyRange(this.selectedNeuronId);\n            }\n            \n            // Get current frequency data\n            const freqData = this.neuronFrequencies.get(this.selectedNeuronId);\n            \n            // Update custom frequency\n            freqData.customFreq = value;\n            \n            // Set the override value\n            overrides.note = value;\n        } \n        // Handle envelope parameters\n        else if (['attack', 'decay', 'sustain', 'release', 'attackCurve', 'decayCurve', 'releaseCurve'].includes(paramName)) {\n            // Initialize envelope object if not exists\n            if (!overrides.envelope) {\n                overrides.envelope = {};\n            }\n            overrides.envelope[paramName] = value;\n            \n            // Also set the top-level parameter for compatibility\n            overrides[paramName] = value;\n        }\n        // Handle oscillator parameters\n        else if (paramName === 'oscillatorType') {\n            // Initialize oscillator object if not exists\n            if (!overrides.oscillator) {\n                overrides.oscillator = {};\n            }\n            overrides.oscillator.type = value;\n            \n            // Also set the top-level parameter for compatibility\n            overrides[paramName] = value;\n            \n            // Validate that this oscillator type exists in our bank\n            if (!this.oscillatorBank.has(value)) {\n                console.warn(`Oscillator type \"${value}\" not found in oscillator bank. Using \"sine\" instead.`);\n                overrides.oscillator.type = \"sine\";\n            }\n            \n            // Ensure this change is immediately reflected in UI\n            if (window.settings) {\n                window.settings.selectedOscillatorType = value;\n                console.log(`%c[OSCILLATOR BANK] Updated oscillator type to ${value} for neuron ${this.selectedNeuronId}`, \"color: #00ff00;\");\n            }\n        }\n        // Handle filter parameters\n        else if (['filterType', 'filterFrequency', 'filterQ'].includes(paramName)) {\n            // Initialize filter object if not exists\n            if (!overrides.filter) {\n                overrides.filter = {};\n            }\n            \n            const filterParamName = paramName.replace('filter', '').toLowerCase();\n            overrides.filter[filterParamName] = value;\n            \n            // Also set the top-level parameter for compatibility\n            overrides[paramName] = value;\n            \n            // Update bus filter immediately for selected neuron\n            if (this.buses && this.buses.selected && this.buses.selected.filter) {\n                if (filterParamName === 'type') {\n                    this.buses.selected.filter.type = value;\n                } else if (filterParamName === 'frequency') {\n                    const now = Tone.now();\n                    this.buses.selected.filter.frequency.cancelScheduledValues(now);\n                    this.buses.selected.filter.frequency.setValueAtTime(this.buses.selected.filter.frequency.value, now);\n                    this.buses.selected.filter.frequency.linearRampToValueAtTime(value, now + 0.05);\n                } else if (filterParamName === 'q') {\n                    const now = Tone.now();\n                    this.buses.selected.filter.Q.cancelScheduledValues(now);\n                    this.buses.selected.filter.Q.setValueAtTime(this.buses.selected.filter.Q.value, now);\n                    this.buses.selected.filter.Q.linearRampToValueAtTime(value, now + 0.05);\n                }\n            }\n        }\n        // Handle effect parameters\n        else if (['reverbSend', 'delaySend'].includes(paramName)) {\n            // Initialize effects object if not exists\n            if (!overrides.effects) {\n                overrides.effects = {};\n            }\n            \n            overrides.effects[paramName] = value;\n            \n            // Also set the top-level parameter for compatibility\n            overrides[paramName] = value;\n            \n            // Update bus effects immediately for selected neuron\n            if (this.buses && this.buses.selected) {\n                if (paramName === 'reverbSend' && this.buses.selected.reverb) {\n                    this.buses.selected.reverb.wet.value = value;\n                } else if (paramName === 'delaySend' && this.buses.selected.delay) {\n                    this.buses.selected.delay.wet.value = value;\n                }\n            }\n        }\n        // Handle modulation parameters\n        else if (['tremoloFreq', 'tremoloDepth', 'vibratoFreq', 'vibratoDepth'].includes(paramName)) {\n            // Initialize modulation object if not exists\n            if (!overrides.modulation) {\n                overrides.modulation = {};\n            }\n            \n            overrides.modulation[paramName] = value;\n            \n            // Also set the top-level parameter for compatibility\n            overrides[paramName] = value;\n            \n            // Update bus modulation immediately for selected neuron\n            if (this.buses && this.buses.selected) {\n                if (paramName === 'tremoloFreq' && this.buses.selected.tremolo) {\n                    this.buses.selected.tremolo.frequency.value = value;\n                } else if (paramName === 'tremoloDepth' && this.buses.selected.tremolo) {\n                    this.buses.selected.tremolo.depth.value = value;\n                    this.buses.selected.tremolo.wet.value = value > 0 ? 1 : 0;\n                } else if (paramName === 'vibratoFreq' && this.buses.selected.vibrato) {\n                    this.buses.selected.vibrato.frequency.value = value;\n                } else if (paramName === 'vibratoDepth' && this.buses.selected.vibrato) {\n                    this.buses.selected.vibrato.depth.value = value;\n                    this.buses.selected.vibrato.wet.value = value > 0 ? 1 : 0;\n                }\n            }\n        }\n        // Handle other parameters\n        else {\n            overrides[paramName] = value;\n            \n            // Special handling for preset name\n            if (paramName === 'name') {\n                console.log(`%c[OSCILLATOR BANK] Set preset name to \"${value}\" for neuron ${this.selectedNeuronId}`, \"color: #00aaff;\");\n            }\n        }\n        \n        // Save the updated overrides back to the map\n        this.neuronSoundOverrides.set(this.selectedNeuronId, overrides);\n        \n        // Update window.settings to reflect the changes (for tweakpane updates)\n        if (window.settings) {\n            // Convert paramName to match the tweakpane control name format\n            const settingName = `selected${paramName.charAt(0).toUpperCase() + paramName.slice(1)}`;\n            window.settings[settingName] = value;\n            \n            // Refresh UI controls if they exist\n            if (window.selectedSynthFolder) {\n                window.selectedSynthFolder.refresh();\n            }\n        }\n        \n        // Only play a preview sound if explicitly enabled\n        if (window.settings && window.settings.previewSounds) {\n            this.triggerPreviewSound();\n        }\n    }\n\n    /**\n     * Trigger a preview sound to demonstrate current sound settings\n     */\n    triggerPreviewSound() {\n        // Only play preview sounds if enabled\n        if (!window.settings || !window.settings.previewSounds) {\n            return;\n        }\n        \n        // Clear any existing debounce timeout\n        if (this.previewDebounceTimeout) {\n            clearTimeout(this.previewDebounceTimeout);\n        }\n        \n        // Debounce to prevent too many sounds from playing at once during slider adjustment\n        this.previewDebounceTimeout = setTimeout(() => {\n            if (this.selectedNeuronId !== null) {\n                this.playNeuronFiring(\n                    0.7, // weight\n                    0.5, // speed\n                    this.selectedNeuronId,\n                    true, // isIsolated\n                    true, // hasDC\n                    0    // distance\n                );\n                \n                // Force update of visualizations\n                if (window.drawVisualizations) {\n                    window.drawVisualizations();\n                }\n            }\n        }, 50); // Short debounce delay\n    }\n\n    /**\n     * Play a small sound for UI feedback\n     * @param {number} pitch - Pitch parameter (0-1)\n     * @param {number} speed - Speed parameter (0-1)\n     * @param {number} volume - Volume parameter (0-1)\n     */\n    playSmallSound(pitch = 0.5, speed = 0.5, volume = 0.3) {\n        // Ensure audio context is running\n        this.ensureAudioContext();\n        \n        // Convert pitch parameter to a frequency in a suitable range\n        const freq = 600 + (pitch * 600);\n        \n        // Duration based on speed (faster = shorter sound)\n        const duration = 0.1 + ((1 - speed) * 0.2);\n        \n        // Use one of our existing buses for simplicity\n        const bus = this.buses[\"selected\"];\n        if (!bus || !bus.eq) {\n            console.warn(\"Cannot play small sound - bus not available\");\n            return;\n        }\n        \n        // Get quantized frequency\n        const quantizedFreq = this.getClosestFrequency(freq);\n        \n        // Get oscillator data for sine wave (simplest for UI sounds)\n        const oscillatorType = \"sine\";\n        \n        // Get or create the oscillator (lazy initialization)\n        const oscData = this._getOrCreateOscillator(oscillatorType, quantizedFreq);\n        \n        if (!oscData) {\n            console.warn(`No oscillator found for UI sound`);\n            return;\n        }\n        \n        // Create a temporary gain node for this sound\n        const tempGain = new Tone.Gain(0).connect(bus.gain);\n        oscData.oscillator.connect(tempGain);\n        \n        // Play a quick double tone with envelope\n        const now = Tone.now();\n        \n        // First tone\n        tempGain.gain.cancelScheduledValues(now);\n        tempGain.gain.setValueAtTime(0, now);\n        tempGain.gain.linearRampToValueAtTime(volume * 0.7, now + 0.01);\n        tempGain.gain.linearRampToValueAtTime(0, now + duration * 0.6);\n        \n        // Cleanup gain node after sound is done\n        setTimeout(() => {\n            tempGain.dispose();\n        }, (duration * 1000) + 200);\n    }\n\n    // Set the global volume\n    setVolume(volume) {\n        this.volume = volume;\n        if (this.finalMixer) {\n            // Convert from dB to linear gain\n            const gainValue = Math.pow(10, volume / 20);\n            this.finalMixer.gain.value = gainValue;\n        }\n        console.log(`Set master volume to ${volume}dB (gain: ${Math.pow(10, volume / 20).toFixed(3)})`);\n    }\n    \n    // Set the volume normalization factor\n    setVolumeNormalization(factor) {\n        this.volumeNormalization = factor;\n        console.log(`Set volume normalization factor to ${factor.toFixed(2)}`);\n    }\n    \n    /**\n     * Set preview sounds mode (solo selected neuron)\n     * @param {boolean} enabled - Whether preview sounds mode is enabled\n     */\n    setPreviewSounds(enabled) {\n        this.playPreviewSounds = enabled;\n        console.log(`Preview sounds ${enabled ? 'enabled' : 'disabled'} - ${enabled ? 'Only selected neuron' : 'All neurons'} will play`);\n    }\n    \n    // Add a direct test sound method at the end of the class\n    testSound() {\n        console.log(\"Playing test sound...\");\n        this.ensureAudioContext();\n        \n        // Create a simple oscillator and connect it directly to the output\n        const osc = new Tone.Oscillator({\n            frequency: 440,\n            type: \"sine\"\n        }).start();\n        \n        const gain = new Tone.Gain(0).toDestination();\n        osc.connect(gain);\n        \n        // Simple envelope\n        const now = Tone.now();\n        gain.gain.setValueAtTime(0, now);\n        gain.gain.linearRampToValueAtTime(0.5, now + 0.01);\n        gain.gain.linearRampToValueAtTime(0, now + 0.5);\n        \n        // Clean up\n        setTimeout(() => {\n            osc.stop();\n            osc.dispose();\n            gain.dispose();\n            console.log(\"Test sound completed\");\n        }, 600);\n    }\n    \n    // Immediately silence a specific neuron\n    silenceNeuron(neuronId) {\n        if (!neuronId) return;\n        \n        console.log(`Silencing neuron ${neuronId}`);\n        \n        // Find the appropriate bus for this neuron\n        const busId = this.neuronBusAssignments.get(neuronId) || 'mid';\n        const bus = this.buses[busId];\n        \n        // If we have a bus, temporarily mute it to silence any ongoing sounds for this neuron\n        if (bus && bus.gain) {\n            // Store the original volume\n            const originalVolume = bus.gain.gain.value;\n            \n            // Immediately set gain to 0 to silence\n            bus.gain.gain.setValueAtTime(0, Tone.now());\n            \n            // Restore after a short time (to allow disconnects to happen)\n            setTimeout(() => {\n                bus.gain.gain.setValueAtTime(originalVolume, Tone.now());\n            }, 100);\n        }\n        \n        // Clean up any pending restorations\n        if (this.pendingRestorations && this.pendingRestorations.has(neuronId)) {\n            clearTimeout(this.pendingRestorations.get(neuronId));\n            this.pendingRestorations.delete(neuronId);\n        }\n        \n        // Remove from active voices\n        if (this.activeVoices) {\n            this.activeVoices.delete(neuronId);\n        }\n        \n        // Clear any synth overrides\n        this.neuronSoundOverrides.delete(neuronId);\n        \n        // Clear any frequency assignments\n        this.neuronFrequencies.delete(neuronId);\n        \n        // Clear any bus assignments\n        this.neuronBusAssignments.delete(neuronId);\n        \n        // If this was the selected neuron, deselect it\n        if (this.selectedNeuronId === neuronId) {\n            this.selectedNeuronId = null;\n        }\n    }\n    \n    // Silence all neurons and clear all neuron-related sound data\n    silenceAllNeurons() {\n        console.log(\"Silencing all neurons\");\n        \n        // Save current sound state before clearing\n        this._lastNeuronSoundState = {\n            neuronSoundOverrides: new Map(this.neuronSoundOverrides),\n            neuronFrequencies: new Map(this.neuronFrequencies),\n            neuronBusAssignments: new Map(this.neuronBusAssignments)\n        };\n        \n        // Temporarily mute all buses to immediately stop all sounds\n        Object.values(this.buses).forEach(bus => {\n            if (bus && bus.gain) {\n                const originalVolume = bus.gain.gain.value;\n                // Immediately silence\n                bus.gain.gain.setValueAtTime(0, Tone.now());\n                \n                // Restore after a short delay\n                setTimeout(() => {\n                    bus.gain.gain.setValueAtTime(originalVolume, Tone.now());\n                }, 100);\n            }\n        });\n        \n        // Clear all pending restorations\n        if (this.pendingRestorations) {\n            this.pendingRestorations.forEach(timeoutId => {\n                clearTimeout(timeoutId);\n            });\n            this.pendingRestorations.clear();\n        }\n        \n        // Clear all data structures\n        this.activeVoices.clear();\n        this.neuronSoundOverrides.clear();\n        this.neuronFrequencies.clear();\n        this.neuronBusAssignments.clear();\n        this.voicePriorities.clear();\n        \n        // Reset selected neuron\n        this.selectedNeuronId = null;\n    }\n\n    /**\n     * Restore all neuron sound assignments after audio context resume\n     */\n    restoreAllNeuronSounds() {\n        // If we have a backup from before silence, restore it\n        if (this._lastNeuronSoundState) {\n            this.neuronSoundOverrides = new Map(this._lastNeuronSoundState.neuronSoundOverrides);\n            this.neuronFrequencies = new Map(this._lastNeuronSoundState.neuronFrequencies);\n            this.neuronBusAssignments = new Map(this._lastNeuronSoundState.neuronBusAssignments);\n            this._lastNeuronSoundState = null; // Clear backup after restoring\n            console.log('Restored neuron sound state from backup.');\n        }\n        if (!window.circles) return;\n        window.circles.forEach(circle => {\n            if (circle && circle.neuron) {\n                const neuronId = circle.neuron.id;\n                // If we have stored overrides and frequency, re-apply them\n                if (this.neuronSoundOverrides.has(neuronId) && this.neuronFrequencies.has(neuronId)) {\n                    // Re-set the override and frequency to themselves to ensure they're in the map\n                    const overrides = this.neuronSoundOverrides.get(neuronId);\n                    this.neuronSoundOverrides.set(neuronId, {...overrides});\n                    const freqData = this.neuronFrequencies.get(neuronId);\n                    this.neuronFrequencies.set(neuronId, {...freqData});\n                }\n                // Ensure bus assignment\n                if (!this.neuronBusAssignments.has(neuronId)) {\n                    const params = this.getNeuronSynthParams ? this.getNeuronSynthParams(neuronId) : this.getNeuronSoundParameters(neuronId);\n                    const isIsolated = !circle.neuron.outgoingConnections.size;\n                    const hasDC = circle.neuron.dcInput > 0;\n                    const busId = this.getBusForNeuron(neuronId, false, hasDC, params);\n                    this.neuronBusAssignments.set(neuronId, busId);\n                }\n            }\n        });\n        console.log('Restored all neuron sound assignments after audio context resume.');\n    }\n    \n    /**\n     * Refresh DC neuron functionality without disrupting sound playback\n     * This is a replacement for the previous implementation that would \n     * cause neurons to pause when creating connections\n     */\n    refreshDCNeurons() {\n        // We intentionally do nothing disruptive here\n        // With our improved neuron.js implementation, there's actually \n        // no need to reset or refresh anything when connections change\n        \n        // This empty method ensures any legacy code calling refreshDCNeurons \n        // will not cause any disruption to audio playback\n        \n        // Here's why we've removed all logic:\n        // 1. When a neuron has DC input, its internal timer continues firing regularly\n        // 2. When connections are created/modified, they don't affect the DC timing\n        // 3. Our neuron.js improvements ensure DC timing is preserved during all operations\n        \n        // The empty method exists only for backward compatibility\n        return;\n    }\n\n    // Add method for tracking active sound types\n    trackSoundTypeActivity() {\n        // Update playing status based on time elapsed (consider a sound \"active\" for 200ms)\n        const now = performance.now();\n        const activeThreshold = 200; // 200ms\n        \n        // Check if bass is still playing\n        if (now - this.recentSoundTypes.bass.lastPlayed < activeThreshold) {\n            this.recentSoundTypes.bass.isPlaying = true;\n        } else {\n            this.recentSoundTypes.bass.isPlaying = false;\n        }\n        \n        // Check if hi-hat is still playing\n        if (now - this.recentSoundTypes.hihat.lastPlayed < activeThreshold) {\n            this.recentSoundTypes.hihat.isPlaying = true;\n        } else {\n            this.recentSoundTypes.hihat.isPlaying = false;\n        }\n        \n        // If both are playing, ensure the finalMixer gain is reduced\n        if (this.recentSoundTypes.bass.isPlaying && this.recentSoundTypes.hihat.isPlaying) {\n            if (this.finalMixer && this.finalMixer.gain) {\n                // Temporarily reduce the gain to prevent clipping\n                this.finalMixer.gain.value = 0.85; // Further reduce from 0.92 to 0.85 when both are active\n            }\n        } else {\n            // Return to normal gain\n            if (this.finalMixer && this.finalMixer.gain) {\n                this.finalMixer.gain.value = 0.92;\n            }\n        }\n    }\n\n    // Add a new dispose method to ensure proper cleanup at shutdown\n    dispose() {\n        console.log(\"%c[OSCILLATOR BANK] Disposing all oscillators and audio resources\", \"color: #ff0000; font-weight: bold;\");\n        \n        // Clean up all oscillators\n        this.oscillatorBank.forEach((freqMap, type) => {\n            freqMap.forEach((oscData, freq) => {\n                if (oscData.gain) oscData.gain.dispose();\n                if (oscData.oscillator) oscData.oscillator.dispose();\n            });\n            freqMap.clear();\n        });\n        this.oscillatorBank.clear();\n        \n        // Also clean up audio buses and other resources\n        if (this.buses) {\n            Object.values(this.buses).forEach(bus => {\n                if (bus.gain) bus.gain.dispose();\n                if (bus.eq) bus.eq.dispose();\n                if (bus.compressor) bus.compressor.dispose();\n                if (bus.reverb) bus.reverb.dispose();\n                if (bus.delay) bus.delay.dispose();\n            });\n        }\n        \n        if (this.masterLimiter) this.masterLimiter.dispose();\n        if (this.masterCompressor) this.masterCompressor.dispose();\n        if (this.finalMixer) this.finalMixer.dispose();\n        if (this.waveformAnalyzer) this.waveformAnalyzer.dispose();\n        \n        // Clean up spatial audio nodes\n        this.spatialAudioNodes.forEach(panner => {\n            if (panner && typeof panner.dispose === 'function') {\n                panner.dispose();\n            }\n        });\n        this.spatialAudioNodes.clear();\n        this.spatialAudioPanners.clear();\n        \n        console.log(\"%c[OSCILLATOR BANK] All audio resources disposed\", \"color: #ff0000; font-weight: bold;\");\n    }\n\n    // Add a method to manage polyphony by releasing old notes when needed\n    managePolyphonyOverflow(synth) {\n        if (!synth || !synth._activeVoices) return;\n        \n        // Check if we're close to the polyphony limit\n        if (synth._activeVoices.size >= synth.options.maxPolyphony - 2) {\n            console.log(`%c[POLYPHONY] Managing polyphony for synth - active voices: ${synth._activeVoices.size}/${synth.options.maxPolyphony}`, \"color: #ff9900;\");\n            \n            // Get notes that have been playing the longest\n            const activeNotes = Array.from(synth._activeVoices.entries());\n            \n            // Sort by start time (oldest first)\n            activeNotes.sort((a, b) => a[1].startTime - b[1].startTime);\n            \n            // Release up to 4 of the oldest notes to make room for new ones\n            const notesToRelease = activeNotes.slice(0, Math.min(4, Math.ceil(activeNotes.length * 0.25)));\n            \n            notesToRelease.forEach(noteEntry => {\n                try {\n                    const note = noteEntry[0];\n                    // Force an immediate release\n                    synth.triggerRelease(note, Tone.now());\n                    console.log(`%c[POLYPHONY] Released old note ${note} to make room for new notes`, \"color: #ff9900;\");\n                } catch (err) {\n                    console.warn(`Error releasing note: ${err.message}`);\n                }\n            });\n        }\n    }\n} \n\n// Set up the global helper function to update the neuron label\nwindow.updateNeuronLabel = (neuronId) => {\n    if (neuronId === null) {\n        this.neuronLabelElement.style.display = 'none';\n    } else {\n        // Find the neuron to get its preset name\n        let presetName = '';\n        let dcValue = '0.00';\n        \n        if (window.circles) {\n            const neuron = window.circles.find(circle => \n                circle && circle.neuron && circle.neuron.id === neuronId);\n            \n            if (neuron && neuron.neuron) {\n                presetName = neuron.neuron.presetName || '';\n                dcValue = neuron.neuron.dcInput?.toFixed(2) || '0.00';\n            }\n        }\n        \n        // Format the label with [ID] and preset name\n        this.neuronLabelElement.innerHTML = `[ ${neuronId} ]  ${presetName}<br>DC: ${dcValue} <span style=\"margin-left: 5px; font-size: 12px;\">🔊</span>`;\n        this.neuronLabelElement.style.display = 'block';\n        \n        // Add tooltip for clarity\n        this.neuronLabelElement.title = \"Click to toggle sound controls\";\n    }\n};","import * as THREE from 'three';\n\nimport Logger from '../utils/logger';\n\n/**\n * NeuronEffect - Lightweight visual effects for neuron firing\n * Separates visual effects from core neuron logic for better performance\n */\nexport class NeuronEffect {\n  static effectsPool = [];\n  static availableEffects = [];\n  static initialized = false;\n  \n  /**\n   * Initialize the effects system with a pool of reusable effects\n   * @param {THREE.Scene} scene - The scene to add effects to\n   * @param {number} poolSize - Number of pre-created effects (default 20)\n   */\n  static initialize(scene, poolSize = 20) {\n    if (this.initialized) return;\n    \n    this.scene = scene;\n    this.initialized = true;\n    Logger.info(`[NeuronEffect] Initialized with disabled effects for performance`);\n  }\n  \n  /**\n   * Create a single firing effect object - disabled\n   * @returns {THREE.Object3D} A lightweight effect object\n   */\n  static createEffect() {\n    return null;\n  }\n  \n  /**\n   * Get an available effect from the pool - disabled\n   * @returns {THREE.Object3D} An effect object ready to use\n   */\n  static getEffect() {\n    return null;\n  }\n  \n  /**\n   * Return an effect to the pool for reuse - disabled\n   * @param {THREE.Object3D} effect - The effect to return to the pool\n   */\n  static releaseEffect(effect) {\n    // Do nothing - disabled\n  }\n  \n  /**\n   * Create a firing effect at the specified neuron - disabled for performance\n   * @param {THREE.Object3D} neuronMesh - The neuron mesh\n   * @param {THREE.Color} color - Color of the effect (optional)\n   */\n  static createFiringEffect(neuronMesh, color = null) {\n    // Animation disabled for performance\n    return;\n  }\n  \n  /**\n   * Clean up all effects\n   */\n  static dispose() {\n    if (!this.initialized) return;\n    this.initialized = false;\n  }\n} ","import * as THREE from 'three';\n\nimport Logger from '../utils/logger';\n\n/**\n * ConnectionEffect - Lightweight visual effects for connection signals\n * Handles particle animations without affecting neuron performance\n */\nexport class ConnectionEffect {\n  static particlePool = [];\n  static availableParticles = [];\n  static initialized = false;\n  \n  /**\n   * Initialize the connection effects system\n   * @param {THREE.Scene} scene - The scene to add effects to\n   * @param {number} poolSize - Number of pre-created particles (default 30)\n   */\n  static initialize(scene, poolSize = 30) {\n    if (this.initialized) return;\n    \n    this.scene = scene;\n    this.initialized = true;\n    Logger.info(`[ConnectionEffect] Initialized with disabled effects for performance`);\n  }\n  \n  /**\n   * Create a single signal particle - disabled\n   * @returns {THREE.Object3D} A lightweight particle object\n   */\n  static createParticle() {\n    return null;\n  }\n  \n  /**\n   * Get an available particle from the pool - disabled\n   * @returns {THREE.Object3D} A particle object ready to use\n   */\n  static getParticle() {\n    return null;\n  }\n  \n  /**\n   * Return a particle to the pool for reuse - disabled\n   * @param {THREE.Object3D} particle - The particle to return to the pool\n   */\n  static releaseParticle(particle) {\n    // Do nothing - disabled\n  }\n  \n  /**\n   * Create a signal particle traveling between neurons - disabled for performance\n   * @param {THREE.Vector3} sourcePos - Starting position\n   * @param {THREE.Vector3} targetPos - Ending position\n   * @param {Function} onComplete - Callback when particle reaches target\n   * @param {number} speed - Speed factor (0-1)\n   * @param {number} weight - Weight factor for particle size (0-1)\n   */\n  static createSignalParticle(sourcePos, targetPos, onComplete = null, speed = 0.5, weight = 0.5) {\n    // Animation disabled for performance, but still trigger the callback\n    if (onComplete) {\n      // Use a setTimeout with minimal delay to simulate completion\n      setTimeout(onComplete, 10);\n    }\n    return;\n  }\n  \n  /**\n   * Clean up all connection effects\n   */\n  static dispose() {\n    if (!this.initialized) return;\n    this.initialized = false;\n  }\n} ","import * as THREE from 'three';\nimport Logger from '../utils/logger';\n\nimport { NeuronEffect } from './NeuronEffect';\nimport { ConnectionEffect } from './ConnectionEffect';\n\n/**\n * EffectsManager - Coordinates all visual effects in the SNN\n * Provides a single interface to manage all lightweight effects\n */\nexport class EffectsManager {\n  constructor(scene) {\n    this.scene = scene;\n    this.initialized = false;\n    \n    // Initialize the effect systems\n    this.initialize();\n  }\n  \n  /**\n   * Initialize all effect systems\n   */\n  initialize() {\n    if (this.initialized) return;\n    \n    Logger.debug('[EffectsManager] Initializing effect systems');\n    \n    // Initialize neuron effects\n    NeuronEffect.initialize(this.scene, 20);\n    \n    // Initialize connection effects\n    ConnectionEffect.initialize(this.scene, 30);\n    \n    this.initialized = true;\n    Logger.info('[EffectsManager] All effect systems initialized');\n  }\n  \n  /**\n   * Create a neuron firing effect\n   * @param {THREE.Object3D} neuronMesh - The neuron mesh\n   * @param {THREE.Color} color - Optional color for the effect\n   */\n  createNeuronFiringEffect(neuronMesh, color = null) {\n    if (!this.initialized) return;\n    NeuronEffect.createFiringEffect(neuronMesh, color);\n  }\n  \n  /**\n   * Create a signal particle between neurons\n   * @param {THREE.Vector3} sourcePos - Starting position\n   * @param {THREE.Vector3} targetPos - Ending position\n   * @param {Function} onComplete - Callback when particle reaches target\n   * @param {number} speed - Speed factor (0-1)\n   * @param {number} weight - Weight factor for particle size (0-1)\n   */\n  createSignalParticle(sourcePos, targetPos, onComplete = null, speed = 0.5, weight = 0.5) {\n    if (!this.initialized) return;\n    ConnectionEffect.createSignalParticle(sourcePos, targetPos, onComplete, speed, weight);\n  }\n  \n  /**\n   * Clean up all resources\n   */\n  dispose() {\n    if (!this.initialized) return;\n    \n    NeuronEffect.dispose();\n    ConnectionEffect.dispose();\n    \n    this.initialized = false;\n  }\n} ","import * as THREE from 'three';\n\nexport class FluidBackgroundEffect {\n    constructor(scene, camera) {\n        this.scene = scene;\n        this.camera = camera;\n        this.neurons = [];\n        this.clock = new THREE.Clock();\n        \n        // Configuration - use visible but not too bright colors\n        this.colors = {\n            dark: new THREE.Color('#1a1a1a'),   // Brighter dark gray\n            light: new THREE.Color('#2a2a2a')   // Brighter medium gray\n        };\n        \n        // Initialize the effect\n        this.initialize();\n    }\n    \n    initialize() {\n        // Create shader material\n        this.shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n                neuronPositions: { value: new Float32Array(30 * 3) }, // xyz for 30 neurons max\n                neuronStrengths: { value: new Float32Array(30) },\n                neuronCount: { value: 0 },\n                colorDark: { value: this.colors.dark },\n                colorLight: { value: this.colors.light }\n            },\n            vertexShader: `\n                varying vec2 vUv;\n                \n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform vec2 resolution;\n                uniform float neuronPositions[90]; // x,y,z for each neuron (max 30)\n                uniform float neuronStrengths[30];\n                uniform int neuronCount;\n                uniform vec3 colorDark;\n                uniform vec3 colorLight;\n                \n                varying vec2 vUv;\n                \n                // Grid calculation function\n                float grid(vec2 uv, float size) {\n                    // Adjust UV coordinates based on aspect ratio\n                    vec2 aspectCorrectedUV = uv;\n                    aspectCorrectedUV.x *= resolution.x / resolution.y;\n                    \n                    // Calculate grid with aspect ratio correction\n                    vec2 grid = fract(aspectCorrectedUV * size);\n                    return (step(0.95, grid.x) + step(0.95, grid.y)) * 0.018;\n                }\n                \n                // Simplified fluid-like function\n                float fluidEffect(vec2 p, float time) {\n                    float value = 0.0;\n                    \n                    // Add base wave pattern - more visible\n                    value += 0.6 * sin(p.x * 2.0 + time * 0.3) * sin(p.y * 2.2 + time * 0.2);\n                    \n                    // Add secondary waves for more complexity\n                    value += 0.3 * sin(p.x * 5.0 - time * 0.2) * sin(p.y * 4.0 - time * 0.1);\n                    value += 0.15 * sin(p.x * 10.0 + time * 0.5) * sin(p.y * 8.0 - time * 0.3);\n                    \n                    // Add neuron influences with stronger effect\n                    for (int i = 0; i < 30; i++) {\n                        if (i >= neuronCount) break;\n                        \n                        // Get neuron screen position from float array\n                        vec2 neuronPos = vec2(\n                            neuronPositions[i * 3],     // x\n                            neuronPositions[i * 3 + 1]  // y\n                        );\n                        \n                        // Calculate distance with proper aspect ratio\n                        vec2 aspectCorrectedPos = neuronPos;\n                        aspectCorrectedPos.x *= resolution.x / resolution.y;\n                        vec2 aspectCorrectedP = p;\n                        aspectCorrectedP.x *= resolution.x / resolution.y;\n                        float dist = distance(aspectCorrectedP, aspectCorrectedPos);\n                        \n                        // Create ripple effect around each neuron\n                        float strength = neuronStrengths[i];\n                        float ripple = strength * 0.005 * sin(dist * 15.0 - time * 3.0) / (1.0 + dist * 3.0);\n                        \n                        // Add repulsion force (neurons push fluid away)\n                        float repulsion = strength * 0.3 / (0.05 + dist * dist * 4.0);\n                        \n                        value += ripple + repulsion;\n                    }\n                    \n                    return value;\n                }\n                \n                void main() {\n                    // Convert UV to normalized device coordinates\n                    vec2 p = vUv * 2.0 - 1.0;\n                    \n                    // Get fluid effect value\n                    float fluid = fluidEffect(p, time);\n                    \n                    // Enhance contrast with non-linear mapping\n                    fluid = 0.5 + 0.5 * fluid;\n                    fluid = pow(fluid, 1.5); // Increase contrast reduction\n                    \n                    // Create gradient between dark and light colors\n                    vec3 color = mix(colorDark, colorLight, fluid);\n                    \n                    // Add grid overlay\n                    float gridValue = grid(vUv, 20.0); // Adjust grid size by changing the number\n                    color = mix(color, vec3(1.0), gridValue);\n                    \n                    gl_FragColor = vec4(color, 1.0);\n                }\n            `,\n            transparent: false,\n            depthWrite: false, // Don't write to depth buffer\n            depthTest: false,  // Don't test against depth buffer\n            needsUpdate: true  // Force update\n        });\n        \n        // Create a plane that fills the view\n        const planeGeometry = new THREE.PlaneGeometry(2, 2);\n        this.plane = new THREE.Mesh(planeGeometry, this.shaderMaterial);\n        \n        // Create a separate scene and camera for the background\n        this.bgScene = new THREE.Scene();\n        this.bgCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -10, 10);\n        \n        // Add plane to the background scene\n        this.bgScene.add(this.plane);\n        \n        // Ensure the plane is visible\n        this.plane.position.z = -5;\n        \n        // Set up resize handler\n        window.addEventListener('resize', this.handleResize.bind(this));\n        \n        // Remove the DOM fallback - we won't need it now\n        const existingFallback = document.getElementById('fluid-fallback');\n        if (existingFallback) {\n            existingFallback.parentNode.removeChild(existingFallback);\n        }\n        \n        // Log initialization\n        console.log('Fluid background effect initialized');\n    }\n    \n    handleResize() {\n        // Update resolution uniform\n        this.shaderMaterial.uniforms.resolution.value.set(\n            window.innerWidth, window.innerHeight\n        );\n    }\n    \n    // Method to update neuron data\n    updateNeurons(neurons) {\n        this.neurons = neurons;\n        \n        // Cap at 30 neurons for performance\n        const count = Math.min(neurons.length, 30);\n        \n        // Create arrays for positions and strengths\n        const positions = new Float32Array(count * 3); // xyz for each neuron\n        const strengths = new Float32Array(count);\n        \n        // Fill arrays with data\n        for (let i = 0; i < count; i++) {\n            const neuron = neurons[i];\n            \n            if (neuron && neuron.position) {\n                // Project 3D position to screen space (-1 to 1)\n                const pos = neuron.position.clone();\n                pos.project(this.camera);\n                \n                // Add position to Float32Array\n                positions[i * 3] = pos.x;\n                positions[i * 3 + 1] = pos.y;\n                positions[i * 3 + 2] = pos.z;\n                \n                // Add strength based on neuron charge or firing state\n                let strength = 0.2; // Base strength\n                \n                if (neuron.neuron) {\n                    // Increase strength when firing\n                    if (neuron.neuron.isFiring) {\n                        strength = 1.0;\n                    } \n                    // Or use current charge\n                    else if (neuron.neuron.currentCharge) {\n                        strength = 0.2 + neuron.neuron.currentCharge * 0.8;\n                    }\n                }\n                \n                strengths[i] = strength;\n            } else {\n                // Add defaults if neuron data is incomplete\n                positions[i * 3] = 0;\n                positions[i * 3 + 1] = 0;\n                positions[i * 3 + 2] = 0;\n                strengths[i] = 0;\n            }\n        }\n        \n        // Update shader uniforms\n        this.shaderMaterial.uniforms.neuronPositions.value = positions;\n        this.shaderMaterial.uniforms.neuronStrengths.value = strengths;\n        this.shaderMaterial.uniforms.neuronCount.value = count;\n    }\n    \n    // Render the background\n    render(renderer) {\n        if (!renderer) {\n            console.error('No renderer provided to fluid background render method');\n            return;\n        }\n        \n        // Update time uniform\n        this.shaderMaterial.uniforms.time.value = this.clock.getElapsedTime();\n        \n        // Debug log (only at startup or once per 300 frames)\n        if (this._renderCount === undefined) {\n            this._renderCount = 0;\n            console.log(`Rendering fluid with ${this.shaderMaterial.uniforms.neuronCount.value} neurons`);\n        } else if (this._renderCount % 300 === 0) {\n            console.log(`Fluid effect active with ${this.shaderMaterial.uniforms.neuronCount.value} neurons`);\n        }\n        this._renderCount++;\n        \n        // Force essential rendering states\n        const originalAutoClear = renderer.autoClear;\n        \n        // Render the background scene\n        renderer.autoClear = true; // Clear everything first\n        renderer.render(this.bgScene, this.bgCamera);\n        \n        // Restore original state\n        renderer.autoClear = originalAutoClear;\n    }\n} ","import * as THREE from 'three';\n\n/**\n * OptimizedParticleSystem - High performance particle system using individual billboard meshes\n * Uses efficient pooling and billboarding for best visual quality and performance\n */\nexport class OptimizedParticleSystem {\n  constructor(scene, maxParticles = 2000) {\n    // Core scene reference\n    this.scene = scene;\n    \n    // Particle management\n    this.maxParticles = maxParticles;\n    this.activeParticles = [];\n    this.particlePool = [];\n    \n    // Tracking data\n    this.neuronConnections = new Map(); // Maps sourceId_targetId to particle meshes\n    \n    // Initialize the particle system\n    this.initialize();\n    \n    console.log(`Particle System initialized with ${maxParticles} maximum particles`);\n  }\n  \n  /**\n   * Initialize billboard particle system\n   */\n  initialize() {\n    // Create a shared geometry for all particles\n    this.geometry = new THREE.PlaneGeometry(0.05, 0.05);\n    \n    // Create a shared material template - will be cloned for each particle\n    this.material = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 0.9,\n      side: THREE.DoubleSide\n    });\n    \n    console.log('Initialized billboard particle system');\n  }\n  \n  /**\n   * Create a particle traveling between two neurons\n   * @param {THREE.Vector3} sourcePos - Start position\n   * @param {THREE.Vector3} targetPos - End position\n   * @param {number} sourceId - Source neuron ID\n   * @param {number} targetId - Target neuron ID\n   * @param {number} weight - Connection weight (0-1)\n   * @param {number} speed - Speed factor (0-1, where 0=stationary, 1=instant)\n   * @returns {string} Particle UUID\n   */\n  createParticle(sourcePos, targetPos, sourceId, targetId, weight = 0.5, speed = 0.5) {\n    // Generate connection key for tracking\n    const connectionKey = `${sourceId}_${targetId}`;\n    \n    // Get a mesh from the pool or create a new one\n    let mesh;\n    if (this.particlePool.length > 0) {\n      mesh = this.particlePool.pop();\n    } else {\n      // Create a new mesh with its own material instance\n      const material = this.material.clone();\n      mesh = new THREE.Mesh(this.geometry, material);\n    }\n    \n    // Handle speed parameter based on the input synaptic speed\n    let actualSpeed;\n    if (speed >= 0.999) {\n      // Special case: Instant\n      actualSpeed = 1.0;\n    } else if (speed <= 0.001) {\n      // Special case: No movement\n      actualSpeed = 0.0001;  // Nearly no movement but keeps animation active\n    } else {\n      // Map speed from 0-1 to appropriate range for animation\n      // Using a more aggressive exponential curve to make differences more obvious\n      actualSpeed = 0.005 * Math.pow(1000, speed - 0.5);\n    }\n    \n    // Position mesh at source\n    mesh.position.copy(sourcePos);\n    \n    // Try to get camera for billboarding\n    const camera = this.scene.getObjectByProperty('type', 'OrthographicCamera') || \n                   this.scene.getObjectByProperty('type', 'PerspectiveCamera');\n                   \n    // Set initial orientation to face camera\n    if (camera) {\n      mesh.lookAt(camera.position);\n    } else {\n      // Default is a top-down view\n      mesh.rotation.x = -Math.PI / 2;\n    }\n    \n    // Set up particle data\n    mesh.userData = {\n      sourcePos: sourcePos.clone(),\n      targetPos: targetPos.clone(),\n      sourceId,\n      targetId,\n      connectionKey,\n      progress: 0,\n      speed: actualSpeed,\n      weight,\n      creationTime: Date.now()\n    };\n    \n    // Add to tracking and scene\n    this.activeParticles.push(mesh);\n    this.scene.add(mesh);\n    \n    // Track connection\n    if (!this.neuronConnections.has(connectionKey)) {\n      this.neuronConnections.set(connectionKey, new Set());\n    }\n    this.neuronConnections.get(connectionKey).add(mesh.uuid);\n    \n    // Enforce maximum particles limit by removing oldest if needed\n    if (this.activeParticles.length > this.maxParticles) {\n      this.removeOldestParticle();\n    }\n    \n    console.log(`Created particle from ${sourceId} to ${targetId}, input speed: ${speed}, calculated speed: ${actualSpeed}`);\n    \n    // For instant travel, immediately complete the particle journey\n    if (speed >= 1) {\n      // Set to final position\n      mesh.position.copy(targetPos);\n      mesh.position.y += 0.2; // Maintain height offset\n      \n      // Trigger arrival event immediately\n      window.dispatchEvent(new CustomEvent('particleArrived', {\n        detail: { \n          targetNeuronId: targetId,\n          sourceNeuronId: sourceId\n        }\n      }));\n      \n      // Remove the particle in the next frame to allow for a brief visual flash\n      setTimeout(() => {\n        if (this.activeParticles.includes(mesh)) {\n          this.removeParticle(mesh);\n        }\n      }, 50);\n    }\n    \n    return mesh.uuid;\n  }\n  \n  /**\n   * Find and remove the oldest particle\n   */\n  removeOldestParticle() {\n    if (this.activeParticles.length === 0) return;\n    \n    let oldestTime = Infinity;\n    let oldestIndex = -1;\n    \n    // Find the oldest particle\n    for (let i = 0; i < this.activeParticles.length; i++) {\n      const creationTime = this.activeParticles[i].userData.creationTime;\n      if (creationTime < oldestTime) {\n        oldestTime = creationTime;\n        oldestIndex = i;\n      }\n    }\n    \n    if (oldestIndex !== -1) {\n      const mesh = this.activeParticles[oldestIndex];\n      this.removeParticle(mesh);\n    }\n  }\n  \n  /**\n   * Remove a particle and return it to the pool\n   * @param {THREE.Mesh} mesh - The particle mesh to remove\n   */\n  removeParticle(mesh) {\n    // Remove from scene\n    this.scene.remove(mesh);\n    \n    // Remove from active particles list\n    const index = this.activeParticles.indexOf(mesh);\n    if (index !== -1) {\n      this.activeParticles.splice(index, 1);\n    }\n    \n    // Remove from connection tracking\n    const connectionKey = mesh.userData.connectionKey;\n    if (this.neuronConnections.has(connectionKey)) {\n      this.neuronConnections.get(connectionKey).delete(mesh.uuid);\n      \n      // Clean up empty sets\n      if (this.neuronConnections.get(connectionKey).size === 0) {\n        this.neuronConnections.delete(connectionKey);\n      }\n    }\n    \n    // Return to pool for reuse\n    this.particlePool.push(mesh);\n  }\n  \n  /**\n   * Update all active particles\n   * @param {number} deltaTime - Time since last frame in seconds\n   */\n  update(deltaTime) {\n    // Cap delta time to prevent huge jumps if frame rate drops\n    const cappedDelta = Math.min(deltaTime, 0.1);\n    \n    // Track particles to remove\n    const particlesToRemove = [];\n    \n    // Get camera if available in the scene\n    const camera = this.scene.getObjectByProperty('type', 'OrthographicCamera') || \n                   this.scene.getObjectByProperty('type', 'PerspectiveCamera');\n    \n    // Update each active mesh\n    for (let i = 0; i < this.activeParticles.length; i++) {\n      const mesh = this.activeParticles[i];\n      const data = mesh.userData;\n      \n      // Update progress based on speed and delta time\n      data.progress += data.speed * cappedDelta * 60;\n      \n      // Check if completed\n      if (data.progress >= 1.0) {\n        particlesToRemove.push(mesh);\n        \n        // Dispatch arrived event\n        window.dispatchEvent(new CustomEvent('particleArrived', {\n          detail: { \n            targetNeuronId: data.targetId,\n            sourceNeuronId: data.sourceId\n          }\n        }));\n        continue;\n      }\n      \n      // Update position - lerp with arc\n      const t = data.progress;\n      const sourcePos = data.sourcePos;\n      const targetPos = data.targetPos;\n      \n      // Linear interpolation\n      mesh.position.x = sourcePos.x + (targetPos.x - sourcePos.x) * t;\n      mesh.position.z = sourcePos.z + (targetPos.z - sourcePos.z) * t;\n      \n      // Add arc effect\n      const arcHeight = 0.6;\n      const arc = Math.sin(t * Math.PI);\n      mesh.position.y = 0.2 + (arcHeight * arc);\n      \n      // Pulse size\n      const pulseFactor = 0.9 + 0.2 * Math.sin(t * 12);\n      const scale = 1.0 * pulseFactor;\n      mesh.scale.set(scale, scale, scale);\n      \n      // Billboard effect - make the plane always face the camera\n      if (camera) {\n        mesh.lookAt(camera.position);\n      } else {\n        // Default orientation if no camera found (top-down view)\n        mesh.rotation.x = -Math.PI / 2;\n      }\n    }\n    \n    // Remove completed particles\n    for (const mesh of particlesToRemove) {\n      this.removeParticle(mesh);\n    }\n    \n    // Only log occasionally if there are significant changes\n    if ((this.activeParticles.length > 10 || particlesToRemove.length > 5) && Math.random() < 0.01) {\n      console.log(`Updating ${this.activeParticles.length} particles, removed ${particlesToRemove.length}`);\n    }\n  }\n  \n  /**\n   * Clean up particles associated with a connection\n   * @param {number} sourceId - Source neuron ID\n   * @param {number} targetId - Target neuron ID\n   */\n  removeConnection(sourceId, targetId) {\n    const connectionKey = `${sourceId}_${targetId}`;\n    \n    if (this.neuronConnections.has(connectionKey)) {\n      const meshIds = Array.from(this.neuronConnections.get(connectionKey));\n      \n      for (const meshId of meshIds) {\n        // Find the mesh\n        const mesh = this.activeParticles.find(m => m.uuid === meshId);\n        if (mesh) {\n          this.removeParticle(mesh);\n        }\n      }\n      \n      // Clear connection\n      this.neuronConnections.delete(connectionKey);\n      \n      console.log(`Removed all particles for connection ${sourceId} → ${targetId}`);\n    }\n  }\n  \n  /**\n   * Clean up all particles (e.g., during scene reset)\n   */\n  clearAllParticles() {\n    // Remove all active meshes from scene and return to pool\n    while (this.activeParticles.length > 0) {\n      const mesh = this.activeParticles[0];\n      this.removeParticle(mesh);\n    }\n    \n    // Clear connection tracking\n    this.neuronConnections.clear();\n    \n    console.log('Cleared all particles');\n  }\n  \n  /**\n   * Find and remove orphaned particles (neurons no longer exist)\n   * @param {Array} activeNeuronIds - Array of active neuron IDs\n   */\n  cleanupOrphanedParticles(activeNeuronIds) {\n    // Convert to Set for faster lookups\n    const activeIds = new Set(activeNeuronIds);\n    const particlesToRemove = [];\n    \n    // Check each active mesh\n    for (const mesh of this.activeParticles) {\n      const data = mesh.userData;\n      if (!activeIds.has(data.sourceId) || !activeIds.has(data.targetId)) {\n        particlesToRemove.push(mesh);\n      }\n    }\n    \n    // Remove orphaned particles\n    for (const mesh of particlesToRemove) {\n      this.removeParticle(mesh);\n    }\n    \n    if (particlesToRemove.length > 0) {\n      console.log(`Removed ${particlesToRemove.length} orphaned particles`);\n    }\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    // Clean up all active particles\n    this.clearAllParticles();\n    \n    // Dispose shared geometry and material\n    this.geometry.dispose();\n    this.material.dispose();\n    \n    // Clear particle pool\n    for (const mesh of this.particlePool) {\n      if (mesh.parent) {\n        mesh.parent.remove(mesh);\n      }\n      if (mesh.material) mesh.material.dispose();\n    }\n    this.particlePool = [];\n    \n    console.log('Disposed particle system');\n  }\n} ","import * as THREE from 'three';\n\n// Define sound presets for use in the application\nconst soundPresets = [\n    { \n        name: \"Pluck\", \n        attack: 0.001,\n        decay: 0.2,\n        sustain: 0.1,\n        release: 0.4,\n        pitchDecay: 0.02,\n        detune: 2,\n        oscillatorType: \"square\",\n        filterType: \"lowpass\",\n        filterFrequency: 3000,\n        filterQ: 2,\n        reverbSend: 0.15,\n        delaySend: 0.2,\n        volumeScaling: 0.8, // Medium scaling for pluck sounds\n        color: new THREE.Color(0xcccc00) // Yellow\n    },\n    { \n        name: \"Lo-Fi Piano\", \n        attack: 0.002,\n        decay: 0.12,\n        sustain: 0.3,\n        release: 0.8,\n        oscillatorType: \"triangle\",\n        pitchDecay: 0.01,\n        detune: 3,\n        filterType: \"lowpass\",\n        filterFrequency: 5000,\n        filterQ: 0.8,\n        reverbSend: 0.15,\n        delaySend: 0.05,\n        neuronVolume: 2,\n        volumeScaling: 0.7, // Medium scaling for piano\n        color: new THREE.Color(0xffffff) // White\n    },\n    { \n        name: \"Analog Synth\", \n        attack: 0.01, \n        decay: 0.3, \n        sustain: 0.4, \n        release: 0.7,\n        oscillatorType: \"sawtooth\",\n        filterType: \"lowpass\",\n        filterFrequency: 1500,\n        filterQ: 3,\n        reverbSend: 0.15,\n        delaySend: 0.2,\n        neuronVolume: 2,\n        volumeScaling: 0.65, // Medium-low scaling for sawtooth waves\n        color: new THREE.Color(0x7700ff) // Vibrant Purple\n    },\n    { \n        name: \"Pad\", \n        attack: 0.3, \n        decay: 0.5, \n        sustain: 0.8, \n        release: 2.0, \n        oscillatorType: \"sine\", \n        useSustainedTone: true,\n        filterType: \"lowpass\",\n        filterFrequency: 1800,\n        filterQ: 0.6,\n        reverbSend: 0.4,\n        delaySend: 0.2,\n        vibratoFreq: 3.5,\n        vibratoDepth: 0.1,\n        neuronVolume: -6, // Changed from -10 to a more moderate starting value\n        volumeScaling: 0.15, // Reduced from 0.3 to 0.15 for much quieter pads\n        color: new THREE.Color(0x00ffff) // Pure Cyan\n    },\n    { \n        name: \"Bell\", \n        attack: 0.001,\n        decay: 0.4,\n        sustain: 0.1,\n        release: 1.2,\n        pitchDecay: 0.1,\n        detune: 5,\n        oscillatorType: \"sine\",\n        filterType: \"highpass\",\n        filterFrequency: 1000,\n        filterQ: 1.5,\n        reverbSend: 0.4,\n        delaySend: 0.1,\n        vibratoFreq: 5,\n        vibratoDepth: 0.1,\n        volumeScaling: 0.75, // Medium scaling for bells\n        color: new THREE.Color(0xffcc00) // Golden\n    },\n    { \n        name: \"Percussion\", \n        attack: 0.001,\n        decay: 0.1,\n        sustain: 0.0,\n        release: 0.2,\n        oscillatorType: \"square\",\n        filterType: \"bandpass\",\n        filterFrequency: 1000,\n        filterQ: 2,\n        reverbSend: 0.1,\n        delaySend: 0.05,\n        volumeScaling: 0.55, // Medium-low scaling for percussion\n        color: new THREE.Color(0xff3300) // Red/orange\n    },\n    { \n        name: \"Brass\", \n        attack: 0.05,\n        decay: 0.3,\n        sustain: 0.7,\n        release: 0.8,\n        oscillatorType: \"sawtooth\",\n        filterType: \"lowpass\",\n        filterFrequency: 2000,\n        filterQ: 1,\n        reverbSend: 0.2,\n        delaySend: 0.1,\n        neuronVolume: -8, // Changed to -8\n        volumeScaling: 0.5, // Medium-low scaling for brass\n        color: new THREE.Color(0xff8800) // Changed to orange\n    },\n    { \n        name: \"String\", \n        attack: 0.1,\n        decay: 0.4,\n        sustain: 0.6,\n        release: 1.0,\n        oscillatorType: \"sine\",\n        filterType: \"lowpass\",\n        filterFrequency: 3000,\n        filterQ: 0.5,\n        reverbSend: 0.3,\n        delaySend: 0.2,\n        neuronVolume: -8, // Changed to -8\n        volumeScaling: 0.5, // Medium-low scaling for strings\n        color: new THREE.Color(0xff8800) // Warm amber\n    },\n    { \n        name: \"Guitar\", \n        attack: 0.01,\n        decay: 0.2,\n        sustain: 0.4,\n        release: 0.6,\n        oscillatorType: \"sine\",\n        filterType: \"lowpass\",\n        filterFrequency: 2500,\n        filterQ: 1,\n        reverbSend: 0.2,\n        delaySend: 0.15,\n        volumeScaling: 0.7, // Medium scaling for guitar\n        color: new THREE.Color(0xff8800) // Warm amber\n    },\n    { \n        name: \"Synth Lead\", \n        attack: 0.1,     // Slow attack for natural organ swell\n        decay: 0.4,      // Moderate decay for organ-like sustained body\n        sustain: 0.8,    // High sustain like a real church organ\n        release: 2.0,    // Long release for natural fade\n        oscillatorType: \"sine\", // Pure sine for fundamental tone\n        pitchDecay: 0.0, // No pitch decay for stable organ sound\n        detune: 0,       // No detune for pure organ sound\n        useSustainedTone: true, // Important for organ-like sound\n        filterType: \"lowpass\",\n        filterFrequency: 2000, // Warmer tone with less high-end harshness\n        filterQ: 0.7,    // Low resonance for natural sound\n        reverbSend: 0.4, // More reverb for church-like space\n        delaySend: 0.1,  // Slight delay for richer sound\n        vibratoFreq: 5.5, // Gentle vibrato like pipe organ tremulant\n        vibratoDepth: 0.08, // Subtle vibrato depth\n        tremoloFreq: 2.5, // Slow tremolo for subtle movement\n        tremoloDepth: 0.1, // Very subtle tremolo\n        neuronVolume: -4, // Changed from -11.0 to a more moderate starting value\n        volumeScaling: 0.25, // Reduced from 0.35 to 0.25 for better balance\n        color: new THREE.Color(0x8800ff) // Purple with more blue for church organ feel\n    },\n    { \n        name: \"Acoustic Drum\", \n        attack: 0.001, \n        decay: 0.18, \n        sustain: 0.0, \n        release: 0.3,\n        oscillatorType: \"triangle\",\n        filterType: \"lowpass\",\n        filterFrequency: 1200,\n        filterQ: 1.5,\n        reverbSend: 0.22,\n        delaySend: 0.05,\n        neuronVolume: 4,\n        volumeScaling: 0.6, // Medium-low scaling for drums\n        color: new THREE.Color(0xff0000) // Pure Red\n    },\n    { \n        name: \"Bass\", \n        attack: 0.01,           // Slightly slower attack for smoother start\n        decay: 0.3,             // Longer decay for more body\n        sustain: 0.2,           // More sustain for fullness\n        release: 0.5,           // Longer release to avoid clipping\n        oscillatorType: \"sine\", // Pure sine wave for cleaner deep bass\n        pitchDecay: 0.08,       // Subtle pitch decay for movement\n        detune: 3,              // Minimal detune for clarity\n        filterType: \"lowpass\",  // Lowpass to focus on the low end\n        filterFrequency: 350,   // Much lower frequency cutoff for deep bass\n        filterQ: 0.7,           // Reduced from 0.8 to 0.7 for smoother sound\n        reverbSend: 0.04,       // Reduced from 0.05 to 0.04 (less reverb for cleaner bass)\n        delaySend: 0.02,        // Reduced from 0.03 to 0.02 (less delay to avoid mud)\n        neuronVolume: 3,        // Reduced from 5 to 3 (lower volume to prevent clipping)\n        volumeScaling: 0.7,     // Reduced from 0.8 to 0.7 for better balance with hi-hats\n        note: 41.20,            // E1 - very low bass register\n        color: new THREE.Color(0x0080ff) // Vibrant blue\n    },\n    { \n        name: \"Gentle Hi-Hat\", \n        attack: 0.001, \n        decay: 0.1,     \n        sustain: 0.0, \n        release: 0.15,\n        oscillatorType: \"noise\", // Changed to noise for realism\n        filterType: \"highpass\",\n        filterFrequency: 8000, // Much higher frequency for hi-hats \n        filterQ: 1.2,           // Reduced from 1.5 to 1.2 for smoother sound\n        reverbSend: 0.08,       // Reduced from 0.12 to 0.08 (less reverb)\n        delaySend: 0.02,        // Reduced from 0.03 to 0.02 (less delay) \n        neuronVolume: 0,        // Reduced from 1 to 0 (lower volume to prevent clipping)\n        volumeScaling: 0.22,    // Reduced from 0.25 to 0.22 (even lower scaling for better balance)\n        color: new THREE.Color(0xcccc00) // Yellow  \n    },\n    { \n        name: \"Bright Hi-Hat\", \n        attack: 0.0005, \n        decay: 0.04,     \n        sustain: 0.0, \n        release: 0.06,\n        oscillatorType: \"noise\", // Changed to noise\n        filterType: \"highpass\",\n        filterFrequency: 11000, // Very high frequency for bright sound\n        filterQ: 2.5,           // Reduced from 3.0 to 2.5 for smoother sound\n        reverbSend: 0.04,       // Reduced from 0.05 to 0.04\n        delaySend: 0.01,        // Reduced from 0.02 to 0.01 \n        neuronVolume: 2,        // Reduced from 4 to 2 (lower volume to prevent clipping)\n        volumeScaling: 0.18,    // Reduced from 0.2 to 0.18 (lower scaling for better balance)\n        color: new THREE.Color(0xcccc00) // Yellow\n    }\n];\n\nexport default soundPresets; ","/**\n * EventSystem - Handles event delegation and interception\n * \n * This class provides a clean way to intercept and delegate events\n * without monkey-patching native functions\n */\nimport { stateManager } from './StateManager.js';\n\nexport class EventSystem {\n  constructor() {\n    this.handlers = {};\n    this.originalHandlers = {};\n    this.delegations = {};\n  }\n  \n  /**\n   * Initialize the event system\n   */\n  initialize() {\n    // Set up global event handling\n    document.addEventListener('click', this.handleGlobalEvent.bind(this, 'click'));\n    document.addEventListener('dblclick', this.handleGlobalEvent.bind(this, 'dblclick'));\n    document.addEventListener('touchend', this.handleGlobalEvent.bind(this, 'touchend'));\n    document.addEventListener('touchstart', this.handleGlobalEvent.bind(this, 'touchstart'));\n  }\n  \n  /**\n   * Global event handler that delegates to registered handlers\n   * @param {string} eventType - Type of event\n   * @param {Event} event - DOM event object\n   */\n  handleGlobalEvent(eventType, event) {\n    // Skip if no delegations for this event type\n    if (!this.delegations[eventType]) return;\n    \n    // Check if the event target matches any delegated selectors\n    for (const { selector, handler } of this.delegations[eventType]) {\n      // Check if the event target matches the selector\n      if (event.target.matches && event.target.matches(selector)) {\n        // Call the handler with the event\n        handler(event);\n      }\n    }\n  }\n  \n  /**\n   * Register a delegate for a specific event type and selector\n   * @param {string} eventType - Type of event (click, touchend, etc)\n   * @param {string} selector - CSS selector to match targets\n   * @param {Function} handler - Event handler function\n   */\n  delegate(eventType, selector, handler) {\n    // Initialize array for this event type if needed\n    if (!this.delegations[eventType]) {\n      this.delegations[eventType] = [];\n    }\n    \n    // Add the delegation\n    this.delegations[eventType].push({ selector, handler });\n  }\n  \n  /**\n   * Register an interceptor for a component's method\n   * @param {object} component - The component instance\n   * @param {string} methodName - Method name to intercept\n   * @param {Function} beforeFn - Function to call before method (can prevent original)\n   * @param {Function} afterFn - Function to call after method\n   */\n  intercept(component, methodName, beforeFn, afterFn) {\n    // Skip if method doesn't exist\n    if (typeof component[methodName] !== 'function') {\n      // Skip non-critical warnings\n      return;\n    }\n    \n    // Skip if already intercepted\n    if (this.handlers[component] && this.handlers[component][methodName]) {\n      // Skip non-critical warnings\n      return;\n    }\n    \n    // Initialize handlers for this component if needed\n    if (!this.handlers[component]) {\n      this.handlers[component] = {};\n      this.originalHandlers[component] = {};\n    }\n    \n    // Store the original method\n    const originalMethod = component[methodName];\n    this.originalHandlers[component][methodName] = originalMethod;\n    \n    // Create the intercepted method\n    component[methodName] = (...args) => {\n      // Call the before function, which can prevent the original method\n      let shouldCallOriginal = true;\n      let modifiedArgs = args;\n      \n      if (beforeFn) {\n        const beforeResult = beforeFn(...args);\n        if (beforeResult === false) {\n          shouldCallOriginal = false;\n        } else if (Array.isArray(beforeResult)) {\n          modifiedArgs = beforeResult;\n        }\n      }\n      \n      // Call the original method if allowed\n      let result;\n      if (shouldCallOriginal) {\n        result = originalMethod.apply(component, modifiedArgs);\n      }\n      \n      // Call the after function with the result\n      if (afterFn) {\n        const afterResult = afterFn(result, ...modifiedArgs);\n        if (afterResult !== undefined) {\n          result = afterResult;\n        }\n      }\n      \n      return result;\n    };\n    \n    // Store the handler\n    this.handlers[component][methodName] = component[methodName];\n  }\n  \n  /**\n   * Restore original method implementation\n   * @param {object} component - The component instance\n   * @param {string} methodName - Method name to restore\n   * @returns {boolean} True if restoration was successful\n   */\n  restoreOriginal(component, methodName) {\n    // Check if method was intercepted\n    if (!this.originalHandlers[component] || !this.originalHandlers[component][methodName]) {\n      return false;\n    }\n    \n    // Restore the original method\n    component[methodName] = this.originalHandlers[component][methodName];\n    \n    // Remove stored handlers\n    delete this.originalHandlers[component][methodName];\n    delete this.handlers[component][methodName];\n    \n    return true;\n  }\n  \n  /**\n   * Clean up all interceptors\n   */\n  cleanup() {\n    // Restore all original methods\n    Object.keys(this.originalHandlers).forEach(component => {\n      Object.keys(this.originalHandlers[component]).forEach(methodName => {\n        component[methodName] = this.originalHandlers[component][methodName];\n      });\n    });\n    \n    // Clear all handlers\n    this.handlers = {};\n    this.originalHandlers = {};\n    \n    // Remove global event listeners\n    document.removeEventListener('click', this.handleGlobalEvent.bind(this, 'click'));\n    document.removeEventListener('dblclick', this.handleGlobalEvent.bind(this, 'dblclick'));\n    document.removeEventListener('touchend', this.handleGlobalEvent.bind(this, 'touchend'));\n    document.removeEventListener('touchstart', this.handleGlobalEvent.bind(this, 'touchstart'));\n  }\n}\n\n// Create a single instance to be imported by all components\nexport const eventSystem = new EventSystem(); ","/**\n * AppInitializer - Handles the initialization of all architectural components\n */\nimport { stateManager } from './StateManager.js';\nimport { reactiveManager } from './ReactiveManager.js';\nimport { eventSystem } from './EventSystem.js';\nimport { timerManager } from './TimerManager.js';\nimport { eventManager } from './EventManager.js';\nimport { resourceManager } from './ResourceManager.js';\n\nexport class AppInitializer {\n  constructor() {\n    this.initialized = false;\n  }\n  \n  /**\n   * Initialize the application architecture\n   * @param {Object} components - Object containing core application components\n   */\n  initialize(components) {\n    if (this.initialized) {\n      // Only log errors, not warnings\n      return;\n    }\n    \n    // Register core components with state manager\n    Object.entries(components).forEach(([name, component]) => {\n      stateManager.registerComponent(name, component);\n    });\n    \n    // Initialize managers in correct sequence\n    this.initializeStateManager(components);\n    this.initializeResourceManager();\n    this.initializeTimerManager();\n    this.initializeEventManager();\n    this.initializeReactiveManager();\n    this.initializeEventSystem();\n    \n    // Set up event relay between system components\n    this.setupEventRelay();\n    \n    // Initialize reactive UI updates\n    this.setupReactiveUI();\n    \n    // Make managers globally available\n    this.exposeManagersGlobally();\n    \n    // Mark as initialized\n    this.initialized = true;\n  }\n  \n  /**\n   * Initialize the state manager with initial values\n   * @param {Object} components - Core application components\n   */\n  initializeStateManager(components) {\n    // Store initial state values\n    stateManager.setState('isMobile', window.innerWidth < 1024);\n    stateManager.setState('circles', components.circles || []);\n    stateManager.setState('settings', components.settings || {});\n    stateManager.setState('neuronGridNeedsUpdate', false);\n    stateManager.setState('canvasNeedsUpdate', false);\n    \n    // Store functions\n    if (components.updateNeuronGrid) {\n      stateManager.setState('updateNeuronGrid', components.updateNeuronGrid);\n    }\n  }\n  \n  /**\n   * Initialize the resource manager for THREE.js object management\n   */\n  initializeResourceManager() {\n    // Nothing special needed for initialization\n  }\n  \n  /**\n   * Initialize the timer manager for centralized timer handling\n   */\n  initializeTimerManager() {\n    // Nothing special needed for initialization\n  }\n  \n  /**\n   * Initialize the event manager for centralized event handling\n   */\n  initializeEventManager() {\n    // Nothing special needed for initialization\n  }\n  \n  /**\n   * Initialize the reactive manager\n   */\n  initializeReactiveManager() {\n    reactiveManager.initialize();\n  }\n  \n  /**\n   * Initialize the event system\n   */\n  initializeEventSystem() {\n    eventSystem.initialize();\n  }\n  \n  /**\n   * Set up event relay between components\n   */\n  setupEventRelay() {\n    // Neuron state changes -> Grid updates\n    stateManager.on('neuronStateChanged', () => {\n      stateManager.setState('neuronGridNeedsUpdate', true);\n    });\n    \n    // Layout changes -> UI updates\n    stateManager.on('layoutChanged', ({ isMobile }) => {\n      const uiManager = stateManager.getComponent('uiManager');\n      if (isMobile && uiManager) {\n        uiManager.updateSynthPanelMobileView();\n      }\n    });\n    \n    // Sound parameter changes -> Canvas updates\n    stateManager.on('soundParameterChanged', () => {\n      reactiveManager.markCanvasForUpdate();\n    });\n  }\n  \n  /**\n   * Set up reactive UI updates\n   */\n  setupReactiveUI() {\n    // Set up resize observer for responsive layout using reactiveManager\n    reactiveManager.observeResize(document.body, 'layout', (entries) => {\n      const isMobile = window.innerWidth < 1024;\n      if (stateManager.getState('isMobile') !== isMobile) {\n        stateManager.setState('isMobile', isMobile);\n        stateManager.dispatchEvent('layoutChanged', { isMobile });\n      }\n    });\n  }\n  \n  /**\n   * Expose managers globally for backward compatibility\n   */\n  exposeManagersGlobally() {\n    // Make managers available on window for existing code\n    window.stateManager = stateManager;\n    window.reactiveManager = reactiveManager;\n    window.timerManager = timerManager;\n    window.eventManager = eventManager;\n    window.resourceManager = resourceManager;\n  }\n  \n  /**\n   * Clean up all managers when shutting down the application\n   */\n  cleanup() {\n    // Clean up in reverse order of initialization\n    reactiveManager.cleanup();\n    eventSystem.cleanup();\n    eventManager.cleanup();\n    timerManager.cleanup();\n    resourceManager.cleanup();\n    \n    // Mark as uninitialized\n    this.initialized = false;\n  }\n}\n\n// Create a single instance to be imported by all components\nexport const appInitializer = new AppInitializer(); ","// Add right at the beginning of main.js, before any other initialization\ndocument.body.style.backgroundColor = 'transparent'; // Ensure body doesn't cover our fluid background\n\nimport * as THREE from 'three';\nimport * as Tone from 'tone';  // Add Tone import\nimport { initializeManagers, patchExistingCode } from './components/initManagers.js';\nimport { Neuron } from './components/neuron.js';  // Note the .js extension\nimport { InputManager } from './components/InputManager';\nimport { ConnectionManager } from './components/ConnectionManager';\nimport { OptimizedSoundManager } from './components/OptimizedSoundManager.js';\nimport { WorkerManager } from './components/WorkerManager.js'; // Import WorkerManager\nimport { HarmonicSystem } from './components/HarmonicSystem.js'; // Import the HarmonicSystem\nimport { UIManager } from './components/UIManager.js'; // Import the UIManager\nimport { SceneManager } from './components/SceneManager.js'; // Import the SceneManager\n\nimport soundPresets from './config/soundPresets.js'; // Import sound presets\n\nimport gsap from 'gsap';\n\n// Initialize all managers (timer, event, resource)\ninitializeManagers();\n\n// Patch existing code to use managers (optional, comment out if causing issues)\n// patchExistingCode();\n\n// Clear any existing random sound timers\nif (window.randomSoundsTimerId) {\n    clearTimeout(window.randomSoundsTimerId);\n    window.randomSoundsTimerId = null;\n}\n\n// Pre-create reusable objects\nconst vector3 = new THREE.Vector3();\nlet lastFrameTime = 0;\nconst frameInterval = 1000 / 240; // Target 240 FPS\nlet frameCount = 0; // For animation updates\n\n// Initialize SceneManager\nconst sceneManager = new SceneManager();\nwindow.sceneManager = sceneManager;\n\n// Get references to scene, camera, and renderer from SceneManager\nconst scene = sceneManager.getScene();\nconst camera = sceneManager.getCamera();\nconst renderer = sceneManager.getRenderer();\n\n// Configure scene specific settings\nscene.matrixAutoUpdate = false; // Disable automatic matrix updates\n\n// Initialize arrays\nwindow.circles = [];\n\n// Initialize UI Manager\nconst uiManager = new UIManager(scene, camera, renderer);\nwindow.uiManager = uiManager;\n\n// No longer making the panel draggable as it conflicts with CSS positioning\n// uiManager.makePaneDraggable();\n\n// Create shared geometries and materials\nconst circleGeometry = new THREE.PlaneGeometry(1.0, 1.0);\ncircleGeometry.computeBoundingSphere();\n\n// Create a larger geometry for touch/click detection (invisible)\nconst touchGeometry = new THREE.PlaneGeometry(6.0, 6.0);\ntouchGeometry.computeBoundingSphere();\n\n// Modified to use instancing - vertexColors allows customization per instance\nconst neuronMaterial = new THREE.MeshBasicMaterial({ \n    color: 0xffffff, // White base color - will be multiplied by vertex colors\n    side: THREE.FrontSide,\n    transparent: false,\n    depthTest: true,\n    depthWrite: true,\n    precision: 'lowp'\n});\n\n// Invisible material for touch detection\nconst touchMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    transparent: true,\n    opacity: 0.0,\n    side: THREE.FrontSide,\n    depthTest: false,\n    depthWrite: false\n});\n\n// Create window.settings object\nwindow.settings = {\n    // Neuron properties\n    selectedNeuron: null,\n    \n    // Connection properties\n    selectedConnection: null,\n    selectedWeight: 0.5,\n    selectedSpeed: 0.5,\n    \n    // Audio\n    volume: -6,\n    volumeNormalization: 1.0,  // Default volume normalization factor\n    \n    // Selected neuron synth parameters\n    selectedPitchDecay: 0.05,\n    selectedDetune: 0,\n    selectedNeuronVolume: 0,  // Individual neuron volume offset\n    selectedAttack: 0.002,\n    selectedDecay: 0.3,\n    selectedSustain: 0.2,     // Added sustain parameter\n    selectedRelease: 0.8,\n    selectedNote: null,       // No default frequency\n    selectedNoteIndex: null,  // No default note index\n    selectedOscillatorType: \"triangle\", // Default oscillator type\n    selectedAttackCurve: \"exponential\", // Default envelope curve\n    selectedUseSustainedTone: false,    // Toggle for sustained tones\n    \n    // Harmony controls\n    isHarmonyAnchor: false,    // Added toggle for harmony anchor\n    harmonyStrength: 0.5,      // Global harmony strength\n    harmonyDebug: false,       // Debug mode for harmony system\n    \n    // Filter parameters\n    selectedFilterType: \"lowpass\",\n    selectedFilterFrequency: 5000,\n    selectedFilterQ: 1,\n    \n    // Effect send parameters\n    selectedReverbSend: 0.2,\n    selectedDelaySend: 0.15,\n    \n    // Modulation parameters\n    selectedTremoloFreq: 4,\n    selectedTremoloDepth: 0,\n    selectedVibratoFreq: 5,\n    selectedVibratoDepth: 0,\n    \n    // Preview sound toggle\n    previewSounds: false,\n    \n    // Spatial audio toggle\n    spatialAudioEnabled: false,\n    \n    // Methods for UI interaction\n    addNeuron: (position) => {\n        const neuron = createNewNeuron(position);\n        window.circles.push(neuron);\n        scene.add(neuron);\n        return neuron;\n    },\n    masterCompressor: {\n        threshold: -18,    // Even higher threshold to catch peaks earlier\n        ratio: 2.5,        // More gentle ratio for transparent compression\n        attack: 0.02,      // Slower attack to avoid choking the transients\n        release: 0.4,      // Much longer release for smoother compression between triggers\n        knee: 20           // Very wide knee for ultra-smooth compression\n    }\n};\n\n// Add Tweakpane controls\ntry {\n    // Set fixed size for the Tweakpane panel\n    pane.element.style.width = '300px';\n    pane.element.style.maxWidth = '300px';\n    pane.element.style.minWidth = '300px';\n    \n    // Prevent scaling when sliders change\n    pane.on('change', () => {\n        pane.element.style.width = '300px';\n        pane.element.style.transform = 'none';\n    });\n    \n    // Add additional event listener to prevent panel movement during slider interaction\n    setTimeout(() => {\n        // Find all slider elements\n        const sliders = pane.element.querySelectorAll('.tp-sldv_i');\n        sliders.forEach(slider => {\n            slider.addEventListener('mousedown', (e) => {\n                e.stopPropagation(); // Prevent event from propagating to panel dragging\n            });\n            \n            slider.addEventListener('mousemove', (e) => {\n                e.stopPropagation(); // Prevent event from propagating to panel dragging\n            });\n        });\n        \n        // Also stop propagation for all inputs and controls\n        const controls = pane.element.querySelectorAll('input, button, .tp-rotv_c');\n        controls.forEach(control => {\n            control.addEventListener('mousedown', (e) => {\n                e.stopPropagation();\n            });\n        });\n    }, 200);\n    \n    // Add neuron grid visualization directly to the main pane\n    setTimeout(() => {\n        // Find the pane element\n        const paneElement = pane.element;\n        if (paneElement) {\n            // Create grid container\n            const gridContainer = document.createElement('div');\n            gridContainer.id = 'neuron-grid-container';\n            \n            // Fixed settings, no dynamic calculations\n            gridContainer.style.display = 'flex';\n            gridContainer.style.flexWrap = 'wrap';\n            gridContainer.style.padding = '0';\n            gridContainer.style.margin = '8px 0';\n            gridContainer.style.background = 'rgba(0, 0, 0, 0.2)';\n            gridContainer.style.width = '280px'; // Exactly 14 cells of 20px each\n            gridContainer.style.fontSize = '0';\n            gridContainer.style.lineHeight = '0';\n            \n            // Insert into the pane\n            paneElement.appendChild(gridContainer);\n            \n            // Define the update function\n            window.updateNeuronGrid = function() {\n                updateNeuronGridDisplay();\n            };\n            \n            // Initial update\n            updateNeuronGridDisplay();\n        }\n    }, 100);\n    \n    // Add event listeners for neuron state updates to improve synchronization\nwindow.addEventListener('neuronChargeUpdate', (event) => {\n    const { neuronId, charge, threshold, isFiring, dcInput } = event.detail;\n    \n    // Update the hover label if this is the currently hovered neuron\n    if (window.currentHoveredNeuron && \n        window.currentHoveredNeuron.neuron && \n        window.currentHoveredNeuron.neuron.id === neuronId) {\n        \n        // Get the current mouse position from the label position\n        if (uiManager.neuronHoverLabel && uiManager.neuronHoverLabel.style.display === 'block') {\n            // Extract current position and get back to original mouse coordinates\n            const currentLeft = parseInt(uiManager.neuronHoverLabel.style.left);\n            const currentTop = parseInt(uiManager.neuronHoverLabel.style.top);\n            \n            // Get the defined offsets or use defaults if not available\n            const offsetX = parseInt(uiManager.neuronHoverLabel.dataset.offsetX || 30);\n            const offsetY = parseInt(uiManager.neuronHoverLabel.dataset.offsetY || -20);\n            \n            // Calculate the original mouse position by removing the offsets\n            const originalX = currentLeft - offsetX;\n            const originalY = currentTop - offsetY;\n            \n            // Update the label with the original mouse position - let UIManager apply the offsets\n            updateNeuronHoverLabel(window.currentHoveredNeuron, originalX, originalY);\n        }\n    }\n    \n    // Only update grid on significant charge changes to avoid performance issues\n    if (charge === 0 || charge >= threshold || (charge * 100) % 10 < 0.1) {\n        requestAnimationFrame(() => {\n            if (window.updateNeuronGrid) {\n                window.updateNeuronGrid();\n            }\n        });\n    }\n});\n\n// Add event listener for neuron reset\nwindow.addEventListener('neuronReset', (event) => {\n    const { neuronId } = event.detail;\n    \n    // Update grid to reflect reset state\n    requestAnimationFrame(() => {\n        if (window.updateNeuronGrid) {\n            window.updateNeuronGrid();\n        }\n    });\n});\n\n// Function to update the neuron grid display\nfunction updateNeuronGridDisplay() {\n    const gridContainer = document.getElementById('neuron-grid-container');\n    if (!gridContainer) return;\n    \n    // Clear existing grid elements\n    while (gridContainer.firstChild) {\n        gridContainer.removeChild(gridContainer.firstChild);\n    }\n    \n    // Update grid container style\n    gridContainer.style.background = 'rgba(0, 0, 0, 0.2)';\n    gridContainer.style.border = '1px solid rgba(255, 255, 255, 0.1)';\n    gridContainer.style.borderRadius = '4px';\n    gridContainer.style.boxShadow = 'inset 0 0 5px rgba(0, 0, 0, 0.2)';\n    gridContainer.style.padding = '4px';\n    \n    // Fixed cell size of 20px, 14 per row\n    const CELL_SIZE = 20;\n    const CELLS_PER_ROW = 14;\n    \n    // Create a grid wrapper\n    const gridWrapper = document.createElement('div');\n    gridWrapper.style.display = 'flex';\n    gridWrapper.style.flexWrap = 'wrap';\n    gridWrapper.style.gap = '2px';\n    gridWrapper.style.justifyContent = 'center';\n    gridContainer.appendChild(gridWrapper);\n    \n    // Add only cells for existing neurons - no placeholders\n    window.circles.forEach((circle) => {\n        const neuronElement = document.createElement('div');\n        neuronElement.style.width = CELL_SIZE + 'px';\n        neuronElement.style.height = CELL_SIZE + 'px';\n        neuronElement.style.cursor = 'pointer';\n        neuronElement.style.margin = '0';\n        neuronElement.style.padding = '0';\n        neuronElement.style.boxSizing = 'border-box';\n        neuronElement.style.display = 'inline-block';\n        neuronElement.style.border = 'none';\n        neuronElement.style.borderRadius = '0';\n        neuronElement.style.boxShadow = 'none';\n        neuronElement.style.transition = 'transform 0.15s, box-shadow 0.15s, border 0.15s, filter 0.15s';\n        \n        // Store the neuron ID as a data attribute for easier updates\n        if (circle.neuron) {\n            neuronElement.dataset.neuronId = circle.neuron.id;\n        }\n        \n        // Calculate color based on neuron state and preset color\n        const neuron = circle.neuron;\n        if (neuron) {\n            // Get the preset color if it exists\n            const presetColor = neuron.presetColor;\n            \n            // Get firing state\n            if (neuron.isFiring) {\n                // Bright yellow when firing, regardless of preset\n                neuronElement.style.backgroundColor = '#ffff00';\n                neuronElement.style.border = '1px solid #aaaa00';\n                neuronElement.style.boxShadow = '0 0 5px rgba(255, 255, 0, 0.7)';\n                \n                // Add a tooltip showing the preset name if available\n                if (neuron.presetName) {\n                    neuronElement.title = `${neuron.presetName} (Neuron ${neuron.id}) - Firing!`;\n                } else {\n                    neuronElement.title = `Neuron ${neuron.id} - Firing!`;\n                }\n            } else if (presetColor) {\n                // Use the preset color, influenced by charge\n                const chargeValue = neuron.currentCharge || 0;\n                const r = Math.floor(presetColor.r * 255);\n                const g = Math.floor(presetColor.g * 255);\n                const b = Math.floor(presetColor.b * 255);\n                neuronElement.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;\n                \n                \n                // Add a subtle glow effect based on the preset color\n                neuronElement.style.boxShadow = `0 0 3px rgba(${r}, ${g}, ${b}, 0.8)`;\n                \n                // Add a tooltip showing the preset name\n                neuronElement.title = `${neuron.presetName} (Neuron ${neuron.id})`;\n                if (chargeValue > 0) {\n                    neuronElement.title += ` - Charging: ${Math.round(chargeValue * 100)}%`;\n                }\n                if (neuron.dcInput > 0) {\n                    neuronElement.title += ` - DC: ${neuron.dcInput.toFixed(2)}`;\n                }\n                \n                // If neuron has DC input, add a subtle pulsing animation\n                if (neuron.dcInput > 0) {\n                    neuronElement.style.animation = 'neuronPulse 2s infinite';\n                    \n                    // Create the animation if it doesn't exist yet\n                    if (!document.getElementById('neuronPulseStyle')) {\n                        const style = document.createElement('style');\n                        style.id = 'neuronPulseStyle';\n                        style.textContent = `\n                            @keyframes neuronPulse {\n                                0% { filter: brightness(1); }\n                                50% { filter: brightness(1.3); }\n                                100% { filter: brightness(1); }\n                            }\n                        `;\n                        document.head.appendChild(style);\n                    }\n                }\n            } else {\n                // Default color with charge influence\n                const chargeValue = neuron.currentCharge || 0;\n                const green = Math.floor(Math.min(0.2, chargeValue) * 255);\n                neuronElement.style.backgroundColor = `rgb(0, ${green}, 255)`;\n                neuronElement.title = `Neuron ${neuron.id}`;\n                if (chargeValue > 0) {\n                    neuronElement.title += ` - Charging: ${Math.round(chargeValue * 100)}%`;\n                }\n                if (neuron.dcInput > 0) {\n                    neuronElement.title += ` - DC: ${neuron.dcInput.toFixed(2)}`;\n                }\n                \n                // DC input animation\n                if (neuron.dcInput > 0) {\n                    neuronElement.style.animation = 'neuronPulse 2s infinite';\n                }\n            }\n        } else {\n            neuronElement.style.backgroundColor = '#0000ff'; // Default blue\n            neuronElement.title = 'Default neuron';\n        }\n        \n        // Add hover effect\n        neuronElement.addEventListener('mouseenter', () => {\n            neuronElement.style.transform = 'scale(1.2)';\n            neuronElement.style.zIndex = '10';\n            neuronElement.style.boxShadow = '0 2px 8px rgba(255, 255, 255, 0.5)';\n            neuronElement.style.border = '1px solid rgba(255, 255, 255, 0.9)';\n        });\n        \n        neuronElement.addEventListener('mouseleave', () => {\n            neuronElement.style.transform = 'scale(1)';\n            neuronElement.style.zIndex = '1';\n            neuronElement.style.boxShadow = 'none';\n            neuronElement.style.border = 'none';\n        });\n        \n        // Add click handler to select the neuron\n        neuronElement.addEventListener('click', () => {\n            if (inputManager) {\n                inputManager.selectNeuron(circle);\n            }\n        });\n        \n        gridWrapper.appendChild(neuronElement);\n    });\n}\n\n    // Make sure to export the function to the global window object\n    window.updateNeuronGrid = updateNeuronGridDisplay;\n\n    // Remove the volume control - as requested\n    // const volumeControl = pane.addBinding(window.settings, 'volume', {\n    //     min: -48,\n    //     max: 6,\n    //     step: 1,\n    //     label: 'Volume (dB)'\n    // }).on('change', (ev) => {\n    //     if (window.soundManager) {\n    //         window.soundManager.setVolume(ev.value);\n    //     }\n    // });\n\n    // Weight and Speed controls removed as requested\n\n    // Store references to the control elements for toggling visibility\n    // Wait a moment to ensure the DOM is fully processed\n    setTimeout(() => {\n        // Find the parent elements for each control - going up to the container level\n        const findControlContainer = (control) => {\n            if (!control || !control.element) return null;\n            \n            // The actual controller is the first parent\n            const controller = control.element.parentElement;\n            if (!controller) return null;\n            \n            // The container is the next parent level\n            return controller.parentElement;\n        };\n        \n        // All controls are removed as requested\n        window.globalControls = {};\n        \n        console.log(\"Global controls initialized:\", window.globalControls);\n    }, 100);\n\n    // Connection update logic and controls removed as requested\n\n    // --- Add Selected Neuron Synth Parameters ---\n    const selectedSynthFolder = pane.addFolder({\n        title: 'Sound Controls',\n        expanded: true // Start expanded when visible\n    });\n    \n    // Master Compressor removed as requested\n    \n    // Set initial display state - hidden until a neuron is selected\n    selectedSynthFolder.element.style.display = 'none'; \n    \n    // Immediately make it available globally\n    window.selectedSynthFolder = selectedSynthFolder;\n    console.log(\"Sound controls folder created and assigned to global variable\");\n    \n    // Function to handle display of the synth folder based on device type\n    window.updateSynthFolderDisplay = function() {\n        const screenWidth = window.innerWidth;\n        const isDesktop = screenWidth >= 1024;\n        \n        if (isDesktop) {\n            // On desktop, always show the folder, but only enable controls when a neuron is selected\n            if (selectedSynthFolder && selectedSynthFolder.element) {\n                selectedSynthFolder.element.style.display = 'block';\n                \n                // Remove any placeholder messages that might exist\n                    const placeholderMsg = document.getElementById('synth-placeholder-msg');\n                    if (placeholderMsg) {\n                        placeholderMsg.remove();\n                }\n            }\n        } else {\n            // On mobile, only show when a neuron is explicitly selected\n            if (selectedSynthFolder && selectedSynthFolder.element) {\n                selectedSynthFolder.element.style.display = \n                    window.soundManager?.selectedNeuronId ? 'block' : 'none';\n            }\n        }\n        \n        // Update neuron label position after changing synth folder visibility\n        if (window.updateNeuronLabelPosition) {\n            window.updateNeuronLabelPosition();\n        }\n    };\n    \n    // Call immediately and set up for changes\n    setTimeout(window.updateSynthFolderDisplay, 100);\n    window.addEventListener('resize', window.updateSynthFolderDisplay);\n    \n    // Make sure the folder's internal content is properly initialized\n    setTimeout(() => {\n        // Ensure the folder is properly initialized\n        if (selectedSynthFolder && selectedSynthFolder.element) {\n            // Force the internal structure to be created even though it's hidden\n            const tempDisplay = selectedSynthFolder.element.style.display;\n            selectedSynthFolder.element.style.display = 'block';\n            // Give it a moment to render\n            setTimeout(() => {\n                // Reset to appropriate display state\n                window.updateSynthFolderDisplay();\n                console.log(\"Sound controls panel initialized\");\n            }, 10);\n        }\n    }, 100);\n    \n    // Define musical notes with frequencies\n    const musicalNotes = [\n        // Lower octave (C2 to B2)\n        { name: \"C2\", freq: 65.41 },\n        { name: \"D2\", freq: 73.42 },\n        { name: \"E2\", freq: 82.41 },\n        { name: \"F2\", freq: 87.31 },\n        { name: \"G2\", freq: 98.00 },\n        { name: \"A2\", freq: 110.00 },\n        { name: \"B2\", freq: 123.47 },\n        // Middle octave (C3 to B3)\n        { name: \"C3\", freq: 130.81 },\n        { name: \"D3\", freq: 146.83 },\n        { name: \"E3\", freq: 164.81 },\n        { name: \"F3\", freq: 174.61 },\n        { name: \"G3\", freq: 196.00 },\n        { name: \"A3\", freq: 220.00 },\n        { name: \"B3\", freq: 246.94 },\n        // Higher octave (C4 to B4)\n        { name: \"C4\", freq: 261.63 },\n        { name: \"D4\", freq: 293.66 },\n        { name: \"E4\", freq: 329.63 },\n        { name: \"F4\", freq: 349.23 },\n        { name: \"G4\", freq: 392.00 },\n        { name: \"A4\", freq: 440.00 },\n        { name: \"B4\", freq: 493.88 },\n        // Even higher octave (C5 to B5)\n        { name: \"C5\", freq: 523.25 },\n        { name: \"D5\", freq: 587.33 },\n        { name: \"E5\", freq: 659.25 },\n        { name: \"F5\", freq: 698.46 },\n        { name: \"G5\", freq: 783.99 },\n        { name: \"A5\", freq: 880.00 },\n        { name: \"B5\", freq: 987.77 },\n        // Highest octave (C6 to B6)\n        { name: \"C6\", freq: 1046.50 },\n        { name: \"D6\", freq: 1174.66 },\n        { name: \"E6\", freq: 1318.51 },\n        { name: \"F6\", freq: 1396.91 },\n        { name: \"G6\", freq: 1567.98 },\n        { name: \"A6\", freq: 1760.00 },\n        { name: \"B6\", freq: 1975.53 }\n    ];\n    \n    // Make musicalNotes available globally for other functions\n    window.musicalNotes = musicalNotes;\n    \n    // Create buttons for musical note selection with 8-bit styling\n    const noteSelectionContainer = document.createElement('div');\n    noteSelectionContainer.style.marginBottom = '10px';\n    noteSelectionContainer.style.marginLeft = 'auto';\n    noteSelectionContainer.style.marginRight = 'auto';\n    noteSelectionContainer.style.padding = '5px'; // Reduced padding to fit better\n    noteSelectionContainer.style.backgroundColor = '#000000'; // Black background for classic 8-bit look\n    noteSelectionContainer.style.borderRadius = '0'; // Square corners for 8-bit aesthetic\n    noteSelectionContainer.style.display = 'flex';\n    noteSelectionContainer.style.flexDirection = 'column';\n    noteSelectionContainer.style.gap = '0'; // Removed gap to tighten space\n    noteSelectionContainer.style.border = '2px solid #444444'; // Grey border\n    noteSelectionContainer.style.boxShadow = '0 0 0 1px #000000, 0 0 0 4px #222222'; // Pixel-perfect border\n    noteSelectionContainer.style.width = '286px'; // Match Tweakpane width (300px - 14px for margins/padding)\n    noteSelectionContainer.style.boxSizing = 'border-box'; // Include padding in width calculation\n    noteSelectionContainer.style.alignSelf = 'center'; // Center in parent container\n    \n    // Create note buttons container with exactly 3 rows of buttons\n    const noteButtonsContainer = document.createElement('div');\n    noteButtonsContainer.style.display = 'grid';\n    noteButtonsContainer.style.gridTemplateRows = 'repeat(3, 1fr)'; // Exactly 3 rows\n    noteButtonsContainer.style.gridTemplateColumns = 'repeat(12, 1fr)'; // 12 columns per row\n    noteButtonsContainer.style.gap = '1px'; // Minimal gap for dense layout\n    noteButtonsContainer.style.backgroundColor = '#111111'; // Darker background behind buttons\n    noteButtonsContainer.style.padding = '3px'; // Padding around button grid\n    noteButtonsContainer.style.border = '1px solid #333333'; // Inner border\n    noteButtonsContainer.style.width = '100%'; // Use full width\n    noteButtonsContainer.style.height = '76px'; // Fixed height for all 3 rows\n    noteButtonsContainer.style.boxSizing = 'border-box'; // Include border in size calculation\n    noteButtonsContainer.style.overflow = 'hidden'; // Hide any overflow\n    noteSelectionContainer.appendChild(noteButtonsContainer);\n    \n    // Keep track of active note button\n    let activeNoteButton = null;\n    \n    // Function to create note buttons\n    function createNoteButton(note, index) {\n        const button = document.createElement('button');\n        button.textContent = note.name;\n        button.dataset.noteIndex = index;\n        button.dataset.frequency = note.freq;\n        button.style.padding = '1px 0'; // Minimal padding\n        button.style.fontSize = '5px'; // Smaller font size to ensure fitting\n        button.style.fontFamily = \"'Press Start 2P', monospace\"; // 8-bit style font\n        button.style.color = '#FFFFFF'; // White text for all buttons for better contrast with grey\n        button.style.textShadow = '0px 0px 1px #000000'; // Subtle text shadow for better readability\n        button.style.borderRadius = '0'; // Square corners for 8-bit look\n        button.style.cursor = 'pointer';\n        button.style.transition = 'all 0.15s ease';\n        button.style.position = 'relative'; // For scanline effect\n        button.style.margin = '0'; // No margin for tighter fit\n        button.style.textAlign = 'center';\n        button.style.boxShadow = 'inset 0 0 2px rgba(255, 255, 255, 0.3)';\n        button.style.width = '100%'; // Fill the grid cell completely\n        button.style.minWidth = '0'; // Allow very narrow buttons\n        button.style.height = '23px'; // Fixed height for each row (70px ÷ 3)\n        button.style.lineHeight = '1'; // Tighter line height\n        button.style.overflow = 'hidden'; // Prevent text overflow\n        button.style.boxSizing = 'border-box'; // Include border in size calculation\n        \n        // Color-code different octaves with shades of grey for 8-bit look\n        const octave = parseInt(note.name.match(/\\d+/)[0]);\n        \n        // Apply different shades of grey based on octave\n        let bgColor, borderColorTop, borderColorBottom;\n        \n        if (octave <= 1) {\n            // Darkest grey for lowest octave\n            bgColor = '#3A3A3A'; \n            borderColorTop = '#505050';\n            borderColorBottom = '#252525';\n        } else if (octave === 2) {\n            // Dark grey for low octave\n            bgColor = '#454545'; \n            borderColorTop = '#5A5A5A';\n            borderColorBottom = '#303030';\n        } else if (octave === 3) {\n            // Medium grey for mid-low octave\n            bgColor = '#505050'; \n            borderColorTop = '#656565';\n            borderColorBottom = '#3A3A3A';\n        } else if (octave === 4) {\n            // Light-medium grey for mid octave\n            bgColor = '#606060'; \n            borderColorTop = '#757575';\n            borderColorBottom = '#454545';\n        } else if (octave === 5) {\n            // Light grey for high octave\n            bgColor = '#707070'; \n            borderColorTop = '#858585';\n            borderColorBottom = '#555555';\n        } else if (octave >= 6) {\n            // Lightest grey for highest octave\n            bgColor = '#808080'; \n            borderColorTop = '#959595';\n            borderColorBottom = '#656565';\n        }\n        \n        // Highlight black keys (sharps/flats) with different color\n        if (note.name.includes('#') || (note.name.length > 2 && note.name[1] === 'b')) {\n            bgColor = '#202020';\n            borderColorTop = '#3A3A3A';\n            borderColorBottom = '#101010';\n            button.style.color = '#FFFFFF';\n        }\n        \n        // Apply the colors\n        button.style.backgroundColor = bgColor;\n        button.style.borderTop = `2px solid ${borderColorTop}`;\n        button.style.borderLeft = `2px solid ${borderColorTop}`;\n        button.style.borderBottom = `2px solid ${borderColorBottom}`;\n        button.style.borderRight = `2px solid ${borderColorBottom}`;\n        \n        // Store original styles for hover/active effects\n        button.dataset.original = bgColor;\n        button.dataset.originalBorderTop = borderColorTop;\n        button.dataset.originalBorderBottom = borderColorBottom;\n        \n        // Add click event to select the note - ensure it works with one tap\n        button.addEventListener('click', (e) => {\n            e.preventDefault(); // Prevent any default behavior\n            e.stopPropagation(); // Stop event propagation\n            \n            // Update the note setting immediately\n            window.settings.selectedNote = note.freq;\n            window.settings.selectedNoteIndex = index;\n            \n            // Update sound manager without playing a test tone immediately\n            if (window.soundManager) {\n                window.soundManager.updateSelectedSynthParam('note', note.freq);\n                // Do not play a test tone automatically\n            }\n            \n            // Visual feedback - deactivate previous button\n            if (activeNoteButton) {\n                // Restore original 8-bit styles\n                activeNoteButton.style.backgroundColor = activeNoteButton.dataset.original || '#404040';\n                activeNoteButton.style.borderTop = `2px solid ${activeNoteButton.dataset.originalBorderTop || '#505050'}`;\n                activeNoteButton.style.borderLeft = `2px solid ${activeNoteButton.dataset.originalBorderTop || '#505050'}`;\n                activeNoteButton.style.borderBottom = `2px solid ${activeNoteButton.dataset.originalBorderBottom || '#303030'}`;\n                activeNoteButton.style.borderRight = `2px solid ${activeNoteButton.dataset.originalBorderBottom || '#303030'}`;\n                activeNoteButton.style.transform = 'scale(1)';\n                activeNoteButton.style.boxShadow = 'inset 0 0 2px rgba(255, 255, 255, 0.3)';\n                activeNoteButton.style.fontWeight = 'normal';\n                activeNoteButton.style.color = 'white';\n            }\n            \n            // Activate this button with a darker shade of the note's original color\n            // Get original color and create darker version\n            const originalColor = button.dataset.original;\n            \n            // Function to darken color\n            const getDarkerButtonColor = (color) => {\n                if (color.startsWith('#')) {\n                    const hex = color.replace('#', '');\n                    let r = parseInt(hex.substring(0, 2), 16);\n                    let g = parseInt(hex.substring(2, 4), 16);\n                    let b = parseInt(hex.substring(4, 6), 16);\n                    \n                    // Make significantly darker (40% of original brightness)\n                    r = Math.floor(r * 0.4);\n                    g = Math.floor(g * 0.4);\n                    b = Math.floor(b * 0.4);\n                    \n                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n                }\n                return '#222222'; // Fallback dark color\n            };\n            \n            const darkColor = getDarkerButtonColor(originalColor);\n            const veryDarkColor = getDarkerButtonColor(darkColor); // Even darker for borders\n            \n            // Apply the darker color\n            button.style.backgroundColor = darkColor;\n            button.style.color = '#FFFFFF'; // White text for contrast on dark background\n            button.style.borderTop = `2px solid ${veryDarkColor}`;       // Darker top/left for pressed effect\n            button.style.borderLeft = `2px solid ${veryDarkColor}`;\n            button.style.borderBottom = `2px solid ${darkColor}`;        // Same color for bottom/right\n            button.style.borderRight = `2px solid ${darkColor}`;\n            button.style.transform = 'scale(0.95)';                      // Slightly smaller for pressed effect\n            button.style.boxShadow = 'inset 0 0 5px rgba(0, 0, 0, 0.7)'; // Dark inner shadow\n            button.style.fontWeight = 'bold';                            // Make selected note text bold\n            \n            // Add active pixel scanlines\n            if (!button.scanlines) {\n                const scanlines = document.createElement('div');\n                scanlines.style.position = 'absolute';\n                scanlines.style.top = '0';\n                scanlines.style.left = '0';\n                scanlines.style.width = '100%';\n                scanlines.style.height = '100%';\n                scanlines.style.backgroundImage = 'repeating-linear-gradient(0deg, rgba(0,0,0,0.2), rgba(0,0,0,0.2) 1px, transparent 1px, transparent 2px)';\n                scanlines.style.pointerEvents = 'none';\n                scanlines.style.zIndex = '1';\n                button.appendChild(scanlines);\n                button.scanlines = scanlines;\n            }\n            \n            activeNoteButton = button;\n            window.activeNoteButton = button; // Sync with global reference\n            \n            console.log(`Note changed to: ${note.name} (${note.freq}Hz)`);\n            \n            // Return false to prevent any issues with event handling\n            return false;\n        });\n        \n        // Also add touchend handler for mobile devices to ensure one-tap functionality\n        button.addEventListener('touchend', (e) => {\n            e.preventDefault(); // Prevent any default behavior\n            \n            // Trigger the click event manually\n            button.click();\n            \n            // Return false to prevent any issues with event handling\n            return false;\n        });\n        \n        // Add 8-bit style hover effects\n        button.addEventListener('mouseenter', () => {\n            if (button !== activeNoteButton) {\n                // Brighten colors for hover effect but keep 8-bit style\n                // Create lighter version of original color\n                const brightenColor = (color) => {\n                    // Basic implementation to make a hex color brighter\n                    if (color.startsWith('#')) {\n                        const r = parseInt(color.slice(1, 3), 16);\n                        const g = parseInt(color.slice(3, 5), 16);\n                        const b = parseInt(color.slice(5, 7), 16);\n                        \n                        // Brighten by 30%\n                        const brighterR = Math.min(255, r + 50).toString(16).padStart(2, '0');\n                        const brighterG = Math.min(255, g + 50).toString(16).padStart(2, '0');\n                        const brighterB = Math.min(255, b + 50).toString(16).padStart(2, '0');\n                        \n                        return `#${brighterR}${brighterG}${brighterB}`;\n                    }\n                    return color; // Fallback\n                };\n                \n                // Brighten the button with pixelated glow\n                const brighterBg = brightenColor(button.dataset.original);\n                button.style.backgroundColor = brighterBg;\n                button.style.boxShadow = 'inset 0 0 4px rgba(255, 255, 255, 0.5)';\n                button.style.borderTop = `2px solid ${brightenColor(button.dataset.originalBorderTop)}`;\n                button.style.borderLeft = `2px solid ${brightenColor(button.dataset.originalBorderTop)}`;\n                \n                // Add subtle pulse animation\n                button.style.animation = 'noteButtonPulse 1.5s infinite';\n                \n                // Create animation if it doesn't exist yet\n                if (!document.getElementById('noteButtonPulseStyle')) {\n                    const style = document.createElement('style');\n                    style.id = 'noteButtonPulseStyle';\n                    style.textContent = `\n                        @keyframes noteButtonPulse {\n                            0% { transform: scale(1); }\n                            50% { transform: scale(1.05); }\n                            100% { transform: scale(1); }\n                        }\n                    `;\n                    document.head.appendChild(style);\n                }\n            }\n        });\n        \n        button.addEventListener('mouseleave', () => {\n            if (button !== activeNoteButton) {\n                // Reset to original 8-bit styling\n                button.style.backgroundColor = button.dataset.original;\n                button.style.borderTop = `2px solid ${button.dataset.originalBorderTop}`;\n                button.style.borderLeft = `2px solid ${button.dataset.originalBorderTop}`;\n                button.style.borderBottom = `2px solid ${button.dataset.originalBorderBottom}`;\n                button.style.borderRight = `2px solid ${button.dataset.originalBorderBottom}`;\n                button.style.boxShadow = 'inset 0 0 2px rgba(255, 255, 255, 0.3)';\n                button.style.animation = 'none';\n                button.style.transform = 'scale(1)';\n            }\n        });\n        \n        return button;\n    }\n    \n    // Organize notes into exactly 3 rows with notes spread across columns\n    \n    // Calculate number of notes per row (36 notes total ÷ 3 rows = 12 notes per row)\n    const notesPerRow = Math.ceil(musicalNotes.length / 3);\n    \n    // Create 3 rows of notes\n    const rowGroups = [\n        musicalNotes.slice(0, notesPerRow),          // Row 1: Lowest third (C2-G3)\n        musicalNotes.slice(notesPerRow, notesPerRow * 2),   // Row 2: Middle third (A3-E5)\n        musicalNotes.slice(notesPerRow * 2)          // Row 3: Highest third (F5-B6)\n    ];\n    \n    // Add notes row by row (each row will have multiple columns)\n    rowGroups.forEach((rowNotes, rowIndex) => {\n        rowNotes.forEach((note, noteIndex) => {\n            const overallIndex = rowIndex * notesPerRow + noteIndex;\n            const button = createNoteButton(note, overallIndex);\n        noteButtonsContainer.appendChild(button);\n        });\n    });\n    \n    // Function to update the active note button styling with 8-bit aesthetics\n    window.updateActiveNoteButton = function(noteFreq) {\n        // Find the button with the matching frequency\n        const buttons = noteButtonsContainer.querySelectorAll('button');\n        \n        // First deactivate any currently active button\n        if (activeNoteButton) {\n            // Restore original 8-bit styles\n            activeNoteButton.style.backgroundColor = activeNoteButton.dataset.original || '#404040';\n            activeNoteButton.style.borderTop = `2px solid ${activeNoteButton.dataset.originalBorderTop || '#505050'}`;\n            activeNoteButton.style.borderLeft = `2px solid ${activeNoteButton.dataset.originalBorderTop || '#505050'}`;\n            activeNoteButton.style.borderBottom = `2px solid ${activeNoteButton.dataset.originalBorderBottom || '#303030'}`;\n            activeNoteButton.style.borderRight = `2px solid ${activeNoteButton.dataset.originalBorderBottom || '#303030'}`;\n            activeNoteButton.style.transform = 'scale(1)';\n            activeNoteButton.style.boxShadow = 'inset 0 0 2px rgba(255, 255, 255, 0.3)';\n            activeNoteButton.style.fontWeight = 'normal';\n            activeNoteButton.style.color = 'white';\n            \n            // Remove scanlines if they exist\n            if (activeNoteButton.scanlines) {\n                activeNoteButton.scanlines.remove();\n                activeNoteButton.scanlines = null;\n            }\n            \n            activeNoteButton = null;\n            window.activeNoteButton = null; // Sync with global reference\n        }\n        \n        // Only activate a button if a valid frequency is provided\n        if (noteFreq) {\n        // Find and activate the button for the current note\n        buttons.forEach(button => {\n            const buttonFreq = parseFloat(button.dataset.frequency);\n            if (Math.abs(buttonFreq - noteFreq) < 0.1) {\n                    // Apply darker shade of note's original color for active styling\n                    const originalColor = button.dataset.original;\n                    \n                    // Function to darken color\n                    const getDarkerButtonColor = (color) => {\n                        if (color.startsWith('#')) {\n                            const hex = color.replace('#', '');\n                            let r = parseInt(hex.substring(0, 2), 16);\n                            let g = parseInt(hex.substring(2, 4), 16);\n                            let b = parseInt(hex.substring(4, 6), 16);\n                            \n                            // Make significantly darker (40% of original brightness)\n                            r = Math.floor(r * 0.4);\n                            g = Math.floor(g * 0.4);\n                            b = Math.floor(b * 0.4);\n                            \n                            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n                        }\n                        return '#222222'; // Fallback dark color\n                    };\n                    \n                    const darkColor = getDarkerButtonColor(originalColor);\n                    const veryDarkColor = getDarkerButtonColor(darkColor); // Even darker for borders\n                    \n                    // Apply the darker color\n                    button.style.backgroundColor = darkColor;\n                    button.style.color = '#FFFFFF'; // White text for contrast on dark background\n                    button.style.borderTop = `2px solid ${veryDarkColor}`;       // Darker top/left for pressed effect\n                    button.style.borderLeft = `2px solid ${veryDarkColor}`;\n                    button.style.borderBottom = `2px solid ${darkColor}`;        // Same color for bottom/right\n                    button.style.borderRight = `2px solid ${darkColor}`;\n                    button.style.transform = 'scale(0.95)';                      // Slightly smaller for pressed effect\n                    button.style.boxShadow = 'inset 0 0 5px rgba(0, 0, 0, 0.7)'; // Dark inner shadow\n                button.style.fontWeight = 'bold';\n                    \n                    // Add scanlines for 8-bit effect\n                    if (!button.scanlines) {\n                        const scanlines = document.createElement('div');\n                        scanlines.style.position = 'absolute';\n                        scanlines.style.top = '0';\n                        scanlines.style.left = '0';\n                        scanlines.style.width = '100%';\n                        scanlines.style.height = '100%';\n                        scanlines.style.backgroundImage = 'repeating-linear-gradient(0deg, rgba(0,0,0,0.2), rgba(0,0,0,0.2) 1px, transparent 1px, transparent 2px)';\n                        scanlines.style.pointerEvents = 'none';\n                        scanlines.style.zIndex = '1';\n                        button.appendChild(scanlines);\n                        button.scanlines = scanlines;\n                    }\n                    \n                activeNoteButton = button;\n                    window.activeNoteButton = button; // Sync with global reference\n            }\n        });\n        }\n    };\n    \n    // Add to sound controls folder at the top with proper alignment\n    selectedSynthFolder.element.insertBefore(noteSelectionContainer, selectedSynthFolder.element.firstChild);\n    \n    // Ensure the container is properly centered within the folder\n    const containerParent = noteSelectionContainer.parentElement;\n    if (containerParent) {\n        containerParent.style.display = 'flex';\n        containerParent.style.flexDirection = 'column';\n        containerParent.style.alignItems = 'center';\n    }\n    \n    // We'll add preset container right after the notes for better usability\n    // Create preset controls now so we can insert them below notes\n    const presetContainer = document.createElement('div');\n    presetContainer.style.marginTop = '10px';\n    presetContainer.style.marginLeft = 'auto';\n    presetContainer.style.marginRight = 'auto';\n    presetContainer.style.padding = '8px';\n    presetContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';\n    presetContainer.style.borderRadius = '6px';\n    presetContainer.style.display = 'flex';\n    presetContainer.style.flexDirection = 'column';\n    presetContainer.style.gap = '8px';\n    presetContainer.className = 'preset-container'; // Add class for identification\n    presetContainer.style.boxShadow = 'inset 0 0 5px rgba(0, 0, 0, 0.2)';\n    presetContainer.style.border = '1px solid rgba(255, 255, 255, 0.1)';\n    presetContainer.style.width = '286px'; // Match the width of the note container\n    presetContainer.style.boxSizing = 'border-box'; // Include padding in width calculation\n    \n    // Add the preset container right after the note selection container\n    selectedSynthFolder.element.insertBefore(presetContainer, noteSelectionContainer.nextSibling);\n    \n    // No header needed for presets - keeping UI clean\n\n    // Create button grid container with improved layout\n    const presetButtonGrid = document.createElement('div');\n    presetButtonGrid.style.display = 'grid';\n    presetButtonGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';\n    presetButtonGrid.style.gap = '12px'; // Increased from 6px to 12px for more space between buttons\n    presetButtonGrid.style.padding = '4px';  // Slightly more padding\n    presetButtonGrid.style.borderRadius = '4px';\n    presetButtonGrid.className = 'preset-button-grid'; // Add class for easy selection\n    presetContainer.appendChild(presetButtonGrid);\n\n    // Track which preset is active\n    let activePresetButton = null;\n    \n    // We'll remove the slider since the buttons are sufficient and we want more space\n    // Instead, directly update the window.settings.selectedNoteIndex in the button click handlers\n    // This is already handled in the createNoteButton function\n    \n    // Create tabs for better organization of sound controls\n    const soundTabs = selectedSynthFolder.addTab({\n        pages: [\n            {title: 'Sound'},\n            {title: 'Filter'},\n            {title: 'FX Sends'},\n            {title: 'Modulation'}\n        ]\n    });\n    \n    // Store references to the tabs for refreshing later\n    window.soundControlsTabs = soundTabs;\n    \n    // ---- SOUND PARAMETERS TAB ----\n    // Add detune control\n    soundTabs.pages[0].addBinding(window.settings, 'selectedDetune', {\n        min: -50, max: 50, step: 1, label: 'Detune'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('detune', ev.value);\n    });\n\n    // Add neuron-specific volume control\n    soundTabs.pages[0].addBinding(window.settings, 'selectedNeuronVolume', {\n        min: -12, max: 12, step: 1, label: 'Volume (min=mute)'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('neuronVolume', ev.value);\n    });\n\n    // Create oscillator type dropdown\n    if (window.soundManager && window.soundManager.getOscillatorTypes) {\n        const oscillatorTypes = window.soundManager.getOscillatorTypes();\n        soundTabs.pages[0].addBinding(window.settings, 'selectedOscillatorType', {\n            options: oscillatorTypes.reduce((acc, type) => {\n                acc[type] = type;\n                return acc;\n            }, {}),\n            label: 'Oscillator Type'\n        }).on('change', (ev) => {\n            window.soundManager?.updateSelectedSynthParam('oscillatorType', ev.value);\n        });\n    }\n\n    // Add attack parameter control\n    soundTabs.pages[0].addBinding(window.settings, 'selectedAttack', {\n        min: 0.001, max: 0.5, step: 0.005, label: 'Attack'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('attack', ev.value);\n        window.forceRenderEnvelope(); // Update envelope visualization\n    });\n\n    soundTabs.pages[0].addBinding(window.settings, 'selectedDecay', {\n        min: 0.1, max: 1.5, step: 0.05, label: 'Decay'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('decay', ev.value);\n        window.forceRenderEnvelope(); // Update envelope visualization\n    });\n\n    // Add sustain parameter\n    soundTabs.pages[0].addBinding(window.settings, 'selectedSustain', {\n        min: 0, max: 1.0, step: 0.05, label: 'Sustain'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('sustain', ev.value);\n        window.forceRenderEnvelope(); // Update envelope visualization\n    });\n\n    soundTabs.pages[0].addBinding(window.settings, 'selectedRelease', {\n        min: 0.2, max: 3.0, step: 0.1, label: 'Release'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('release', ev.value);\n        window.forceRenderEnvelope(); // Update envelope visualization\n    });\n\n    // Add envelope curve selector if available\n    if (window.soundManager && window.soundManager.getEnvelopeCurves) {\n        const curves = window.soundManager.getEnvelopeCurves();\n        const curveOptions = curves.reduce((acc, curve) => {\n            acc[curve] = curve;\n            return acc;\n        }, {});\n        \n        soundTabs.pages[0].addBinding(window.settings, 'selectedAttackCurve', {\n            options: curveOptions,\n            label: 'Curve Shape'\n        }).on('change', (ev) => {\n            window.soundManager?.updateSelectedSynthParam('attackCurve', ev.value);\n            window.soundManager?.updateSelectedSynthParam('decayCurve', ev.value);\n            window.soundManager?.updateSelectedSynthParam('releaseCurve', ev.value);\n        });\n    }\n\n    // Add pitch decay control\n    soundTabs.pages[0].addBinding(window.settings, 'selectedPitchDecay', {\n        min: 0.01, max: 0.3, step: 0.01, label: 'Pitch Decay'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('pitchDecay', ev.value);\n    });\n\n    // Add sustained tone toggle\n    soundTabs.pages[0].addBinding(window.settings, 'selectedUseSustainedTone', {\n        label: 'Sustain Mode'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('useSustainedTone', ev.value);\n    });\n\n    // Add harmony anchor control\n    soundTabs.pages[0].addBinding(window.settings, 'isHarmonyAnchor', {\n        label: 'Harmony Anchor'\n    }).on('change', (ev) => {\n        // Find selected neuron and update its harmony anchor status\n        if (window.soundManager && window.soundManager.selectedNeuronId !== null) {\n            const selectedNeuronId = window.soundManager.selectedNeuronId;\n            const selectedNeuron = window.circles.find(\n                circle => circle && circle.neuron && circle.neuron.id === selectedNeuronId\n            );\n            \n            if (selectedNeuron && selectedNeuron.neuron) {\n                selectedNeuron.neuron.isHarmonyAnchor = ev.value;\n                console.log(`Set neuron ${selectedNeuronId} as harmony anchor: ${ev.value}`);\n                \n                // Visual indicator for harmony anchors\n                if (ev.value) {\n                    // Create a visual indicator for harmony anchors\n                    if (!selectedNeuron.harmonyAnchorIndicator) {\n                        const indicatorGeometry = new THREE.RingGeometry(0.3, 0.35, 16);\n                        const indicatorMaterial = new THREE.MeshBasicMaterial({\n                            color: 0xffff00,\n                            transparent: true,\n                            opacity: 0.5,\n                            side: THREE.DoubleSide\n                        });\n                        \n                        const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);\n                        indicator.rotation.x = -Math.PI / 2;\n                        indicator.position.copy(selectedNeuron.position);\n                        indicator.position.y += 0.05; // Slightly above the neuron\n                        \n                        // Store reference and add to scene\n                        selectedNeuron.harmonyAnchorIndicator = indicator;\n                        window.scene.add(indicator);\n                    } else {\n                        // Show existing indicator\n                        selectedNeuron.harmonyAnchorIndicator.visible = true;\n                    }\n                } else if (selectedNeuron.harmonyAnchorIndicator) {\n                    // Hide indicator when toggled off\n                    selectedNeuron.harmonyAnchorIndicator.visible = false;\n                }\n            }\n        }\n    });\n\n    // ---- FILTER CONTROLS TAB ----\n    // Add filter type dropdown\n    if (window.soundManager && window.soundManager.getFilterTypes) {\n        const filterTypes = window.soundManager.getFilterTypes();\n        soundTabs.pages[1].addBinding(window.settings, 'selectedFilterType', {\n            options: filterTypes.reduce((acc, type) => {\n                acc[type] = type;\n                return acc;\n            }, {}),\n            label: 'Filter Type'\n        }).on('change', (ev) => {\n            window.soundManager?.updateSelectedSynthParam('filterType', ev.value);\n            // Do not play a test tone automatically\n        });\n    }\n    \n    // Add filter frequency control\n    soundTabs.pages[1].addBinding(window.settings, 'selectedFilterFrequency', {\n        min: 50, max: 10000, step: 10, label: 'Frequency'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('filterFrequency', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // Add filter resonance (Q) control\n    soundTabs.pages[1].addBinding(window.settings, 'selectedFilterQ', {\n        min: 0.1, max: 10, step: 0.1, label: 'Resonance (Q)'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('filterQ', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // ---- EFFECTS SEND TAB ----\n    // Add reverb send control\n    soundTabs.pages[2].addBinding(window.settings, 'selectedReverbSend', {\n        min: 0, max: 1, step: 0.01, label: 'Reverb'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('reverbSend', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // Add delay send control\n    soundTabs.pages[2].addBinding(window.settings, 'selectedDelaySend', {\n        min: 0, max: 1, step: 0.01, label: 'Delay'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('delaySend', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // ---- MODULATION TAB ----\n    // Add tremolo frequency control\n    soundTabs.pages[3].addBinding(window.settings, 'selectedTremoloFreq', {\n        min: 0.1, max: 10, step: 0.1, label: 'Tremolo Rate'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('tremoloFreq', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // Add tremolo depth control\n    soundTabs.pages[3].addBinding(window.settings, 'selectedTremoloDepth', {\n        min: 0, max: 1, step: 0.01, label: 'Tremolo Depth'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('tremoloDepth', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // Add vibrato frequency control\n    soundTabs.pages[3].addBinding(window.settings, 'selectedVibratoFreq', {\n        min: 0.1, max: 10, step: 0.1, label: 'Vibrato Rate'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('vibratoFreq', ev.value);\n        // Do not play a test tone automatically\n    });\n    \n    // Add vibrato depth control\n    soundTabs.pages[3].addBinding(window.settings, 'selectedVibratoDepth', {\n        min: 0, max: 1, step: 0.01, label: 'Vibrato Depth'\n    }).on('change', (ev) => {\n        window.soundManager?.updateSelectedSynthParam('vibratoDepth', ev.value);\n        // Do not play a test tone automatically\n    });\n\n    // Add toggle for preview sounds when adjusting parameters\n    selectedSynthFolder.addBinding(window.settings, 'previewSounds', {\n        label: 'Solo + Preview'\n    }).on('change', (ev) => {\n        if (window.soundManager) {\n            window.soundManager.setPreviewSounds(ev.value);\n        }\n    });\n\n    // Add toggle for spatial audio\n    selectedSynthFolder.addBinding(window.settings, 'spatialAudioEnabled', {\n        label: 'Spatial Audio'\n    }).on('change', (ev) => {\n        if (window.soundManager) {\n            window.soundManager.setSpatialAudio(ev.value);\n        }\n    });\n\n    // Preset container, header, grid, and related components already created earlier\n\n    // Use sound presets imported from config\n    const defaultPresets = soundPresets;\n\n    // Make presets available globally for preset detection\n    window.defaultPresets = defaultPresets;\n\n    // Function to create a preset button\n    function createPresetButton(preset) {\n        const button = document.createElement('button');\n        button.textContent = preset.name;\n        button.style.padding = '5px 6px';  // Reduced padding\n        button.style.fontSize = '8px';     // Slightly larger font for better visibility\n        button.style.fontFamily = \"'Press Start 2P', 'Courier New', monospace\"; // Keep the retro font\n        button.style.textTransform = 'uppercase';\n        button.style.letterSpacing = '0.5px';\n        button.style.fontWeight = 'bold'; // Make text bold\n        \n        // Default settings - will be overridden based on sound type\n        let backgroundColor = '#666666';  // Changed to use stroke color as background\n        let borderColor = '#333333';      // Darker border\n        let textColor = '#000000';        // Black text for contrast\n        let glowColor = 'rgba(255, 255, 255, 0.4)';\n        \n        // Use sound profile to determine colors for distinct retro RGB style\n        if (preset.name.includes('Synth') || preset.name.includes('Analog')) {\n            // Synthwave style - neon pink/purple\n            backgroundColor = '#f706cf';  // Use the border color as background\n            borderColor = '#2b0f54';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(247, 6, 207, 0.5)';\n        } else if (preset.name.includes('Bass')) {\n            // Deep bass style - vibrant blue\n            backgroundColor = '#0080ff';  // Use the border color as background\n            borderColor = '#00008b';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(0, 128, 255, 0.5)';\n        } else if (preset.name.includes('Piano')) {\n            // Piano style - black and white\n            backgroundColor = '#ffffff';  // Use the border color as background\n            borderColor = '#101010';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 255, 255, 0.3)';\n        } else if (preset.name.includes('Bell') || preset.name.includes('Pluck')) {\n            // Bell/Pluck style - golden\n            backgroundColor = '#ffcc00';  // Use the border color as background\n            borderColor = '#332200';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 204, 0, 0.5)';\n        } else if (preset.name.includes('Pad')) {\n            // Pad style - soothing blue/green\n            backgroundColor = '#00aaaa';  // Use the border color as background\n            borderColor = '#003333';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(0, 170, 170, 0.5)';\n        } else if (preset.name.includes('Drum') || preset.name.includes('Percussion')) {\n            // Percussion style - red/orange\n            backgroundColor = '#ff3300';  // Use the border color as background\n            borderColor = '#330000';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 51, 0, 0.5)';\n        } else if (preset.name.includes('Hi-Hat')) {\n            // Hi-Hat style - yellow/green\n            backgroundColor = '#cccc00';  // Use the border color as background\n            borderColor = '#1a1a00';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(204, 204, 0, 0.5)';\n        } else if (preset.name.includes('Guitar') || preset.name.includes('String')) {\n            // Guitar/Strings style - warm amber\n            backgroundColor = '#ff8800';  // Use the border color as background\n            borderColor = '#331a00';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 136, 0, 0.5)';\n        } else if (preset.name.includes('Lead')) {\n            // Lead sound style - vivid red\n            backgroundColor = '#ff0000';  // Use the border color as background\n            borderColor = '#330000';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 0, 0, 0.5)';\n        } else if (preset.name.includes('Brass')) {\n            // Brass style - bright orange\n            backgroundColor = '#ff8800';  // Changed to orange\n            borderColor = '#331a00';      // Darker border\n            textColor = '#000000';        // Black text\n            glowColor = 'rgba(255, 136, 0, 0.5)';\n        } else {\n            // Use the preset's color as a fallback\n            if (preset.color) {\n                const r = Math.floor(preset.color.r * 255);\n                const g = Math.floor(preset.color.g * 255);\n                const b = Math.floor(preset.color.b * 255);\n                backgroundColor = `rgb(${r/4}, ${g/4}, ${b/4})`;\n                borderColor = `rgb(${r}, ${g}, ${b})`;\n                textColor = `rgb(${Math.min(255, r*1.5)}, ${Math.min(255, g*1.5)}, ${Math.min(255, b*1.5)})`;\n                glowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;\n            }\n        }\n        \n        // Set button stylings for retro RGB look\n        button.style.backgroundColor = backgroundColor;\n        button.style.color = textColor;\n        // Replace single border with individual borders for 3D effect\n        button.style.borderTop = `2px solid ${getLighterColor(backgroundColor, 50)}`;\n        button.style.borderLeft = `2px solid ${getLighterColor(backgroundColor, 30)}`;\n        button.style.borderBottom = `2px solid ${getDarkerColor(backgroundColor, 40)}`;\n        button.style.borderRight = `2px solid ${getDarkerColor(backgroundColor, 30)}`;\n        button.style.borderRadius = '0';  // Square corners\n        button.style.cursor = 'pointer';\n        button.style.transition = 'all 0.2s ease-in-out';\n        button.style.textAlign = 'center';\n        button.style.boxShadow = `0 0 0 0 ${glowColor}`;\n        button.style.position = 'relative';\n        button.style.overflow = 'hidden';\n        \n        // Add helper functions for color manipulation\n        function getLighterColor(color, amount) {\n            if (color.startsWith('#')) {\n                const hex = color.replace('#', '');\n                let r = parseInt(hex.substring(0, 2), 16);\n                let g = parseInt(hex.substring(2, 4), 16);\n                let b = parseInt(hex.substring(4, 6), 16);\n                \n                r = Math.min(255, r + amount);\n                g = Math.min(255, g + amount);\n                b = Math.min(255, b + amount);\n                \n                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n            } else if (color.startsWith('rgb')) {\n                // Extract RGB values\n                const matches = color.match(/\\d+/g);\n                if (matches && matches.length >= 3) {\n                    const r = Math.min(255, parseInt(matches[0]) + amount);\n                    const g = Math.min(255, parseInt(matches[1]) + amount);\n                    const b = Math.min(255, parseInt(matches[2]) + amount);\n                    return `rgb(${r}, ${g}, ${b})`;\n                }\n            }\n            return color; // Fallback if color format is unknown\n        }\n        \n        function getDarkerColor(color, amount) {\n            if (color.startsWith('#')) {\n                const hex = color.replace('#', '');\n                let r = parseInt(hex.substring(0, 2), 16);\n                let g = parseInt(hex.substring(2, 4), 16);\n                let b = parseInt(hex.substring(4, 6), 16);\n                \n                r = Math.max(0, r - amount);\n                g = Math.max(0, g - amount);\n                b = Math.max(0, b - amount);\n                \n                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n            } else if (color.startsWith('rgb')) {\n                // Extract RGB values\n                const matches = color.match(/\\d+/g);\n                if (matches && matches.length >= 3) {\n                    const r = Math.max(0, parseInt(matches[0]) - amount);\n                    const g = Math.max(0, parseInt(matches[1]) - amount);\n                    const b = Math.max(0, parseInt(matches[2]) - amount);\n                    return `rgb(${r}, ${g}, ${b})`;\n                }\n            }\n            return color; // Fallback if color format is unknown\n        }\n        \n        // Add scanline effect and pixel noise\n        const scanlines = document.createElement('div');\n        scanlines.style.position = 'absolute';\n        scanlines.style.top = '0';\n        scanlines.style.left = '0';\n        scanlines.style.width = '100%';\n        scanlines.style.height = '100%';\n        scanlines.style.backgroundImage = 'repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px)';\n        scanlines.style.pointerEvents = 'none';\n        button.appendChild(scanlines);\n        \n        // Add a tooltip showing what preset is applied\n        button.title = `${preset.name} Preset`;\n\n        // Add a subtle glow effect that pulses slightly\n        button.style.animation = 'buttonPulse 4s infinite';\n        const styleSheet = document.createElement('style');\n        styleSheet.textContent = `\n            @keyframes buttonPulse {\n                0% { box-shadow: 0 0 5px 0 ${glowColor}; }\n                50% { box-shadow: 0 0 8px 1px ${glowColor}; }\n                100% { box-shadow: 0 0 5px 0 ${glowColor}; }\n            }\n        `;\n        document.head.appendChild(styleSheet);\n        \n        // Store the original styles for hover effects\n        button.dataset.original = backgroundColor;\n        button.dataset.originalBorderTop = getLighterColor(backgroundColor, 50);\n        button.dataset.originalBorderLeft = getLighterColor(backgroundColor, 30);\n        button.dataset.originalBorderBottom = getDarkerColor(backgroundColor, 40);\n        button.dataset.originalBorderRight = getDarkerColor(backgroundColor, 30);\n        button.dataset.originalText = textColor;  // Store original text color\n        button.dataset.glow = glowColor;\n        \n        // Add event listener\n        button.addEventListener('click', () => {\n            // First apply the preset immediately\n            applyPreset(preset);\n            \n            // Visual feedback - deactivate previous button\n            if (activePresetButton) {\n                // Properly restore all original colors from the dataset\n                activePresetButton.style.backgroundColor = activePresetButton.dataset.original || '#333333';\n                activePresetButton.style.color = activePresetButton.dataset.originalText || '#000000';\n                activePresetButton.style.borderTop = `2px solid ${activePresetButton.dataset.originalBorderTop || '#333333'}`;\n                activePresetButton.style.borderLeft = `2px solid ${activePresetButton.dataset.originalBorderLeft || '#333333'}`;\n                activePresetButton.style.borderBottom = `2px solid ${activePresetButton.dataset.originalBorderBottom || '#333333'}`;\n                activePresetButton.style.borderRight = `2px solid ${activePresetButton.dataset.originalBorderRight || '#333333'}`;\n                activePresetButton.style.transform = 'scale(1)';\n                activePresetButton.style.boxShadow = 'none';\n                activePresetButton.style.animation = 'buttonPulse 4s infinite';\n                activePresetButton.style.fontWeight = 'normal';\n            }\n            \n            // Activate this button with grey color scheme to indicate selection\n            button.style.backgroundColor = '#222222'; // Much darker grey background for selected button\n            button.style.color = '#eeeeee';          // Light grey text\n            // Invert the border colors for a pressed-in appearance\n            button.style.borderTop = `2px solid #111111`;\n            button.style.borderLeft = `2px solid #111111`;\n            button.style.borderBottom = `2px solid #333333`;\n            button.style.borderRight = `2px solid #333333`;\n            button.style.transform = 'scale(1.05)';\n            button.style.boxShadow = '0 0 8px rgba(100, 100, 100, 0.5)';\n            button.style.animation = 'activePulse 1.5s infinite';\n            \n            // Add a special animation for the active button\n            const activeStyleSheet = document.createElement('style');\n            activeStyleSheet.textContent = `\n                @keyframes activePulse {\n                    0% { box-shadow: 0 0 8px rgba(100, 100, 100, 0.5); }\n                    50% { box-shadow: 0 0 15px rgba(150, 150, 150, 0.7); }\n                    100% { box-shadow: 0 0 8px rgba(100, 100, 100, 0.5); }\n                }\n            `;\n            document.head.appendChild(activeStyleSheet);\n            \n            activePresetButton = button;\n        });\n        \n        // Add hover effect\n        button.addEventListener('mouseenter', () => {\n            if (button !== activePresetButton) {\n                // Brightened background on hover\n                const lightenColor = color => {\n                    // Simple conversion to HSL for lightening\n                    const hex = color.replace('#', '');\n                    // Convert hex to RGB\n                    let r = parseInt(hex.substring(0, 2), 16);\n                    let g = parseInt(hex.substring(2, 4), 16);\n                    let b = parseInt(hex.substring(4, 6), 16);\n                    \n                    // Brighten by adding 20% to each component\n                    r = Math.min(255, r + 50);\n                    g = Math.min(255, g + 50);\n                    b = Math.min(255, b + 50);\n                    \n                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n                };\n                \n                let hoveredBgColor;\n                if (backgroundColor.startsWith('#')) {\n                    hoveredBgColor = lightenColor(backgroundColor);\n                } else {\n                    // Use simple brightening for RGB colors\n                    hoveredBgColor = 'rgba(80, 80, 80, 0.9)';\n                }\n                \n                button.style.backgroundColor = hoveredBgColor;\n                // Update borders to maintain 3D effect with new background color\n                button.style.borderTop = `2px solid ${getLighterColor(hoveredBgColor, 50)}`;\n                button.style.borderLeft = `2px solid ${getLighterColor(hoveredBgColor, 30)}`;\n                button.style.borderBottom = `2px solid ${getDarkerColor(hoveredBgColor, 40)}`;\n                button.style.borderRight = `2px solid ${getDarkerColor(hoveredBgColor, 30)}`;\n                \n                button.style.boxShadow = `0 0 5px ${button.dataset.glow}`;\n            }\n        });\n        \n        button.addEventListener('mouseleave', () => {\n            if (button !== activePresetButton) {\n                button.style.backgroundColor = button.dataset.original;\n                button.style.borderTop = `2px solid ${button.dataset.originalBorderTop}`;\n                button.style.borderLeft = `2px solid ${button.dataset.originalBorderLeft}`;\n                button.style.borderBottom = `2px solid ${button.dataset.originalBorderBottom}`;\n                button.style.borderRight = `2px solid ${button.dataset.originalBorderRight}`;\n                button.style.boxShadow = 'none';\n            }\n        });\n        \n        return button;\n    }\n\n    // Add preset buttons to grid\n    defaultPresets.forEach(preset => {\n        const button = createPresetButton(preset);\n        presetButtonGrid.appendChild(button);\n    });\n    \n    // Add the preset button grid to the container\n    presetContainer.appendChild(presetButtonGrid);\n\n    // Add event listener to deactivate preset button when sliders are changed\n    const deactivatePresetOnChange = () => {\n        if (activePresetButton) {\n            // Properly restore all original colors from the dataset\n            activePresetButton.style.backgroundColor = activePresetButton.dataset.original || '#333333';\n            activePresetButton.style.color = activePresetButton.dataset.originalText || '#000000';\n            activePresetButton.style.borderTop = `2px solid ${activePresetButton.dataset.originalBorderTop || '#333333'}`;\n            activePresetButton.style.borderLeft = `2px solid ${activePresetButton.dataset.originalBorderLeft || '#333333'}`;\n            activePresetButton.style.borderBottom = `2px solid ${activePresetButton.dataset.originalBorderBottom || '#333333'}`;\n            activePresetButton.style.borderRight = `2px solid ${activePresetButton.dataset.originalBorderRight || '#333333'}`;\n            activePresetButton.style.transform = 'scale(1)';\n            activePresetButton.style.boxShadow = 'none';\n            // Restore the original animation\n            activePresetButton.style.animation = 'buttonPulse 4s infinite';\n            activePresetButton.style.fontWeight = 'normal';\n            \n            activePresetButton = null;\n        }\n        // Clear the active preset\n        window.activePreset = null;\n    };\n\n    // Add listener to each control that would modify the sound\n    selectedSynthFolder.children.forEach(control => {\n        if (control.label && \n            !control.label.includes('Presets') && \n            !control.label.includes('Preview')) {\n            control.on('change', deactivatePresetOnChange);\n        }\n    });\n\n    // Also add listeners to the controls in the tabs\n    if (soundTabs && soundTabs.pages) {\n        // Filter tab (index 1)\n        if (soundTabs.pages[1] && soundTabs.pages[1].children) {\n            soundTabs.pages[1].children.forEach(control => {\n            control.on('change', deactivatePresetOnChange);\n        });\n    }\n    \n        // Effects tab (index 2)\n        if (soundTabs.pages[2] && soundTabs.pages[2].children) {\n            soundTabs.pages[2].children.forEach(control => {\n            control.on('change', deactivatePresetOnChange);\n        });\n    }\n    \n        // Modulation tab (index 3)\n        if (soundTabs.pages[3] && soundTabs.pages[3].children) {\n            soundTabs.pages[3].children.forEach(control => {\n            control.on('change', deactivatePresetOnChange);\n        });\n        }\n    }\n\n    // Preset container was already added to the folder earlier\n\n    // Store reference for InputManager to use\n    window.selectedSynthFolder = selectedSynthFolder;\n\n    // Create a container for the waveform visualizer\n    const visualizerContainer = document.createElement('div');\n    visualizerContainer.id = 'visualizer-container';\n    visualizerContainer.style.marginTop = '10px';\n    visualizerContainer.style.width = '100%';\n    visualizerContainer.style.height = '160px'; // Increased height for better visibility\n    visualizerContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';\n    visualizerContainer.style.borderRadius = '4px';\n    visualizerContainer.style.overflow = 'hidden';\n    visualizerContainer.style.position = 'relative';\n    visualizerContainer.style.display = 'flex';\n    visualizerContainer.style.flexDirection = 'column';\n\n    // Create waveform visualizer (directly in the container, no spectrum visualizer)\n    const waveformContainer = document.createElement('div');\n    waveformContainer.id = 'waveform-container';\n    waveformContainer.style.width = '100%';\n    waveformContainer.style.height = '100%'; // Use full height\n    waveformContainer.style.position = 'relative';\n\n    // Create canvas for waveform visualization\n    const waveformCanvas = document.createElement('canvas');\n    waveformCanvas.id = 'waveform-canvas';\n    waveformCanvas.width = 280;\n    waveformCanvas.height = 160; // Increased height to match container\n    waveformCanvas.style.width = '100%';\n    waveformCanvas.style.height = '100%';\n    waveformContainer.appendChild(waveformCanvas);\n\n    // Add containers to the visualizer - only add the waveform container\n    visualizerContainer.appendChild(waveformContainer);\n\n    // Add roundRect polyfill for browsers that don't support it (like Firefox)\n    if (!CanvasRenderingContext2D.prototype.roundRect) {\n        CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radii) {\n            if (typeof radii === 'number') {\n                radii = [radii, radii, radii, radii];\n            } else if (radii.length === 1) {\n                radii = [radii[0], radii[0], radii[0], radii[0]];\n            } else if (radii.length === 2) {\n                radii = [radii[0], radii[1], radii[0], radii[1]];\n            }\n\n            this.beginPath();\n            this.moveTo(x + radii[0], y);\n            this.lineTo(x + width - radii[1], y);\n            this.quadraticCurveTo(x + width, y, x + width, y + radii[1]);\n            this.lineTo(x + width, y + height - radii[2]);\n            this.quadraticCurveTo(x + width, y + height, x + width - radii[2], y + height);\n            this.lineTo(x + radii[3], y + height);\n            this.quadraticCurveTo(x, y + height, x, y + height - radii[3]);\n            this.lineTo(x, y + radii[0]);\n            this.quadraticCurveTo(x, y, x + radii[0], y);\n            this.closePath();\n            return this;\n        };\n    }\n\n    // Add ADSR visualization overlay on waveform - improved version with more space\n    const drawEnvelopePath = (ctx, x, y, width, height, attack, decay, sustain, release) => {\n        const totalTime = attack + decay + 0.2 + release; // Add 0.2 for sustain display\n        const attackX = x + (width * (attack / totalTime));\n        const decayX = attackX + (width * (decay / totalTime));\n        const releaseX = decayX + (width * (0.2 / totalTime)); // Longer sustain display\n        const sustainY = y + (height * (1 - sustain));\n        \n        // Draw background for envelope - changed to dark grey\n        ctx.fillStyle = 'rgba(30, 30, 30, 0.4)'; // Dark grey background\n        ctx.fillRect(x, y, width, height);\n        \n        // Draw grid lines - changed to lighter grey\n        ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';\n        ctx.lineWidth = 0.5;\n        \n        // Horizontal grid lines\n        for (let i = 1; i < 5; i++) { // More grid lines\n            const gridY = y + (height * i / 5);\n            ctx.beginPath();\n            ctx.moveTo(x, gridY);\n            ctx.lineTo(x + width, gridY);\n            ctx.stroke();\n        }\n        \n        // Vertical grid lines\n        for (let i = 1; i < 5; i++) { // More grid lines\n            const gridX = x + (width * i / 5);\n            ctx.beginPath();\n            ctx.moveTo(gridX, y);\n            ctx.lineTo(gridX, y + height);\n            ctx.stroke();\n        }\n        \n        // Draw ADSR path - changed to grey tones\n        ctx.beginPath();\n        ctx.moveTo(x, y + height); // Start at bottom left\n        ctx.lineTo(x, y + height); // Bottom left\n        ctx.lineTo(attackX, y); // Peak (attack)\n        ctx.lineTo(decayX, sustainY); // Decay to sustain level\n        ctx.lineTo(releaseX, sustainY); // Sustain\n        ctx.lineTo(x + width, y + height); // Release to zero\n        \n        ctx.fillStyle = 'rgba(160, 160, 160, 0.25)'; // Grey with transparency - changed to 0.3 opacity\n        ctx.fill();\n        \n        // ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)'; // Light grey line\n        // ctx.lineWidth = 2;\n        // ctx.stroke();\n        \n        // // Add small dots at breakpoints - changed to white\n        // ctx.fillStyle = 'rgba(255, 255, 255, 0.0)';\n        // ctx.beginPath();\n        // ctx.arc(x, y + height, 4, 0, Math.PI * 2); // Start point - larger dots\n        // ctx.arc(attackX, y, 4, 0, Math.PI * 2); // Attack point\n        // ctx.arc(decayX, sustainY, 4, 0, Math.PI * 2); // Decay/sustain point\n        // ctx.arc(releaseX, sustainY, 4, 0, Math.PI * 2); // End of sustain\n        // ctx.arc(x + width, y + height, 4, 0, Math.PI * 2); // End point\n        // ctx.fill();\n        \n        // Add labels with larger font - changed to white\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.3';\n        ctx.font = '11px monospace'; // Larger font\n        ctx.textAlign = 'center';\n        \n        // Label each section with its value\n        ctx.fillText(`A: ${attack.toFixed(2)}`, (x + attackX) / 2, y + height - 8);\n        ctx.fillText(`D: ${decay.toFixed(2)}`, (attackX + decayX) / 2, y + 20);\n        ctx.fillText(`S: ${sustain.toFixed(2)}`, (decayX + releaseX) / 2, sustainY - 8);\n        ctx.fillText(`R: ${release.toFixed(2)}`, (releaseX + x + width) / 2, y + height - 8);\n    };\n\n    // Add container to the folder after a delay to ensure folder is created\n    setTimeout(() => {\n        if (selectedSynthFolder && selectedSynthFolder.element) {\n            selectedSynthFolder.element.appendChild(visualizerContainer);\n        }\n    }, 100);\n\n    // Function to draw both visualizations\n    window.drawVisualizations = function() {\n        // Schedule next frame\n        if (window.visualizationAnimationFrame) {\n            cancelAnimationFrame(window.visualizationAnimationFrame);\n        }\n        window.visualizationAnimationFrame = requestAnimationFrame(window.drawVisualizations);\n        \n        if (!window.soundManager) return;\n        \n        const container = document.getElementById('visualizer-container');\n        if (container && window.getComputedStyle(container).display === 'none') {\n            return; // Don't draw if container is hidden\n        }\n        \n        // Draw waveform visualization\n        if (window.soundManager.waveformAnalyzer) {\n            const canvas = document.getElementById('waveform-canvas');\n            if (canvas) {\n                const ctx = canvas.getContext('2d');\n                const waveform = window.soundManager.waveformAnalyzer.getValue();\n                \n                // Clear canvas\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                \n                // Draw ADSR envelope overlay first (as background)\n                if (window.settings) {\n                    drawEnvelopePath(\n                        ctx, \n                        10, // x\n                        10, // y\n                        canvas.width - 20, // width\n                        canvas.height - 20, // height\n                        window.settings.selectedAttack,\n                        window.settings.selectedDecay,\n                        window.settings.selectedSustain,\n                        window.settings.selectedRelease\n                    );\n                }\n                \n                // Add center line\n                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                ctx.moveTo(0, canvas.height / 2);\n                ctx.lineTo(canvas.width, canvas.height / 2);\n                ctx.stroke();\n                \n                // Only draw the waveform if we have a selected neuron\n                if (window.soundManager.selectedNeuronId !== null) {\n                    // Check if there's an actual signal\n                    let hasSignal = false;\n                    for (let i = 0; i < waveform.length; i++) {\n                        if (Math.abs(waveform[i]) > 0.01) {\n                            hasSignal = true;\n                            break;\n                        }\n                    }\n                    \n                    if (hasSignal) {\n                        ctx.beginPath();\n                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n                        ctx.lineWidth = 1.5;\n                        \n                        const sliceWidth = canvas.width / waveform.length;\n                        let x = 0;\n                        \n                        // Start at the beginning of the waveform\n                        ctx.moveTo(x, (waveform[0] * canvas.height / 2) + canvas.height / 2);\n                        \n                        // Connect all points with lines\n                        for (let i = 1; i < waveform.length; i++) {\n                            const y = (waveform[i] * canvas.height / 2) + canvas.height / 2;\n                            ctx.lineTo(x += sliceWidth, y);\n                        }\n                        \n                        ctx.stroke();\n                    }\n                }\n            }\n        }\n    };\n\n    // Start the animation and store the ID for cleanup\n    window.startVisualizations = function() {\n        if (window.visualizationAnimationFrame) {\n            cancelAnimationFrame(window.visualizationAnimationFrame);\n        }\n        window.visualizationAnimationFrame = requestAnimationFrame(window.drawVisualizations);\n        console.log(\"Started audio visualizations\");\n    };\n\n    // Stop the animation to save resources\n    window.stopVisualizations = function() {\n        if (window.visualizationAnimationFrame) {\n            cancelAnimationFrame(window.visualizationAnimationFrame);\n            window.visualizationAnimationFrame = null;\n            console.log(\"Stopped audio visualizations\");\n        }\n    };\n\n    // Initialize analyzer and start visualizations (renamed for clarity)\n    window.setupSpectrumAnalyzer = function() {\n        if (!window.soundManager) return;\n        \n        console.log(\"Setting up audio visualizer\");\n        \n        // Only initialize the waveform analyzer, remove spectrum analyzer code\n        if (!window.soundManager.waveformAnalyzer) {\n            console.log(\"Creating waveform analyzer\");\n            window.soundManager.waveformAnalyzer = new Tone.Analyser(\"waveform\", 128);\n            Tone.Destination.connect(window.soundManager.waveformAnalyzer);\n        }\n        \n        // Start visualizations immediately\n        window.startVisualizations();\n    };\n\n    // Rename the function for clarity but keep the old name for compatibility\n    window.setupAudioVisualizer = window.setupSpectrumAnalyzer;\n\n    // Fix the method to play a test tone when the Test Sound button is clicked\n    window.playTestTone = function() {\n        if (window.soundManager && window.soundManager.selectedNeuronId !== null) {\n            console.log(\"Playing test tone for neuron:\", window.soundManager.selectedNeuronId);\n            \n            // Ensure Tone.js audio context is started\n            if (Tone && Tone.context && Tone.context.state !== 'running') {\n                Tone.context.resume();\n            }\n            \n            // Override playPreviewSounds setting temporarily for explicit test sound\n            const originalPreviewSetting = window.settings?.previewSounds;\n            if (window.settings) window.settings.previewSounds = true;\n            \n            // Play the sound immediately\n            window.soundManager.playNeuronFiring(\n                0.7, // weight\n                0.5, // speed\n                window.soundManager.selectedNeuronId,\n                true, // isolated\n                true, // hasDC\n                0    // distance\n            );\n            \n            // Restore original preview setting\n            if (window.settings) window.settings.previewSounds = originalPreviewSetting;\n            \n            // Flash the Test Sound button for visual feedback\n            const button = document.querySelector('#visualizer-container button');\n            if (button) {\n                const originalColor = button.style.backgroundColor;\n                button.style.backgroundColor = 'rgba(180, 255, 200, 0.9)';\n                button.style.boxShadow = '0 0 8px rgba(100,255,150,0.8)';\n                \n                // Stronger pulse effect\n                setTimeout(() => {\n                    button.style.backgroundColor = 'rgba(200, 255, 220, 1.0)';\n                    button.style.boxShadow = '0 0 12px rgba(120,255,170,0.9)';\n                }, 50);\n                \n                setTimeout(() => {\n                    button.style.backgroundColor = originalColor;\n                    button.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';\n                }, 300);\n            }\n            \n            // Force update of the envelope visualization\n            if (window.drawVisualizations) {\n                window.drawVisualizations();\n            }\n        } else {\n            console.warn(\"Cannot play test tone - no neuron selected\");\n        }\n    };\n\n    // Update InputManager to start visualization when showing the synth panel\n    setTimeout(() => {\n        const InputManager = window.InputManager;\n        if (InputManager && InputManager.prototype.toggleSynthPanel) {\n            const originalToggleSynthPanel = InputManager.prototype.toggleSynthPanel;\n            \n            InputManager.prototype.toggleSynthPanel = function(show, neuron = null) {\n                // Call the original method first\n                originalToggleSynthPanel.call(this, show, neuron);\n                \n                // If showing panel for a neuron, update the harmony anchor status\n                if (show && neuron) {\n                    // Update isHarmonyAnchor in settings based on the selected neuron\n                    window.settings.isHarmonyAnchor = neuron.isHarmonyAnchor || false;\n                    \n                    // Update UI to reflect current status\n                    if (window.selectedSynthFolder) {\n                        // Force refresh of the synth folder\n                        window.selectedSynthFolder.refresh();\n                    }\n                    \n                    // Update any visual indicators for harmony anchors\n                    const selectedCircle = window.circles.find(circle => \n                        circle && circle.neuron && circle.neuron.id === window.soundManager?.selectedNeuronId\n                    );\n                    \n                    if (selectedCircle && selectedCircle.neuron && selectedCircle.neuron.isHarmonyAnchor) {\n                        // Create or show harmony anchor indicator\n                        if (!selectedCircle.harmonyAnchorIndicator) {\n                            const indicatorGeometry = new THREE.RingGeometry(0.3, 0.35, 16);\n                            const indicatorMaterial = new THREE.MeshBasicMaterial({\n                                color: 0xffff00,\n                                transparent: true,\n                                opacity: 0.5,\n                                side: THREE.DoubleSide\n                            });\n                            \n                            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);\n                            indicator.rotation.x = -Math.PI / 2;\n                            indicator.position.copy(selectedCircle.position);\n                            indicator.position.y += 0.05; // Slightly above the neuron\n                            \n                            // Store reference and add to scene\n                            selectedCircle.harmonyAnchorIndicator = indicator;\n                            window.scene.add(indicator);\n                        } else {\n                            // Ensure indicator is visible\n                            selectedCircle.harmonyAnchorIndicator.visible = true;\n                        }\n                    }\n                }\n                \n                // Get the screen width to determine if we're on desktop (≥1024) or mobile\n                const screenWidth = window.innerWidth;\n                const isDesktop = screenWidth >= 1024;\n                \n                // Make sure the panel is visible with proper display setting\n                if (window.selectedSynthFolder && window.selectedSynthFolder.element) {\n                    const panel = window.selectedSynthFolder.element;\n                    \n                    if (show) {\n                        // On mobile, we show/hide based on user action\n                        // On desktop, the panel is always visible, but we update the content\n                        if (!isDesktop) {\n                        panel.style.display = 'block';\n                        }\n                        \n                        // Force a browser reflow to ensure display changes take effect\n                        void panel.offsetWidth;\n                        \n                        // Make sure all sound control children are visible\n                        Array.from(panel.children).forEach(child => {\n                            if (child) {\n                                child.style.display = 'block';\n                                // If child has children, make them visible too\n                                if (child.children) {\n                                    Array.from(child.children).forEach(grandchild => {\n                                        if (grandchild) grandchild.style.display = 'block';\n                                    });\n                                }\n                            }\n                        });\n                        \n                        // Remove the placeholder message when a neuron is selected\n                        const placeholderMsg = document.getElementById('synth-placeholder-msg');\n                        if (placeholderMsg) {\n                            placeholderMsg.remove();\n                        }\n                        \n                        // Explicitly refresh the panel\n                        if (window.selectedSynthFolder.refresh) {\n                            setTimeout(() => {\n                                window.selectedSynthFolder.refresh();\n                                console.log(\"Sound controls refreshed after showing\");\n                            }, 50);\n                        }\n                    } else {\n                        // On mobile, hide the panel when no neuron is selected\n                        // On desktop, we show a placeholder message instead\n                        if (!isDesktop) {\n                        panel.style.display = 'none';\n                        } else {\n                            // We keep the panel visible but show a placeholder message\n                            panel.style.display = 'block';\n                            \n                            // Add a placeholder message if not already present\n                            if (!document.getElementById('synth-placeholder-msg')) {\n                                const placeholderMsg = document.createElement('div');\n                                placeholderMsg.id = 'synth-placeholder-msg';\n                                placeholderMsg.style.padding = '10px';\n                                placeholderMsg.style.textAlign = 'center';\n                                placeholderMsg.style.color = '#aaa';\n                                placeholderMsg.style.fontStyle = 'italic';\n                                placeholderMsg.innerHTML = 'Select a neuron to edit sound parameters';\n                                \n                                // Insert at the top of the folder\n                                panel.insertBefore(placeholderMsg, panel.firstChild);\n                            }\n                        }\n                    }\n                    \n                    console.log(`InputManager: Sound panel display set to ${panel.style.display}, isDesktop: ${isDesktop}`);\n                }\n                \n                // Toggle visibility of global controls when sound panel is shown/hidden\n                if (window.globalControls && !isDesktop) {\n                    // When showing sound panel, hide global controls (mobile only)\n                    const displayValue = show ? 'none' : '';\n                    \n                    try {\n                        console.log(\"Toggling global controls visibility:\", displayValue);\n                        for (const key in window.globalControls) {\n                            if (window.globalControls[key]) {\n                                console.log(`Setting ${key} display to ${displayValue}`);\n                                window.globalControls[key].style.display = displayValue;\n                            }\n                        }\n                    } catch (error) {\n                        console.error(\"Error toggling control visibility:\", error);\n                    }\n                } else {\n                    console.log(\"Global controls not toggled (desktop mode or not found)\");\n                }\n                \n                // Start visualization if panel is shown\n                if (show && neuron && window.drawVisualizations) {\n                    console.log(\"Starting audio visualizations for neuron:\", neuron.id);\n                    \n                    // Initialize and start visualizations\n                    if (!window.setupSpectrumAnalyzer) {\n                        console.error(\"setupSpectrumAnalyzer function not found!\");\n                    } else {\n                        window.setupSpectrumAnalyzer(); \n                    }\n                    \n                    // Force immediate rendering of the envelope visualization\n                    forceRenderEnvelope();\n                    \n                    // Don't automatically highlight any note, let user explicitly select\n                    // Clear any existing active note button\n                    if (window.activeNoteButton && window.activeNoteButton !== null) {\n                        window.activeNoteButton.style.backgroundColor = window.activeNoteButton.dataset.original || 'rgba(50, 50, 50, 0.7)';\n                        window.activeNoteButton.style.transform = 'scale(1)';\n                        window.activeNoteButton.style.boxShadow = 'none';\n                        window.activeNoteButton.style.fontWeight = 'normal';\n                        window.activeNoteButton = null;\n                    }\n                    \n                    // Remove automatic test tone when showing panel\n                }\n                \n                // Always update the neuron label position\n                if (window.updateNeuronLabelPosition) {\n                    window.updateNeuronLabelPosition();\n                }\n            };\n            \n            console.log(\"Successfully patched InputManager.toggleSynthPanel\");\n        } else {\n            console.warn(\"Could not patch InputManager.toggleSynthPanel - not available\");\n        }\n    }, 1000);\n\n    // Function to render the envelope - uses ReactiveManager for efficient rendering\n    function renderEnvelope(canvas) {\n        // Make sure we have the canvas\n        if (!canvas) {\n            console.warn(\"Waveform canvas not found, can't render envelope\");\n            return;\n        }\n        \n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            console.warn(\"Could not get canvas context\");\n            return;\n        }\n        \n        // Ensure canvas is cleared completely\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Use state manager to get settings if available, otherwise use window.settings\n        let settings;\n        if (typeof stateManager !== 'undefined') {\n            settings = stateManager.getState('settings');\n        }\n        \n        // Fallback to window.settings if stateManager is unavailable or returned no settings\n        if (!settings) {\n            settings = window.settings;\n            if (!settings) {\n                console.warn(\"Settings not available for envelope rendering\");\n            return;\n            }\n        }\n        \n        // Draw the envelope using the current settings\n        // Use the drawEnvelopePath function if available\n        if (typeof drawEnvelopePath === 'function') {\n            drawEnvelopePath(\n                ctx,\n                10, // x\n                10, // y\n                canvas.width - 20, // width\n                canvas.height - 20, // height\n                settings.selectedAttack,\n                settings.selectedDecay,\n                settings.selectedSustain,\n                settings.selectedRelease\n            );\n        } else {\n            // If drawEnvelopePath isn't available, provide a minimal drawing\n            const x = 10;\n            const y = 10;\n            const width = canvas.width - 20;\n            const height = canvas.height - 20;\n            \n            const attack = settings.selectedAttack;\n            const decay = settings.selectedDecay;\n            const sustain = settings.selectedSustain;\n            const release = settings.selectedRelease;\n            \n            const totalTime = attack + decay + 0.1 + release;\n            const attackX = x + (width * (attack / totalTime));\n            const decayX = attackX + (width * (decay / totalTime));\n            const releaseX = decayX + (width * (0.1 / totalTime));\n            const sustainY = y + (height * (1 - sustain));\n            \n            // Draw background\n            ctx.fillStyle = 'rgba(20, 40, 20, 0.4)';\n            ctx.fillRect(x, y, width, height);\n            \n            // Draw ADSR path\n            ctx.beginPath();\n            ctx.moveTo(x, y + height);\n            ctx.lineTo(attackX, y);\n            ctx.lineTo(decayX, sustainY);\n            ctx.lineTo(releaseX, sustainY);\n            ctx.lineTo(x + width, y + height);\n            \n            ctx.fillStyle = 'rgba(90, 200, 120, 0.3)';\n            ctx.fill();\n            \n            ctx.strokeStyle = 'rgba(120, 240, 160, 0.8)';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n        }\n        \n        // Draw center line\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(0, canvas.height / 2);\n        ctx.lineTo(canvas.width, canvas.height / 2);\n        ctx.stroke();\n    }\n    \n    // Function to request an envelope update via ReactiveManager\n    function forceRenderEnvelope() {\n        // Use the ReactiveManager if available, otherwise fallback to direct rendering\n        if (typeof reactiveManager !== 'undefined') {\n            reactiveManager.markCanvasForUpdate();\n        } else {\n            // Direct rendering fallback\n            const canvas = document.getElementById('waveform-canvas');\n            if (canvas) {\n                renderEnvelope(canvas);\n            }\n        }\n    }\n\n    // Register renderEnvelope with state manager - do this when both are available\n    try {\n        if (stateManager && window.soundManager) {\n            stateManager.registerComponent('soundManager', {\n                ...window.soundManager,\n                renderEnvelope: renderEnvelope\n            });\n        }\n    } catch (error) {\n        console.warn(\"Could not register soundManager with stateManager:\", error);\n    }\n    \n    // Make wrapper function available for backward compatibility\n    window.forceRenderEnvelope = forceRenderEnvelope;\n\n    // Make sure envelope is initialized after setup\n    setTimeout(() => {\n        // Initialize analyzer immediately if it exists\n        if (window.setupSpectrumAnalyzer) {\n            window.setupSpectrumAnalyzer();\n        }\n        \n        // Also initialize envelope if a synth panel is already open\n        if (window.selectedSynthFolder && window.selectedSynthFolder.element.style.display !== 'none') {\n            forceRenderEnvelope();\n        }\n    }, 1000);\n\n    // Add volume balance control directly to main pane\npane.addBinding(window.settings, 'volumeNormalization', {\n        min: 0,\n        max: 2,\n        step: 0.1,\n        label: 'Volume Balance'\n    }).on('change', (ev) => {\n        if (window.soundManager) {\n            window.soundManager.setVolumeNormalization(ev.value);\n        }\n    });\n\n    // Connection Weight and Speed controls removed as requested\n\n    // Initialize global controls object\n    window.globalControls = {};\n        \n        console.log(\"Global controls initialized:\", window.globalControls);\n\n    // Add the updateSynthControls function to the window object\n    window.updateSynthControls = function(params) {\n        if (!params) return;\n        \n        // Update all controls with the new values\n        Object.keys(params).forEach(key => {\n            if (key in window.settings) {\n                window.settings[key] = params[key];\n            }\n        });\n        \n        // Refresh the pane to show updated values\n        if (pane && pane.refresh) {\n            pane.refresh();\n        }\n    };\n\n    // Initialize envelope visualization\n    // const envelopeVisualizationFolder = selectedSynthFolder.addFolder({\n    //     title: 'Envelope Visualization',\n    //     expanded: false\n    // });\n    \n    // Add a Test Sound button to the top of the selectedSynthFolder\n    // so users can intentionally hear the sound of the selected neuron\n    /*\n    const testSoundButton = selectedSynthFolder.addButton({\n        title: 'Test Sound',\n        label: 'Test Sound'\n    });\n    \n    testSoundButton.on('click', () => {\n        if (window.soundManager && window.soundManager.selectedNeuronId !== null) {\n            window.playTestTone();\n        }\n    });\n    */\n    \n    // Create a canvas for the envelope visualization\n    // const envelopeCanvas = document.createElement('canvas');\n\n    // Function to highlight preset button by preset name\n    window.highlightPresetButton = function(presetName) {\n        // First unhighlight any currently active button\n        if (activePresetButton) {\n            activePresetButton.style.backgroundColor = activePresetButton.dataset.original || '#333333';\n            activePresetButton.style.color = activePresetButton.dataset.originalText || '#000000';\n            activePresetButton.style.transform = 'scale(1)';\n            activePresetButton.style.boxShadow = 'none';\n            \n            // Restore individual borders instead of setting a single border property\n            activePresetButton.style.borderTop = `2px solid ${activePresetButton.dataset.originalBorderTop || '#333333'}`;\n            activePresetButton.style.borderLeft = `2px solid ${activePresetButton.dataset.originalBorderLeft || '#333333'}`;\n            activePresetButton.style.borderBottom = `2px solid ${activePresetButton.dataset.originalBorderBottom || '#333333'}`;\n            activePresetButton.style.borderRight = `2px solid ${activePresetButton.dataset.originalBorderRight || '#333333'}`;\n            \n            activePresetButton.style.animation = '';\n            activePresetButton.style.fontWeight = 'normal';\n        }\n        \n        // Find the button with matching preset name\n        const allButtons = presetButtonGrid.querySelectorAll('button');\n        let foundButton = null;\n        \n        allButtons.forEach(button => {\n            if (button.textContent === presetName) {\n                foundButton = button;\n            }\n        });\n        \n        if (foundButton) {\n        // Apply much more pronounced active styling - smaller and darker\n        // Use the button's original color but darken it by 70%\n        const originalColor = foundButton.dataset.original || '#333333';\n        let darkerColor;\n        \n        if (originalColor.startsWith('#')) {\n            // Convert hex to RGB and darken\n            const hex = originalColor.replace('#', '');\n            let r = parseInt(hex.substring(0, 2), 16);\n            let g = parseInt(hex.substring(2, 4), 16);\n            let b = parseInt(hex.substring(4, 6), 16);\n            \n            // Darken by reducing each component to 30%\n            r = Math.floor(r * 0.3);\n            g = Math.floor(g * 0.3);\n            b = Math.floor(b * 0.3);\n            \n            darkerColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n        } else if (originalColor.startsWith('rgb')) {\n            // Handle RGB format\n            const matches = originalColor.match(/\\d+/g);\n            if (matches && matches.length >= 3) {\n                const r = Math.floor(parseInt(matches[0]) * 0.3);\n                const g = Math.floor(parseInt(matches[1]) * 0.3);\n                const b = Math.floor(parseInt(matches[2]) * 0.3);\n                darkerColor = `rgb(${r}, ${g}, ${b})`;\n            } else {\n                darkerColor = '#111111'; // Fallback if parsing fails\n            }\n        } else {\n            darkerColor = '#111111'; // Fallback for unknown formats\n        }\n        \n        foundButton.style.backgroundColor = darkerColor;\n        foundButton.style.color = '#d8d8d8';          // Slightly dimmer text\n        foundButton.style.transform = 'scale(0.92)';  // Smaller scale \n        foundButton.style.fontWeight = 'bold';        // Make text bold\n        foundButton.style.boxShadow = '0 0 8px rgba(80, 80, 80, 0.4)'; // Very subtle glow\n        \n        // Inverted lighting effect with darker borders\n        foundButton.style.borderTop = '3px solid #000000';    // Darker top\n        foundButton.style.borderLeft = '3px solid #000000';   // Darker left\n        foundButton.style.borderBottom = '3px solid #222222'; // Lighter bottom\n        foundButton.style.borderRight = '3px solid #222222';  // Lighter right\n        \n        // Add a pulsing border\n        const keyframes = document.createElement('style');\n        // Create an animation that uses a very subtle, darker pulse effect\n        let glowColor = 'rgba(60, 60, 60, 0.3)';\n        let glowColorBright = 'rgba(80, 80, 80, 0.4)';\n        \n        // Try to derive glow color from the original but make it darker\n        if (originalColor.startsWith('#')) {\n            const hex = originalColor.replace('#', '');\n            let r = parseInt(hex.substring(0, 2), 16);\n            let g = parseInt(hex.substring(2, 4), 16);\n            let b = parseInt(hex.substring(4, 6), 16);\n            \n            // Make the glow darker than the original color\n            r = Math.floor(r * 0.25);\n            g = Math.floor(g * 0.25);\n            b = Math.floor(b * 0.25);\n            \n            glowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;\n            glowColorBright = `rgba(${r}, ${g}, ${b}, 0.4)`;\n        }\n        \n        keyframes.textContent = `\n            @keyframes activePulse {\n                0% { box-shadow: 0 0 3px ${glowColor}; }\n                50% { box-shadow: 0 0 5px ${glowColorBright}; }\n                100% { box-shadow: 0 0 3px ${glowColor}; }\n            }\n        `;\n        document.head.appendChild(keyframes);\n        \n        foundButton.style.animation = 'activePulse 1.2s infinite';\n        \n        // Add checkmark indicator\n        foundButton.style.position = 'relative';\n            \n            // Set as active button\n            activePresetButton = foundButton;\n            \n            console.log(`Highlighted preset button: ${presetName}`);\n        }\n    };\n    \n    // Function to unhighlight the active preset button\n    window.unhighlightActivePreset = function() {\n        if (activePresetButton) {\n            // Restore original appearance\n            activePresetButton.style.backgroundColor = activePresetButton.dataset.original || '#333333';\n            activePresetButton.style.color = activePresetButton.dataset.originalText || '#000000';\n            activePresetButton.style.transform = 'scale(1)';\n            activePresetButton.style.boxShadow = 'none';\n            \n            // Restore individual borders instead of setting a single border property\n            activePresetButton.style.borderTop = `2px solid ${activePresetButton.dataset.originalBorderTop || '#333333'}`;\n            activePresetButton.style.borderLeft = `2px solid ${activePresetButton.dataset.originalBorderLeft || '#333333'}`;\n            activePresetButton.style.borderBottom = `2px solid ${activePresetButton.dataset.originalBorderBottom || '#333333'}`;\n            activePresetButton.style.borderRight = `2px solid ${activePresetButton.dataset.originalBorderRight || '#333333'}`;\n            \n            activePresetButton.style.animation = '';\n            activePresetButton.style.fontWeight = 'normal';\n            activePresetButton = null;\n        }\n        // Clear the active preset\n        window.activePreset = null;\n    };\n\n    // Create utility function to apply a preset and remember it for future neurons\n    window.applyAndRememberPreset = function(preset, neuronId = null) {\n        if (!preset) return false;\n        \n        console.log(`%c[PRESET SYSTEM] Remembering preset \"${preset.name}\" for future neurons`, \"color: #00ff00; font-weight: bold;\");\n        \n        // Store this preset globally as the active preset\n        window.activePreset = preset;\n        \n        // Store the preset but specially handle the color property to preserve THREE.Color instance\n        window.lastSelectedPreset = JSON.parse(JSON.stringify(preset)); // Deep clone\n        \n        // Special handling for color - JSON.stringify/parse loses THREE.Color type\n        if (preset.color && preset.color.isColor) {\n            // If it's a THREE.Color, create a new one and copy values\n            window.lastSelectedPreset.color = new THREE.Color();\n            window.lastSelectedPreset.color.copy(preset.color);\n        }\n        \n        // If we have a neuron ID, apply the preset to that neuron\n        if (neuronId !== null && window.soundManager) {\n            // Apply to specific neuron\n            applyPreset(preset, neuronId);\n            return true;\n        }\n        \n        return true;\n    };\n\n    // Add function to check and adjust volume for specific instrument types\n    window.adjustVolumeForInstrumentType = function(params) {\n        if (!params) return params;\n        \n        // Check the instrument type by name\n        const name = params.name?.toLowerCase() || '';\n        \n        // Simple name-based checks for main instrument categories\n        if (name.includes('lead') || name.includes('organ') || name.includes('pad')) {\n            // Don't override manually set values for lead, organ or pad instruments\n            console.log(`%c[VOLUME ADJUSTMENT] Using preset value for ${params.name}`, \"color: #ff8800;\");\n            // No change - use the preset value\n        } else if (name.includes('brass') || name.includes('string')) {\n            console.log(`%c[VOLUME ADJUSTMENT] Setting volume to -8dB for ${params.name}`, \"color: #ff8800;\");\n            params.neuronVolume = -8;\n        }\n        \n        return params;\n    };\n\n    // Create utility function to apply a preset to a specific neuron\n    window.applyPreset = function(preset, neuronId) {\n        if (!preset) return false;\n        \n        // If neuronId is not provided, use the currently selected neuron\n        if (!neuronId && window.soundManager) {\n            neuronId = window.soundManager.selectedNeuronId;\n        }\n        \n        // Still need a valid neuronId to proceed\n        if (!neuronId || !window.soundManager) {\n            console.error(`[PRESET SYSTEM] No neuron selected or provided`);\n            return false;\n        }\n        \n        console.log(`%c[PRESET SYSTEM] Applying preset \"${preset.name}\" to neuron ${neuronId}`, \"color: #00ff00; font-weight: bold;\");\n        \n        // Get the neuron's mesh\n        const neuron = window.circles.find(circle => \n            circle && circle.neuron && circle.neuron.id === neuronId\n        );\n        \n        if (!neuron) {\n            console.error(`[PRESET SYSTEM] Could not find neuron ${neuronId}`);\n            return false;\n        }\n        \n        // Apply color to the neuron's material with animation\n        if (preset.color) {\n            // Store original color for animation\n            const originalColor = neuron.material.color.clone();\n            const targetColor = preset.color.clone();\n            \n            // Store the preset color for future reference\n            neuron.neuron.presetColor = preset.color.clone();\n            \n            // Create animation for smooth color transition\n            gsap.to(originalColor, {\n                r: targetColor.r,\n                g: targetColor.g,\n                b: targetColor.b,\n                duration: 0.5, // 500ms animation\n                ease: \"power2.out\",\n                onUpdate: function() {\n                    // Update the neuron's material color during animation\n                    neuron.material.color.setRGB(originalColor.r, originalColor.g, originalColor.b);\n                },\n                onComplete: function() {\n                    // Ensure final color is exactly the target color\n                    neuron.material.color.copy(targetColor);\n                }\n            });\n            \n            // Create an immediate and more dramatic particle explosion with the new preset color\n            // Check if the particle explosion method exists\n            \n            if (neuron.neuron && typeof neuron.neuron.createParticleExplosion === 'function') {\n                // Use the built-in method\n                // Trigger an immediate particle explosion with the new color\n                neuron.neuron.createParticleExplosion({\n                    color: preset.color,\n                    count: 25,         // Much more particles \n                    speed: 1.2,        // Faster particles for more dramatic effect\n                    scale: 0.2,        // Larger particles\n                    duration: 1200     // Longer duration\n                });\n                \n                // Add a second burst for extra visual impact\n                setTimeout(() => {\n                    neuron.neuron.createParticleExplosion({\n                        color: preset.color,\n                        count: 15,\n                        speed: 0.9,\n                        scale: 0.15,\n                        duration: 1000\n                    });\n                }, 150); // Small delay for second burst\n            } else {\n                // Fallback: Create direct explosion by accessing the scene directly\n                // Create our own particle explosion since the built-in method isn't available\n                \n                const createDirectExplosion = (count, scale, speed, duration) => {\n                                         const particleGeometry = new THREE.PlaneGeometry(scale, scale);\n                     const particleColor = preset.color.clone();\n                     // Less brightening of color to keep it closer to the original\n                     particleColor.r = Math.min(1.2, particleColor.r * 1.1);\n                     particleColor.g = Math.min(1.2, particleColor.g * 1.1);\n                     particleColor.b = Math.min(1.2, particleColor.b * 1.1);\n                    \n                    const particleMaterial = new THREE.MeshBasicMaterial({\n                        color: particleColor,\n                        transparent: true,\n                        opacity: 1.0,  // Reduced opacity\n                        side: THREE.DoubleSide,\n                        depthTest: false,\n                        depthWrite: false\n                    });\n                    \n                    for (let i = 0; i < count; i++) {\n                        const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());\n                        const angle = (i / count) * Math.PI * 2;\n                        const radius = 0.1;  // Smaller initial radius\n                        \n                        particle.position.set(\n                            neuron.position.x + Math.cos(angle) * radius,\n                            neuron.position.y + 0.05,  // Just slightly above neuron\n                            neuron.position.z + Math.sin(angle) * radius\n                        );\n                        \n                        particle.rotation.x = -Math.PI / 2;\n                        particle.renderOrder = 9999;  // Very high render order\n                        \n                        // Add to scene directly\n                        scene.add(particle);\n                        \n                        gsap.to(particle.position, {\n                            x: neuron.position.x + Math.cos(angle) * (radius * speed * 13),  // Reduced travel distance\n                            y: particle.position.y + 0.1,  // Lower maximum height\n                            z: neuron.position.z + Math.sin(angle) * (radius * speed * 13),  // Reduced travel distance\n                            duration: duration / 1000,\n                            ease: \"power2.out\"\n                        });\n                        \n                        gsap.to(particle.material, {\n                            opacity: 0,\n                            duration: duration / 1000,\n                            ease: \"power1.out\",\n                            onComplete: () => {\n                                scene.remove(particle);\n                                particle.material.dispose();\n                                particle.geometry.dispose();\n                            }\n                        });\n                    }\n                };\n                \n                // Create direct particle explosions with our fallback - using more subtle values\n                createDirectExplosion(8, 0.15, 0.75, 800);\n                \n\n            }\n            \n            // Update the neuron grid display immediately\n            if (window.updateNeuronGrid) {\n                window.updateNeuronGrid();\n            }\n        }\n        \n        // Store the preset name - handle case where presetName might be read-only\n        try {\n            // Try to set the presetName directly\n            neuron.neuron.presetName = preset.name;\n        } catch (e) {\n            // If fails, it might be a read-only property, store it in userData instead\n            console.log(\"Using alternative method to store preset name\");\n            if (!neuron.userData) neuron.userData = {};\n            neuron.userData.presetName = preset.name;\n        }\n        \n        // Create sound parameters from the preset\n        const soundParams = {\n            ...preset,\n            envelope: {\n                attack: preset.attack || 0.002,\n                decay: preset.decay || 0.3,\n                sustain: preset.sustain || 0.2,\n                release: preset.release || 0.8\n            },\n            oscillator: {\n                type: preset.oscillatorType || 'triangle'\n            },\n            filter: {\n                type: preset.filterType || 'lowpass',\n                frequency: preset.filterFrequency || 5000,\n                Q: preset.filterQ || 1\n            },\n            effects: {\n                reverbSend: preset.reverbSend || 0.2,\n                delaySend: preset.delaySend || 0.15\n            },\n            modulation: {\n                tremoloFreq: preset.tremoloFreq || 4,\n                tremoloDepth: preset.tremoloDepth || 0,\n                vibratoFreq: preset.vibratoFreq || 5,\n                vibratoDepth: preset.vibratoDepth || 0\n            }\n        };\n        \n        // Apply the sound parameters\n        window.soundManager.neuronSoundOverrides.set(neuronId, soundParams);\n        \n        // Remember this preset for future neurons\n        window.lastSelectedPreset = JSON.parse(JSON.stringify(preset)); // Deep clone\n        \n        // Special handling for color - JSON.stringify/parse loses THREE.Color type\n        if (preset.color && preset.color.isColor) {\n            // If it's a THREE.Color, create a new one and copy values\n            window.lastSelectedPreset.color = new THREE.Color();\n            window.lastSelectedPreset.color.copy(preset.color);\n        }\n        \n        // Update UI if available\n        if (window.refreshSoundControls) {\n            window.refreshSoundControls();\n        }\n        \n        // Play a test sound if preview is enabled\n        if (window.settings && window.settings.previewSounds && window.soundManager) {\n            setTimeout(() => {\n                window.soundManager.playNeuronFiring(\n                    0.5,  // medium weight\n                    0.7,  // faster speed\n                    neuronId,\n                    true, // isolated\n                    false, // hasDC\n                    0     // no distance\n                );\n            }, 100);\n        }\n        \n        return true;\n    };\n\n} catch(error) {\n    console.error(\"Error setting up Tweakpane controls:\", error);\n}\n\n// Remove any grid container we may have added to the document body\nconst existingGridContainer = document.getElementById('neuron-grid-container');\nif (existingGridContainer && existingGridContainer.parentNode) {\n    existingGridContainer.parentNode.removeChild(existingGridContainer);\n}\n\n// Initialize managers\nconst connectionManager = new ConnectionManager(scene, camera, renderer);\nconst inputManager = new InputManager(camera, renderer, connectionManager);\n\n// Make inputManager available globally for debugging\nwindow.inputManager = inputManager;\n\n// Initialize SoundManager here\nconsole.log(\"Initializing OptimizedSoundManager with oscillator bank for phase synchronization\");\nwindow.soundManager = new OptimizedSoundManager(scene, camera, renderer);\n\n// Initialize the Worker Manager to decouple UI from audio processing\nconsole.log(\"Initializing WorkerManager for decoupled audio/simulation processing\");\nwindow.workerManager = new WorkerManager(window.soundManager);\n\n// Initialize HarmonicSystem after SoundManager\nconsole.log(\"Initializing HarmonicSystem for proximity-based harmonic relationships\");\nwindow.harmonicSystem = new HarmonicSystem(scene, window.soundManager);\nconsole.log(\"Harmonic system initialized!\");\n\n// Initialize the waveform analyzer right after creating the sound manager\nsetTimeout(() => {\n    if (window.setupSpectrumAnalyzer) {\n        window.setupSpectrumAnalyzer();\n        console.log(\"Initialized waveform analyzer at startup\");\n    }\n}, 500);\n\n// Add test sound function after setup\nsetTimeout(() => {\n    // Test sound directly to make sure audio is working\n    if (window.soundManager && window.soundManager.testSound) {\n        console.log(\"Playing test sound to verify audio is working...\");\n        window.soundManager.testSound();\n    } else {\n        console.error(\"Test sound function not found!\");\n    }\n}, 1000);\n\n// Patch Neuron methods to use the worker manager\nsetTimeout(() => {\n    if (window.workerManager && window.workerManager.isInitialized) {\n        console.log(\"Patching neuron methods to use worker manager...\");\n        \n        // Replace Neuron.prototype.fire with a version that uses the worker manager\n        const originalFire = Neuron.prototype.fire;\n        Neuron.prototype.fire = function(timeOffset = 0) {\n            // Still call the original fire method for visual effects and local state\n            const result = originalFire.call(this, timeOffset);\n            \n            // If worker manager is available, let it handle the actual firing logic\n            if (window.workerManager && window.workerManager.isInitialized) {\n                // Send firing event to simulation worker\n                window.workerManager.simulationWorker.postMessage({\n                    type: 'externalInput',\n                    neuronId: this.id,\n                    value: this.threshold // Force it to reach threshold\n                });\n            }\n            \n            return result;\n        };\n        \n        // Patch setDCInput to use worker manager\n        const originalSetDCInput = Neuron.prototype.setDCInput;\n        Neuron.prototype.setDCInput = function(value) {\n            // Still call the original method for visual updates\n            const result = originalSetDCInput.call(this, value);\n            \n            // If worker manager is available, let it handle the DC logic\n            if (window.workerManager && window.workerManager.isInitialized) {\n                window.workerManager.setDCInput(this.id, value);\n            }\n            \n            return result;\n        };\n        \n        // Patch add neuron to register with worker manager\n        const originalAddNeuron = window.settings.addNeuron;\n        window.settings.addNeuron = function(position) {\n            // Call original method to create the neuron\n            const neuron = originalAddNeuron.call(this, position);\n            \n            // Register the new neuron with the worker manager\n            if (window.workerManager && window.workerManager.isInitialized && neuron) {\n                window.workerManager.addNeuron(neuron);\n            }\n            \n            return neuron;\n        };\n        \n        console.log(\"Neuron methods patched successfully!\");\n    }\n}, 1500);\n\n// Use the already declared activeNoteButton variable\nwindow.activeNoteButton = null;\n\n// Optimized neuron creation - NO label references\nfunction createNewNeuron(position = null, dcInput = null) {\n    // Create a new instance of the material for each neuron instead of sharing\n    const circleMaterial = neuronMaterial.clone();\n    \n    // Use the cloned material for this neuron\n    const circle = new THREE.Mesh(circleGeometry, circleMaterial);\n    circle.rotation.x = -Math.PI / 2;\n    \n    if (position) {\n        circle.position.set(position.x, 0.1, position.z);\n    } else {\n        circle.position.set(\n            (Math.random() - 0.5) * 10,\n            0.1,\n            (Math.random() - 0.5) * 10\n        );\n    }\n    \n    circle.scale.setScalar(0.2);\n    circle.matrixAutoUpdate = true;\n    \n    // Create color for this instance\n    let neuronColor = new THREE.Color(0x0000ff); // Default blue\n    \n    // Set color based on preset\n    if (window.lastSelectedPreset && window.lastSelectedPreset.color) {\n        if (window.lastSelectedPreset.color.isColor) {\n            neuronColor.copy(window.lastSelectedPreset.color);\n        } else if (typeof window.lastSelectedPreset.color === 'object') {\n            const r = window.lastSelectedPreset.color.r !== undefined ? window.lastSelectedPreset.color.r : 0;\n            const g = window.lastSelectedPreset.color.g !== undefined ? window.lastSelectedPreset.color.g : 0;\n            const b = window.lastSelectedPreset.color.b !== undefined ? window.lastSelectedPreset.color.b : 1;\n            neuronColor.setRGB(r, g, b);\n        } else {\n            neuronColor.set(window.lastSelectedPreset.color);\n        }\n    } else if (window.activePreset && window.activePreset.color) {\n        if (window.activePreset.color.isColor) {\n            neuronColor.copy(window.activePreset.color);\n        } else {\n            neuronColor.set(window.activePreset.color);\n        }\n    }\n    \n    // Apply color directly to the material\n    circleMaterial.color.copy(neuronColor);\n    \n    // Store the current color for later reference \n    circle.userData.originalColor = neuronColor.clone();\n    \n    // Create the larger invisible touch area\n    const touchArea = new THREE.Mesh(touchGeometry, touchMaterial);\n    touchArea.rotation.x = -Math.PI / 2;\n    touchArea.position.copy(circle.position);\n    \n    // Make touch areas much larger, especially on mobile devices\n    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    const touchScale = isMobile ? 0.1 : 0.2; // Increased from 3.0 to 8.0 for desktop\n    \n    touchArea.scale.setScalar(touchScale);\n    touchArea.matrixAutoUpdate = true;\n    touchArea.visible = false; // Invisible touch area\n    touchArea.isHitArea = true;  // Flag to identify the hit area\n    touchArea.parentCircle = circle;  // Reference to the parent circle\n    \n    // Add the touch area to the scene\n    scene.add(touchArea);\n    \n    // Store the touch area reference\n    circle.touchArea = touchArea;\n    \n    const neuron = new Neuron(circle);\n    circle.neuron = neuron;\n    \n    // Add the circle to the scene\n    scene.add(circle);\n    \n    // Make sure the neuron has a note assigned immediately\n    if (window.soundManager) {\n        // Assign a note right away\n        window.soundManager.assignFrequencyRange(neuron.id);\n        \n        // Apply sound parameters to the new neuron\n        if (window.soundManager.neuronSoundOverrides) {\n            let paramToUse;\n            \n            // First priority: Use lastSelectedPreset if available\n            if (window.lastSelectedPreset) {\n\n                \n                // Clone params but keep special handling for the color object\n                paramToUse = JSON.parse(JSON.stringify(window.lastSelectedPreset)); \n                \n                // Apply volume adjustment for specific instrument types\n                if (window.adjustVolumeForInstrumentType) {\n                    window.adjustVolumeForInstrumentType(paramToUse);\n                }\n                \n                // Restore the proper color object that might have been lost in JSON serialization\n                if (window.lastSelectedPreset.color) {\n                    if (window.lastSelectedPreset.color.isColor) {\n                        paramToUse.color = window.lastSelectedPreset.color;\n                    } else if (typeof window.lastSelectedPreset.color === 'object') {\n                        const r = window.lastSelectedPreset.color.r !== undefined ? window.lastSelectedPreset.color.r : 0;\n                        const g = window.lastSelectedPreset.color.g !== undefined ? window.lastSelectedPreset.color.g : 0;\n                        const b = window.lastSelectedPreset.color.b !== undefined ? window.lastSelectedPreset.color.b : 1;\n                        paramToUse.color = new THREE.Color(r, g, b);\n                    } else {\n                        paramToUse.color = new THREE.Color(window.lastSelectedPreset.color);\n                    }\n                }\n                \n                // Store the color and name in the neuron for reference\n                neuron.presetColor = circle.material.color.clone();\n                neuron.presetName = paramToUse.name || \"Remembered Preset\";\n            }\n            // Second priority: Use soundManager's lastSelectedNeuronParams\n            else if (window.soundManager.lastSelectedNeuronParams) {\n\n                paramToUse = JSON.parse(JSON.stringify(window.soundManager.lastSelectedNeuronParams));\n                \n                // Apply color if available\n                if (paramToUse.color) {\n                    // Apply color to the neuron's material\n                    if (typeof paramToUse.color === 'object' && paramToUse.color.isColor) {\n                        circle.material.color.copy(paramToUse.color);\n                        neuron.presetColor = paramToUse.color.clone ? paramToUse.color.clone() : new THREE.Color(paramToUse.color);\n                    } else if (typeof paramToUse.color === 'object') {\n                        const color = new THREE.Color(\n                            paramToUse.color.r !== undefined ? paramToUse.color.r : 0,\n                            paramToUse.color.g !== undefined ? paramToUse.color.g : 0,\n                            paramToUse.color.b !== undefined ? paramToUse.color.b : 1\n                        );\n                        circle.material.color.copy(color);\n                        neuron.presetColor = color;\n                    }\n                    \n                    neuron.presetName = paramToUse.name || \"Custom Sound\";\n\n                }\n            }\n            // Third priority: Use a random preset from defaults\n            else {\n\n                const randomPresetIndex = Math.floor(Math.random() * defaultPresets.length);\n                const randomPreset = defaultPresets[randomPresetIndex];\n                paramToUse = randomPreset;\n                \n                // Also set the preset color and name\n                if (randomPreset.color) {\n                    // Apply color to the neuron's material\n                    circle.material.color.copy(randomPreset.color);\n                    \n                    // Store preset color and name\n                    neuron.presetColor = randomPreset.color.clone();\n                    neuron.presetName = randomPreset.name;\n                    \n\n                }\n            }\n            \n\n            \n            // Create sound overrides from the selected parameters with special care to handle nested properties\n            const soundParams = {\n                // Copy top-level properties\n                ...paramToUse,\n                \n                // Create envelope structure properly\n                envelope: {\n                    attack: paramToUse.attack || (paramToUse.envelope ? paramToUse.envelope.attack : undefined) || 0.002,\n                    decay: paramToUse.decay || (paramToUse.envelope ? paramToUse.envelope.decay : undefined) || 0.3,\n                    sustain: paramToUse.sustain || (paramToUse.envelope ? paramToUse.envelope.sustain : undefined) || 0.2,\n                    release: paramToUse.release || (paramToUse.envelope ? paramToUse.envelope.release : undefined) || 0.8,\n                    attackCurve: paramToUse.attackCurve || (paramToUse.envelope ? paramToUse.envelope.attackCurve : undefined) || \"exponential\",\n                    decayCurve: paramToUse.decayCurve || (paramToUse.envelope ? paramToUse.envelope.decayCurve : undefined) || \"exponential\",\n                    releaseCurve: paramToUse.releaseCurve || (paramToUse.envelope ? paramToUse.envelope.releaseCurve : undefined) || \"exponential\"\n                },\n                \n                // Create oscillator structure properly\n                oscillator: {\n                    type: paramToUse.oscillatorType || (paramToUse.oscillator ? paramToUse.oscillator.type : undefined) || \"triangle\"\n                },\n                \n                // Create filter structure properly\n                filter: {\n                    type: paramToUse.filterType || (paramToUse.filter ? paramToUse.filter.type : undefined) || \"lowpass\",\n                    frequency: paramToUse.filterFrequency || (paramToUse.filter ? paramToUse.filter.frequency : undefined) || 5000,\n                    Q: paramToUse.filterQ || (paramToUse.filter ? paramToUse.filter.Q : undefined) || 1\n                },\n                \n                // Create effects structure properly\n                effects: {\n                    reverbSend: paramToUse.reverbSend || (paramToUse.effects ? paramToUse.effects.reverbSend : undefined) || 0.2,\n                    delaySend: paramToUse.delaySend || (paramToUse.effects ? paramToUse.effects.delaySend : undefined) || 0.15\n                },\n                \n                // Create modulation structure properly\n                modulation: {\n                    tremoloFreq: paramToUse.tremoloFreq || (paramToUse.modulation ? paramToUse.modulation.tremoloFreq : undefined) || 4,\n                    tremoloDepth: paramToUse.tremoloDepth || (paramToUse.modulation ? paramToUse.modulation.tremoloDepth : undefined) || 0,\n                    vibratoFreq: paramToUse.vibratoFreq || (paramToUse.modulation ? paramToUse.modulation.vibratoFreq : undefined) || 5,\n                    vibratoDepth: paramToUse.vibratoDepth || (paramToUse.modulation ? paramToUse.modulation.vibratoDepth : undefined) || 0\n                },\n                \n                // Store name explicitly\n                name: paramToUse.name\n            };\n            \n            window.soundManager.neuronSoundOverrides.set(neuron.id, soundParams);\n\n        }\n        \n        // Only play initial sound if preview sounds are enabled\n        if (window.settings && window.settings.previewSounds) {\n        setTimeout(() => {\n            window.soundManager.playNeuronFiring(\n                0.5,  // medium weight\n                0.7,  // faster speed\n                neuron.id,\n                true, // isolated\n                dcInput > 0, // hasDC\n                0 // no distance\n            );\n        }, 100);\n        }\n    }\n    \n    if (dcInput !== null) {\n        neuron.dcInput = dcInput;\n        neuron.currentCharge = dcInput;\n        \n        if (dcInput === 1.0) {\n            setTimeout(() => {\n                neuron.fire();\n            }, 200);\n        }\n    }\n    \n    // Make sure to update the neuron grid display to show the new neuron with its color\n    if (window.updateNeuronGrid) {\n        setTimeout(() => window.updateNeuronGrid(), 200);\n    }\n    \n    // Add visual feedback animation for new neuron creation\n    circle.neuron.createParticleExplosion();\n    \n    return circle;\n}\n\n// Animation loop - now called by SceneManager\nfunction animate(currentTime, deltaTime, fps) {\n    // Update connection manager\n    connectionManager.updateAllConnections();\n    \n    // Update neurons\n    window.circles.forEach(circle => {\n        if (circle.neuron) {\n            circle.neuron.update();\n        }\n    });\n    \n    // Update the harmonic system every frame - important for visual feedback\n    if (window.harmonicSystem) {\n        window.harmonicSystem.update();\n        \n        // Ensure harmonic visualization always works by forcing minimum values\n        if (window.harmonicSystem.harmonyStrength < 0.1) {\n            window.harmonicSystem.harmonyStrength = 0.1;\n        }\n    }\n    \n    // Update particles using the optimized particle system\n    if (window.particleSystem && typeof window.particleSystem.update === 'function') {\n        window.particleSystem.update(deltaTime);\n    } else if (window.workerManager && typeof window.workerManager.updateParticles === 'function') {\n        window.workerManager.updateParticles(deltaTime);\n    }\n    \n    // The legacy particle system code has been removed in favor of OptimizedParticleSystem\n    \n    // Real-time update of hover label if a neuron is currently being hovered\n    if (window.currentHoveredNeuron && uiManager.neuronHoverLabel.style.display === 'block') {\n        const neuron = window.currentHoveredNeuron;\n        if (neuron && neuron.neuron) {\n            const dcInput = neuron.neuron.dcInput.toFixed(2);\n            const charge = neuron.neuron.currentCharge.toFixed(2);\n            const id = neuron.neuron.id;\n            const chargePercent = Math.round(neuron.neuron.currentCharge * 100);\n            // Get preset name from userData or via the getter method\n            let presetName = '';\n            if (neuron.userData && neuron.userData.presetName) {\n                presetName = neuron.userData.presetName;\n            } else if (neuron.neuron && neuron.neuron.getPresetName && typeof neuron.neuron.getPresetName === 'function') {\n                presetName = neuron.neuron.getPresetName();\n            } else if (neuron.neuron && neuron.neuron.presetName) {\n                // Fallback to direct property if we can access it\n                presetName = neuron.neuron.presetName;\n            }\n            \n            // Get preset color and convert to CSS color\n            let colorStyle = '';\n            if (neuron.neuron.presetColor) {\n                const color = neuron.neuron.presetColor;\n                // Convert THREE.Color (0-1 range) to RGB format (0-255 range)\n                const r = Math.floor(color.r * 255);\n                const g = Math.floor(color.g * 255);\n                const b = Math.floor(color.b * 255);\n                colorStyle = `color: rgb(${r}, ${g}, ${b}); text-shadow: 0 0 2px rgba(0,0,0,0.5);`;\n            }\n            \n            // Update the hover label with current info\n            // Simplified HTML with cleaner layout\n            uiManager.neuronHoverLabel.innerHTML = `\n                <div class=\"neuron-info-header ${presetName ? 'with-preset' : ''}\" style=\"${colorStyle}\">\n                    <span class=\"neuron-id\">N${id}</span>\n                    <span class=\"neuron-preset\">${presetName || ''}</span>\n                </div>\n                <div class=\"neuron-info-stats\">\n                    <div class=\"stat-group\">\n                        <div class=\"stat-label\">Charge:</div>\n                        <div class=\"stat-value\">${charge} (${chargePercent}%)</div>\n                    </div>\n                    <div class=\"stat-group\">\n                        <div class=\"stat-label\">DC Input:</div>\n                        <div class=\"stat-value\">${dcInput}</div>\n                    </div>\n                </div>\n            `;\n        }\n    }\n}\n\nfunction setupInitialNetwork() {\n    // Helper function to find a preset by name\n    const findPresetByName = (name) => {\n        if (!window.defaultPresets) return null;\n        return window.defaultPresets.find(preset => preset.name === name);\n    };\n\n    const initialSetup = [\n        { position: { x: -2, z: -3 }, dc: 0.25, preset: \"Bass\" },        // Neuron 1: DC 0.25, Bass\n        { position: { x: 2, z: -3 }, dc: 0.1, preset: \"Bright Hi-Hat\" }, // Neuron 2: DC 0.1, Hi-Hat\n        { position: { x: 0, z: 1 }, dc: 0.0, preset: \"Pad\" }             // Neuron 3: DC 0, Pad\n    ];\n\n    const connections = [\n        { from: 0, to: 1, weight: 0.2, speed: 0.5 },\n        { from: 1, to: 2, weight: 0.2, speed: 0.5 },\n        { from: 2, to: 0, weight: 0.2, speed: 0.7 }\n    ];\n\n    // First, set up the presets so new neurons will be created with them\n    initialSetup.forEach((setup, index) => {\n        // Find the preset by name\n        const preset = findPresetByName(setup.preset);\n        \n        // If we found the preset, remember it temporarily\n        if (preset) {\n            // Store for the next neuron creation\n            window.lastSelectedPreset = JSON.parse(JSON.stringify(preset));\n            \n            // Special handling for color property\n            if (preset.color && preset.color.isColor) {\n                window.lastSelectedPreset.color = new THREE.Color();\n                window.lastSelectedPreset.color.copy(preset.color);\n            }\n            \n            // Create the neuron with the specific preset\n        const neuron = createNewNeuron(setup.position, 0); // Start with 0 DC\n        window.circles.push(neuron);\n        scene.add(neuron);\n            \n            // --- Ensure neuron 1 is set to F2 and no custom override ---\n            if (index === 0 && window.soundManager) {\n                // Assign F2 as the note (will set baseFreq)\n                window.soundManager.assignFrequencyRange(neuron.neuron.id);\n                // Remove any custom note override for neuron 1\n                if (window.soundManager.neuronSoundOverrides) {\n                    const overrides = window.soundManager.neuronSoundOverrides.get(neuron.neuron.id);\n                    if (overrides && overrides.note) {\n                        delete overrides.note;\n                    }\n                }\n                // Also ensure customFreq is null\n                if (window.soundManager.neuronFrequencies) {\n                    const freqData = window.soundManager.neuronFrequencies.get(neuron.neuron.id);\n                    if (freqData) {\n                        freqData.customFreq = null;\n                    }\n                }\n            }\n            // --- End F2 enforcement ---\n        } else {\n            console.warn(`Preset ${setup.preset} not found, using random preset`);\n            const neuron = createNewNeuron(setup.position, 0);\n            window.circles.push(neuron);\n            scene.add(neuron);\n        }\n    });\n\n    setTimeout(() => {\n        try {\n        // Set DC inputs using the proper method\n        window.circles.forEach((circle, index) => {\n                if (circle.neuron && initialSetup[index]) { // Added check for index bounds\n                circle.neuron.setDCInput(initialSetup[index].dc);\n            }\n        });\n\n        // Create connection array to track all created connections\n        const createdConnections = [];\n\n        connections.forEach(({ from, to, weight, speed }) => {\n                // Add checks for valid indices\n                if (from < window.circles.length && to < window.circles.length) {\n            const connection = connectionManager.createConnection(\n                window.circles[from],\n                window.circles[to]\n            );\n\n            if (connection) {\n                const connectionData = connectionManager.connections.get(connection);\n                if (connectionData) {\n                    connectionData.weight = weight;\n                    connectionData.speed = speed;\n                            // Check if neuron exists before calling methods\n                            if (window.circles[from]?.neuron) {\n                    window.circles[from].neuron.updateConnectionWeight(to, weight);\n                    window.circles[from].neuron.updateConnectionSpeed(to, speed);\n                }\n                    // Store connection for later update\n                    createdConnections.push(connection);\n                        }\n                    }\n                } else {\n                    console.warn(`Invalid connection indices: from ${from}, to ${to}`);\n                }\n            });\n            \n            // Update neuron grid after setup\n            if (window.updateNeuronGrid) {\n                window.updateNeuronGrid();\n            }\n\n            // Force multiple updates of each connection to ensure they're properly initialized\n            setTimeout(() => {\n                // Extra initialization for each connection\n                createdConnections.forEach(connectionGroup => {\n                    connectionManager.updateConnection(connectionGroup);\n                });\n                \n                // Reset lastSelectedPreset to avoid affecting future neuron creation\n                window.lastSelectedPreset = null;\n                \n            }, 300);\n            \n        } catch (error) {\n            console.error(\"Error setting up initial network connections:\", error);\n        }\n    }, 100);\n}\n\n// Export this function to global scope for the UIManager start button\nwindow.setupInitialNetwork = setupInitialNetwork;\n\n// Resize handling is now managed by SceneManager\n\n// Exports\nwindow.scene = scene;\nwindow.THREE = THREE;\nwindow.Neuron = Neuron; // Add Neuron class to window object for global access\nwindow.Neuron.allParticles = []; // Initialize the particles array\nwindow.sceneManager = sceneManager; // Export sceneManager globally\n\n// Set up global isMobile and UI-related functions for external components to use\nwindow.isMobile = function() {\n    return uiManager.isMobile();\n};\n\nwindow.updateSynthPanelMobileView = function() {\n    // Just mark the panel with data attribute for CSS to handle positioning\n    if (!window.selectedSynthFolder || !window.selectedSynthFolder.element) return;\n    \n    const panel = window.selectedSynthFolder.element;\n    panel.dataset.synthPanel = 'true';\n};\n\nwindow.toggleSynthPanelMobile = function() {\n    uiManager.toggleSynthPanelMobile();\n};\n\nwindow.hideSynthPanelOnMobile = function() {\n    uiManager.hideSynthPanelOnMobile();\n};\n\n// Tweakpane draggability handled by UIManager\n\n// SelectionRing removed as it's not needed\n\n// Store the original window.updateNeuronGrid function as a fallback\nif (window.updateNeuronGrid && !window._originalUpdateNeuronGrid) {\n  window._originalUpdateNeuronGrid = window.updateNeuronGrid;\n}\n\n// Make sure stateManager is added to window for global access\nwindow.stateManager = stateManager;\nwindow.reactiveManager = reactiveManager;\n\n// Start animation using SceneManager\nsceneManager.startAnimation(animate);\n\n// Add this function to force a complete refresh of the sound controls\nwindow.refreshSoundControls = function() {\n    if (window.selectedSynthFolder) {\n        try {\n            // Get the currently selected neuron ID from soundManager\n            const selectedNeuronId = window.soundManager?.selectedNeuronId;\n\n    \n            // Re-fetch the parameters directly if we have a selected neuron\n            if (selectedNeuronId && window.soundManager) {\n                const params = window.soundManager.getNeuronSoundParameters(selectedNeuronId);\n    \n                \n                if (params) {\n                    // Update window.settings with the freshly retrieved parameters\n                    window.settings.selectedAttack = params.envelope?.attack || params.attack;\n                    window.settings.selectedDecay = params.envelope?.decay || params.decay;\n                    window.settings.selectedSustain = params.envelope?.sustain || params.sustain;\n                    window.settings.selectedRelease = params.envelope?.release || params.release;\n                    window.settings.selectedPitchDecay = params.pitchDecay || 0.05;\n                    window.settings.selectedDetune = params.detune || 0;\n                    window.settings.selectedNeuronVolume = params.neuronVolume || 0;\n                    window.settings.selectedNote = params.note || null;\n                    window.settings.selectedOscillatorType = params.oscillator?.type || params.oscillatorType || \"triangle\";\n                    window.settings.selectedUseSustainedTone = params.useSustainedTone ?? false;\n                    window.settings.selectedFilterType = params.filter?.type || params.filterType || \"lowpass\";\n                    window.settings.selectedFilterFrequency = params.filter?.frequency || params.filterFrequency || 5000;\n                    window.settings.selectedFilterQ = params.filter?.Q || params.filterQ || 1;\n                    window.settings.selectedReverbSend = params.effects?.reverbSend || params.reverbSend || 0.2;\n                    window.settings.selectedDelaySend = params.effects?.delaySend || params.delaySend || 0.15;\n                    window.settings.selectedTremoloFreq = params.modulation?.tremoloFreq || params.tremoloFreq || 4;\n                    window.settings.selectedTremoloDepth = params.modulation?.tremoloDepth || params.tremoloDepth || 0;\n                    window.settings.selectedVibratoFreq = params.modulation?.vibratoFreq || params.vibratoFreq || 5;\n                    window.settings.selectedVibratoDepth = params.modulation?.vibratoDepth || params.vibratoDepth || 0;\n                    \n                    // Check if the parameters match any preset and highlight it if found\n                    if (typeof findMatchingPreset === 'function') {\n                        const matchedPreset = findMatchingPreset(params);\n                        if (matchedPreset) {\n                            highlightPresetButton(matchedPreset.name);\n                        } else {\n                            // No preset matches, unhighlight any active preset\n                            unhighlightActivePreset();\n                        }\n                    }\n                    \n\n                }\n            }\n            \n            // Refresh the folder first\n            window.selectedSynthFolder.refresh();\n            \n            // Loop through and refresh each child control\n            if (window.selectedSynthFolder.children) {\n                window.selectedSynthFolder.children.forEach(control => {\n                    if (control && control.refresh) {\n                        control.refresh();\n                    }\n                });\n    }\n    \n            // Force the envelope visualization to update\n            if (window.forceRenderEnvelope) {\n                window.forceRenderEnvelope();\n            }\n            \n            // Update note button UI if needed\n            if (window.updateActiveNoteButton && window.settings.selectedNote) {\n                window.updateActiveNoteButton(window.settings.selectedNote);\n            }\n            \n\n        } catch (error) {\n            console.error(\"Error refreshing sound controls:\", error);\n        }\n    }\n};\n\n// Add helper function to find a matching preset based on parameters\nwindow.findMatchingPreset = function(params) {\n    if (!window.defaultPresets || !params) return null;\n    \n    // Look through all presets to find a match\n    for (const preset of window.defaultPresets) {\n        // Check core parameters for a match (we use fuzzy matching with small tolerance)\n        const attackMatch = Math.abs(preset.attack - (params.envelope?.attack || params.attack || 0)) < 0.01;\n        const decayMatch = Math.abs(preset.decay - (params.envelope?.decay || params.decay || 0)) < 0.01;\n        const sustainMatch = Math.abs(preset.sustain - (params.envelope?.sustain || params.sustain || 0)) < 0.05;\n        const releaseMatch = Math.abs(preset.release - (params.envelope?.release || params.release || 0)) < 0.05;\n        const oscTypeMatch = preset.oscillatorType === (params.oscillator?.type || params.oscillatorType);\n        \n        // If all core parameters match, we consider it a match\n        if (attackMatch && decayMatch && sustainMatch && releaseMatch && oscTypeMatch) {\n\n            return preset;\n        }\n    }\n    \n    return null;\n};\n\n// Add a helper function to stop random sounds\nwindow.stopRandomSounds = function() {\n    if (window.randomSoundsTimerId) {\n        clearTimeout(window.randomSoundsTimerId);\n        window.randomSoundsTimerId = null;\n        \n    }\n};\n\n\n\n// Import application architecture components\nimport { appInitializer } from './components/AppInitializer.js';\nimport { stateManager } from './components/StateManager.js';\nimport { reactiveManager } from './components/ReactiveManager.js';\n\n// Defer initialization to ensure all components are loaded before app architecture setup\nsetTimeout(() => {\n  try {\n    // Initialize application architecture with all core components\n    appInitializer.initialize({\n      uiManager,\n      soundManager: window.soundManager,\n      workerManager: window.workerManager, // Add worker manager to app initializer\n      connectionManager,\n      sceneManager,\n      settings: window.settings,\n      circles: window.circles,\n      updateNeuronGrid: window.updateNeuronGrid\n    });\n    // Application architecture successfully initialized\n  } catch (error) {\n    console.error(\"Error initializing application architecture:\", error);\n  }\n}, 500);\n\ninputManager.cleanup = function() {\n    // Restore all original methods\n    Object.keys(this.originalHandlers).forEach(component => {\n      Object.keys(this.originalHandlers[component]).forEach(methodName => {\n        component[methodName] = this.originalHandlers[component][methodName];\n      });\n    });\n    \n    // Clear all handlers\n    this.handlers = {};\n    this.originalHandlers = {};\n    \n    // Clean up event listeners\n    if (window.eventManager) {\n      window.eventManager.cleanupComponent('eventSystem');\n    } else {\n      document.removeEventListener('click', this.handleGlobalEvent.bind(this, 'click'), false);\n      document.removeEventListener('dblclick', this.handleGlobalEvent.bind(this, 'dblclick'), false);\n      document.removeEventListener('touchend', this.handleGlobalEvent.bind(this, 'touchend'), false);\n      document.removeEventListener('touchstart', this.handleGlobalEvent.bind(this, 'touchstart'), false);\n    }\n}\n\n// Add this near the bottom of main.js, after all components are initialized\n// Direct fix for mouse events - ensures events are properly forwarded to InputManager\nsetTimeout(() => {\n  // Backup original event handler and capture all dblclick events at document level\n  document.addEventListener('dblclick', function(event) {\n    // Stop event propagation only if it's heading to the document handler from EventSystem\n    const isOnCanvas = event.target === renderer.domElement;\n    \n    if (isOnCanvas && inputManager && inputManager.onDoubleClickBound) {\n      // If it's on the canvas, manually call InputManager's handler and prevent further propagation\n      inputManager.onDoubleClickBound(event);\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }, true); // Use capture phase to intercept before EventSystem\n  \n  // Similar approach for wheel events\n  document.addEventListener('wheel', function(event) {\n    const isOnCanvas = event.target === renderer.domElement;\n    \n    if (isOnCanvas) {\n      // Check if we're hovering over an arrow first\n      const rect = renderer.domElement.getBoundingClientRect();\n      const mouse = new THREE.Vector2(\n        ((event.clientX - rect.left) / rect.width) * 2 - 1,\n        -((event.clientY - rect.top) / rect.height) * 2 + 1\n      );\n      \n      // Create a raycaster to check for arrow intersections\n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(mouse, camera);\n      \n      // Set a larger threshold for better arrow detection\n      if (raycaster.params.Line) {\n        raycaster.params.Line.threshold = 5;\n      }\n      \n      // Get all arrows from the connection manager\n      let isOverArrow = false;\n      if (connectionManager && connectionManager.connections) {\n        const arrows = Array.from(connectionManager.connections.values())\n          .map(conn => conn.arrow)\n          .filter(Boolean);\n          \n        // Check if we're intersecting any arrows\n        const intersects = raycaster.intersectObjects(arrows);\n        isOverArrow = intersects.length > 0;\n      }\n      \n      // Only let InputManager handle the wheel event if we're not over an arrow\n      if (!isOverArrow && inputManager && inputManager.onWheelBound) {\n        inputManager.onWheelBound(event);\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    }\n  }, { capture: true, passive: false });\n  \n  console.log('Applied direct event forwarding patch to fix mouse interactions');\n}, 1000); // Wait for all other initializations to complete\n\n// Make tutorial available globally\nwindow.startTutorial = function() {\n    if (window.uiManager) {\n        window.uiManager.startTutorial();\n    }\n};\n\n// Create help button for tutorial access after starting\nfunction createHelpButton() {\n    const helpButton = document.createElement('button');\n    helpButton.textContent = '?';\n    helpButton.style.position = 'fixed';\n    helpButton.style.bottom = '20px';  // Match neuron settings button position\n    helpButton.style.right = '20px';\n    helpButton.style.width = '30px';\n    helpButton.style.height = '30px';\n    \n    helpButton.style.backgroundColor = 'rgba(85, 85, 85, 0.7)';  // Grey color\n    helpButton.style.color = 'white';\n    helpButton.style.border = 'none';\n    helpButton.style.fontSize = '16px';\n    helpButton.style.fontWeight = 'bold';\n    helpButton.style.cursor = 'pointer';\n    helpButton.style.zIndex = '1000';\n    helpButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';\n    helpButton.style.display = 'flex';\n    helpButton.style.alignItems = 'center';\n    helpButton.style.justifyContent = 'center';\n    helpButton.title = 'Tutorial';\n    \n    // Add hover effect\n    helpButton.addEventListener('mouseenter', () => {\n        helpButton.style.backgroundColor = 'rgba(102, 102, 102, 0.9)';  // Lighter grey on hover\n        helpButton.style.boxShadow = '0 2px 6px rgba(0,0,0,0.4)';\n    });\n    \n    helpButton.addEventListener('mouseleave', () => {\n        helpButton.style.backgroundColor = 'rgba(85, 85, 85, 0.7)';  // Back to original grey\n        helpButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';\n    });\n    \n    helpButton.addEventListener('click', () => {\n        window.startTutorial();\n    });\n    \n    document.body.appendChild(helpButton);\n}\n\n// Create help button\ncreateHelpButton();\n\n// Continue with any other initialization code\n// ... existing code ...","import * as THREE from 'three';\nimport Logger from './utils/logger';\n\nimport { initEffectsSystem } from './effects/initEffectsSystem';\nimport { enableCentralizedNeuralSystem } from './core/integrator';\nimport { FluidBackgroundEffect } from './FluidBackgroundEffect';\nimport { OptimizedParticleSystem } from './OptimizedParticleSystem';\n\nexport class SceneManager {\n    constructor() {\n        // Core scene components\n        this.scene = null;\n        this.camera = null;\n        this.renderer = null;\n        \n        // Scene settings\n        this.frustumSize = 20; // Match original frustum size from main.js\n        this.backgroundColor = 0x000000; // Match original black background\n        \n        // Stats and metrics\n        this.frameCount = 0;\n        this.startTime = performance.now();\n        this.lastTime = this.startTime;\n\n        // Animation\n        this.isAnimating = false;\n        this.animationFrameId = null;\n        \n        // Setup core components\n        this.initScene();\n        this.initCamera();\n        this.initRenderer();\n        \n        // Initialize fluid background effect first, before any other scene objects\n        this.initFluidBackground();\n        \n        this.setupLighting();\n        this.setupEventListeners();\n        \n        // Initialize particle system before effects system\n        this.initParticleSystem();\n        \n        // Initialize effects system\n        this.initEffectsSystem();\n        \n        // Initialize centralized neural system\n        this.initCentralizedNeuralSystem();\n    }\n    \n    initScene() {\n        // Create scene with minimal settings matching the original\n        this.scene = new THREE.Scene();\n        // Make scene background transparent so our fluid shader is visible\n        this.scene.background = null;\n        \n        // Match original scene settings\n        this.scene.matrixAutoUpdate = false; // Disable automatic matrix updates\n    }\n    \n    initCamera() {\n        // Create orthographic camera\n        const aspect = window.innerWidth / window.innerHeight;\n        this.camera = new THREE.OrthographicCamera(\n            -this.frustumSize * aspect / 2,\n            this.frustumSize * aspect / 2,\n            this.frustumSize / 2,\n            -this.frustumSize / 2,\n            0.1,\n            1000\n        );\n        \n        // Position camera for a top-down view - match original position\n        this.camera.position.set(0, 10, 0);\n        this.camera.lookAt(0, 0, 0);\n        this.camera.rotation.z = 0;\n        this.camera.updateMatrix();\n        this.camera.updateMatrixWorld();\n    }\n    \n    initRenderer() {\n        // Create WebGL renderer with optimized settings but not too aggressive\n        this.renderer = new THREE.WebGLRenderer({\n            antialias: false,                 // Disable antialiasing for performance\n            powerPreference: 'high-performance', // Request high-performance GPU\n            precision: 'mediump',             // Use medium precision for better performance\n            logarithmicDepthBuffer: false     // Disable depth buffer for performance\n        });\n        \n        // Set renderer size and pixel ratio - using a fixed ratio for consistency\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.setPixelRatio(1); // Fixed pixel ratio for consistent performance\n        \n        // Keep sortObjects true to ensure proper rendering order\n        this.renderer.sortObjects = true;\n        \n        // Set dark grey background color with full alpha\n        this.renderer.setClearColor(0x111111, 1);\n        \n        // Append renderer to DOM\n        document.body.appendChild(this.renderer.domElement);\n        \n        // Log for debugging\n        console.log('Renderer initialized with dark grey background');\n    }\n    \n    setupLighting() {\n        // Better lighting to make connections visible\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n        this.scene.add(ambientLight);\n        \n        // Add directional light to improve visibility\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n        directionalLight.position.set(5, 10, 5);\n        this.scene.add(directionalLight);\n    }\n    \n    setupEventListeners() {\n        const componentId = 'sceneManager';\n        \n        // Bind the resize handler\n        this.handleResize = this.handleResize.bind(this);\n        \n        // Use eventManager if available\n        if (window.eventManager) {\n            window.eventManager.registerComponent(componentId, this);\n            window.eventManager.addEventListener(window, 'resize', this.handleResize, false, componentId);\n        } else {\n            // Handle window resize\n            window.addEventListener('resize', this.handleResize, false);\n        }\n    }\n    \n    handleResize() {\n        // Update aspect ratio\n        const aspect = window.innerWidth / window.innerHeight;\n        \n        // Update camera frustum\n        this.camera.left = -this.frustumSize * aspect / 2;\n        this.camera.right = this.frustumSize * aspect / 2;\n        this.camera.top = this.frustumSize / 2;\n        this.camera.bottom = -this.frustumSize / 2;\n        this.camera.updateProjectionMatrix();\n        \n        // Update renderer size\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    \n    startAnimation(animateCallback) {\n        // Store the callback\n        this.animateCallback = animateCallback;\n        \n        // Bind the animation method\n        this._animate = this._animate.bind(this);\n        \n        // Start the animation\n        if (window.timerManager) {\n            // Use timerManager for animation frame\n            this.animationId = window.timerManager.requestAnimationFrame('sceneManager', this._animate);\n        } else {\n            // Fallback to direct requestAnimationFrame\n            this.animationId = requestAnimationFrame(this._animate);\n        }\n    }\n    \n    stopAnimation() {\n        if (window.timerManager && this.animationId) {\n            window.timerManager.cancelAnimationFrame('sceneManager', this.animationId);\n        } else if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n        }\n        this.animationId = null;\n    }\n    \n    _animate(timestamp) {\n        // Calculate delta time since last frame\n        const deltaTime = (timestamp - this.lastTime) / 1000; // convert to seconds\n        this.lastTime = timestamp;\n        \n        // Cap delta time to prevent huge jumps after tab inactivity\n        const clampedDeltaTime = Math.min(deltaTime, 0.1);\n        \n        // Increment frame counter\n        this.frameCount++;\n        \n        // Calculate FPS (every 20 frames to avoid too frequent updates)\n        if (this.frameCount % 20 === 0) {\n            const elapsedTime = (timestamp - this.startTime) / 1000;\n            const fps = Math.round((this.frameCount / elapsedTime) * 10) / 10;\n            \n            // Update any FPS counter if available\n            if (window.uiManager && typeof window.uiManager.updateFPSCounter === 'function') {\n                window.uiManager.updateFPSCounter(fps);\n            }\n        }\n        \n        // Update the particle system if available - BEFORE rendering\n        if (window.particleSystem && typeof window.particleSystem.update === 'function') {\n            try {\n                window.particleSystem.update(clampedDeltaTime);\n            } catch (error) {\n                console.error('Error updating particle system:', error);\n            }\n        }\n        \n        // Call custom animation callback if provided\n        if (this.animateCallback) {\n            this.animateCallback(timestamp, clampedDeltaTime, this.frameCount);\n        }\n        \n        // Update fluid background effect if available\n        if (this.fluidBackground) {\n            // Call render instead of update for the fluid background\n            this.fluidBackground.render(this.renderer);\n        }\n        \n        // Render the scene with our camera\n        this.renderer.render(this.scene, this.camera);\n        \n        // Continue animation loop\n        if (this.isAnimating) {\n            if (window.timerManager) {\n                this.animationId = window.timerManager.requestAnimationFrame('sceneManager', this._animate);\n            } else {\n                this.animationId = requestAnimationFrame(this._animate);\n            }\n        }\n    }\n    \n    addToScene(object) {\n        this.scene.add(object);\n    }\n    \n    removeFromScene(object) {\n        this.scene.remove(object);\n    }\n    \n    getScene() {\n        return this.scene;\n    }\n    \n    getCamera() {\n        return this.camera;\n    }\n    \n    getRenderer() {\n        return this.renderer;\n    }\n    \n    initFluidBackground() {\n        // Create the fluid background effect\n        this.fluidBackground = new FluidBackgroundEffect(this.scene, this.camera);\n    }\n    \n    initParticleSystem() {\n        // Create the optimized particle system and make it globally available\n        if (this.scene) {\n            Logger.debug('[SceneManager] Initializing OptimizedParticleSystem');\n            window.particleSystem = new OptimizedParticleSystem(this.scene, 2000);\n            Logger.info('[SceneManager] OptimizedParticleSystem initialized with 2000 max particles');\n            \n            // Clean up any legacy particles\n            this.cleanupLegacyParticles();\n        }\n    }\n    \n    cleanupLegacyParticles() {\n        // Clean up legacy particles to free memory\n        if (window.Neuron && window.Neuron.allParticles && window.Neuron.allParticles.length > 0) {\n            Logger.info(`[SceneManager] Cleaning up ${window.Neuron.allParticles.length} legacy particles`);\n            \n            // Remove all legacy particles from the scene\n            for (const particle of window.Neuron.allParticles) {\n                if (particle && particle.parent) {\n                    particle.parent.remove(particle);\n                    \n                    // Dispose resources\n                    if (particle.material) particle.material.dispose();\n                    if (particle.geometry) particle.geometry.dispose();\n                }\n            }\n            \n            // Clear the array\n            window.Neuron.allParticles = [];\n            \n            Logger.info('[SceneManager] Legacy particles cleaned up');\n        }\n    }\n    \n    initEffectsSystem() {\n        // Initialize the effects system with our scene\n        if (this.scene) {\n            Logger.debug('Initializing effects system with scene');\n            this.effectsManager = initEffectsSystem(this.scene);\n        }\n    }\n    \n    initCentralizedNeuralSystem() {\n        // Initialize the centralized neural system with our scene and effects manager\n        if (this.scene && this.effectsManager) {\n            Logger.debug('Initializing centralized neural system');\n            this.neuralSystem = enableCentralizedNeuralSystem(this.scene, this.effectsManager);\n            \n            // Make it available globally\n            window.neuralSystem = this.neuralSystem;\n        }\n    }\n    \n    dispose() {\n        // Stop the animation first\n        this.stopAnimation();\n        \n        // Clean up event listeners using eventManager if available\n        if (window.eventManager) {\n            window.eventManager.removeAllForComponent('sceneManager');\n        } else {\n            // Manually remove event listeners\n            window.removeEventListener('resize', this.handleResize, false);\n        }\n        \n        // Clean up the fluid background\n        if (this.fluidBackground) {\n            // Dispose of fluid background resources\n            if (this.fluidBackground.shaderMaterial) {\n                this.fluidBackground.shaderMaterial.dispose();\n            }\n            if (this.fluidBackground.plane && this.fluidBackground.plane.geometry) {\n                this.fluidBackground.plane.geometry.dispose();\n            }\n        }\n        \n        // Clean up the renderer\n        if (this.renderer) {\n            if (this.renderer.domElement && this.renderer.domElement.parentNode) {\n                this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);\n            }\n            this.renderer.dispose();\n            this.renderer = null;\n        }\n        \n        // Clean up effects system\n        if (window.effectsManager) {\n            window.effectsManager.dispose();\n        }\n        \n        // Clean up scene - remove all objects and their geometries/materials\n        if (this.scene) {\n            this.disposeSceneObjects(this.scene);\n            this.scene = null;\n        }\n        \n        // Release camera reference\n        this.camera = null;\n        \n        Logger.debug('SceneManager disposed');\n    }\n    \n    disposeSceneObjects(scene) {\n        if (!scene) return;\n        \n        const disposeMaterial = material => {\n            if (!material) return;\n            \n            // Handle arrays of materials\n            if (Array.isArray(material)) {\n                material.forEach(disposeMaterial);\n                return;\n            }\n            \n            // Handle regular materials with textures\n            if (material.map) material.map.dispose();\n            if (material.lightMap) material.lightMap.dispose();\n            if (material.bumpMap) material.bumpMap.dispose();\n            if (material.normalMap) material.normalMap.dispose();\n            if (material.specularMap) material.specularMap.dispose();\n            if (material.envMap) material.envMap.dispose();\n            \n            // Dispose the material itself\n            material.dispose();\n        };\n        \n        // Remove each object from the scene\n        while (scene.children.length > 0) {\n            const object = scene.children[0];\n            scene.remove(object);\n            \n            // Dispose of geometries and materials\n            if (object.geometry) object.geometry.dispose();\n            if (object.material) disposeMaterial(object.material);\n            \n            // Handle recursive children\n            if (object.children && object.children.length > 0) {\n                this.disposeSceneObjects(object);\n            }\n        }\n    }\n}\n","import { EffectsManager } from './EffectsManager';\nimport Logger from '../utils/logger';\n\nimport { ensureManagersInitialized } from '../utils/initSystemManagers';\n\n/**\n * Initialize the effects system for the SNN visualization\n * @param {THREE.Scene} scene - The THREE.js scene to add effects to\n * @returns {EffectsManager} The initialized effects manager\n */\nexport function initEffectsSystem(scene) {\n  // Ensure our high-performance TimerManager is available\n  ensureManagersInitialized();\n  \n  // Create the effects manager if it doesn't exist\n  if (!window.effectsManager && scene) {\n    Logger.debug('[Effects] Creating new EffectsManager...');\n    window.effectsManager = new EffectsManager(scene);\n    Logger.info('[Effects] EffectsManager created and globally available');\n  }\n  \n  return window.effectsManager;\n}\n\n/**\n * Safely dispose the effects system\n */\nexport function disposeEffectsSystem() {\n  if (window.effectsManager) {\n    Logger.debug('[Effects] Disposing EffectsManager...');\n    window.effectsManager.dispose();\n    window.effectsManager = null;\n    Logger.debug('[Effects] EffectsManager disposed');\n  }\n} ","import * as THREE from 'three';\nimport { Pane } from 'tweakpane';\nimport gsap from 'gsap';\nimport * as Tone from 'tone';  // Import Tone for the start button's audio initialization\n\nexport class UIManager {\n    constructor(scene, camera, renderer) {\n        // Store references to the core components\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        \n        // Initialize Tweakpane\n        this.pane = new Pane({\n            expanded: true,\n        });\n        window.pane = this.pane;\n        \n        // Initialize properties\n        this.neuronLabelElement = null;\n        this.neuronHoverLabel = null;\n        this.startButtonContainer = null;\n        \n        // Skip creating animated background waveform canvas for performance optimization\n        // We will use a static background instead\n        this.backgroundWaveformCanvas = null;\n        \n        // Tutorial system\n        this.tutorialActive = false;\n        this.tutorialStep = 0;\n        this.tutorialOverlay = null;\n        \n        // Setup UI styles and elements\n        this.setupStyles();\n        this.createUIElements();\n        \n        // Setup event listeners\n        this.setupEventListeners();\n        \n        // Add a flag to track if the neural network has been started\n        this.networkStarted = false;\n        \n        // Position elements initially\n        this.positionNeuronLabel();\n        \n        // Initialize master limiter\n        this.masterLimiter = new Tone.Limiter(-1.0); // Less aggressive limiting\n        \n        // Setup background waveform renderer\n        this.setupBackgroundWaveform();\n    }\n    \n    setupStyles() {\n        // Load the 'Press Start 2P' font for 8-bit styling\n        const fontLink = document.createElement('link');\n        fontLink.rel = 'stylesheet';\n        fontLink.href = 'https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap';\n        document.head.appendChild(fontLink);\n        \n        // Add Font Awesome for icons\n        const fontAwesomeLink = document.createElement('link');\n        fontAwesomeLink.rel = 'stylesheet';\n        fontAwesomeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';\n        document.head.appendChild(fontAwesomeLink);\n        \n        // Add styles for the application\n        const style = document.createElement('style');\n        style.textContent = `\n            /* Base styles */\n            body {\n                margin: 0;\n                overflow: hidden;\n                font-family: --tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace\n            }\n            \n            canvas {\n                display: block;\n                width: 100vw;\n                height: 100vh;\n            }\n            \n            /* Start button styles - 8-bit pixel perfect styling */\n            .start-button {\n                position: fixed;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                padding: 15px 30px;\n                font-size: 1.2rem;\n                background-color: #0066cc;\n                color: white;\n                cursor: pointer;\n                z-index: 1000;\n                font-family: 'Press Start 2P', monospace;\n                letter-spacing: 1px;\n                \n                /* 8-bit pixel styling */\n                border: none;\n                border-radius: 0; /* Square corners for 8-bit look */\n                border-top: 3px solid #3399ff;\n                border-left: 3px solid #3399ff;\n                border-bottom: 3px solid #003366;\n                border-right: 3px solid #003366;\n                box-shadow: 0 0 0 2px #000000, inset 0 0 3px rgba(255, 255, 255, 0.3);\n                text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);\n                transition: all 0.1s ease;\n            }\n\n            .start-button:hover {\n                background-color: #0077ee;\n                transform: translate(-50%, -50%) scale(1.05);\n                box-shadow: 0 0 8px rgba(0, 119, 255, 0.6), 0 0 0 2px #000000;\n            }\n            \n            .start-button:active,\n            .start-button.pressed {\n                transform: translate(-50%, -50%) scale(0.95);\n                border-top: 3px solid #003366;\n                border-left: 3px solid #003366;\n                border-bottom: 3px solid #3399ff;\n                border-right: 3px solid #3399ff;\n                box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5), 0 0 0 2px #000000;\n                background-color: #005599;\n            }\n            \n            /* Sound Control Button - 8-bit pixel perfect styling */\n            .sound-control-btn {\n                position: fixed;\n                display: none;\n                background-color: #555555;\n                color: #FFFFFF;\n                padding: 8px 12px;\n                border-radius: 0; /* Square corners for 8-bit look */\n                font-size: 12px;\n                font-family: 'Press Start 2P', monospace;\n                pointer-events: auto;\n                cursor: pointer;\n                z-index: 1001;\n                border: none; /* Remove default border */\n                /* Beveled borders like notes buttons */\n                border-top: 2px solid #777777;\n                border-left: 2px solid #777777;\n                border-bottom: 2px solid #333333;\n                border-right: 2px solid #333333;\n                box-shadow: 0 0 0 1px #000000, inset 0 0 2px rgba(255, 255, 255, 0.3);\n                text-shadow: 1px 1px 0 rgba(0,0,0,0.5);\n                transition: all 0.1s ease;\n                line-height: 1.2;\n                letter-spacing: 0px;\n            }\n            \n            /* Hover state */\n            .sound-control-btn.hover {\n                background-color: #606060;\n                transform: scale(1.05);\n                box-shadow: 0 0 5px rgba(100, 100, 100, 0.8);\n            }\n            \n            /* Active/pressed state */\n            .sound-control-btn.active {\n                transform: scale(0.95);\n                border-top: 2px solid #333333;\n                border-left: 2px solid #333333;\n                border-bottom: 2px solid #777777;\n                border-right: 2px solid #777777;\n                box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);\n            }\n            \n            .sound-control-btn i {\n                margin-left: 5px;\n                font-size: 12px;\n            }\n            \n            /* Neuron hover label */\n            .neuron-hover-label {\n                position: fixed;\n                display: none;\n                background-color: rgba(0, 0, 0, 0.7);\n                color: white;\n                padding: 8px 12px;\n                border-radius: 4px;\n                font-size: 12px;\n                pointer-events: none;\n                z-index: 1000;\n                max-width: 200px;\n            }\n            \n            /* Tutorial overlay styles */\n            .tutorial-overlay {\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background-color: rgba(0, 0, 0, 0.7);\n                z-index: 2000;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                pointer-events: all;\n            }\n            \n            .tutorial-container {\n                background-color: #222;\n                padding: 20px;\n                max-width: 300px;\n                width: 90%;\n                position: relative;\n            }\n            \n            .tutorial-header {\n                font-size: 10px;\n                color: #00aaff;\n                margin-bottom: 15px;\n                font-weight: bold;\n                text-align: center;\n                font-family: -tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace;\n                \n            }\n            \n            .tutorial-content {\n                color: #fff;\n                margin-bottom: 20px;\n                line-height: 1.5;\n                font-size: 14px;\n            }\n            \n            .tutorial-buttons {\n                display: flex;\n                justify-content: space-between;\n            }\n            \n            .tutorial-button {\n                background-color: #00aaff;\n                color: white;\n                border: none;\n                padding: 10px 20px;\n                border-radius: 4px;\n                cursor: pointer;\n                font-family: --tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace;\n                font-size: 10px;\n                letter-spacing: 1px;\n                transition: all 0.2s ease;\n            }\n            \n            .tutorial-button:hover {\n                background-color: #0088cc;\n            }\n            \n            .tutorial-button.secondary {\n                background-color: #555;\n            }\n            \n            .tutorial-button.secondary:hover {\n                background-color: #444;\n            }\n            \n            .tutorial-highlight {\n                position: absolute;\n                border: 3px dashed #00aaff;\n                border-radius: 5px;\n                box-shadow: 0 0 15px rgba(0, 170, 255, 0.4);\n                pointer-events: none;\n                z-index: 2001;\n                animation: pulse 2s infinite;\n            }\n            \n            @keyframes pulse {\n                0% { box-shadow: 0 0 15px rgba(0, 170, 255, 0.4); }\n                50% { box-shadow: 0 0 20px rgba(0, 170, 255, 0.7); }\n                100% { box-shadow: 0 0 15px rgba(0, 170, 255, 0.4); }\n            }\n            \n            /* Global Panel Styles - base styles for all devices */\n            .tp-rotv {\n                box-sizing: border-box;\n                position: fixed !important;\n                top: 10px !important;\n                z-index: 1000 !important;\n                width: 300px !important;\n                min-width: 300px !important;\n                max-width: 90vw !important;\n            }\n            \n            /* Mobile styles (default) - centered positioning */\n            @media (max-width: 1023px) {\n                .tp-rotv {\n                    right: auto !important;\n                    left: 50% !important;\n                    transform: translateX(-50%) !important;\n                }\n                \n                /* Hide waveform visualizer on mobile */\n                #visualizer-container {\n                    display: none !important;\n                }\n                \n                #synth-panel-backdrop {\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    width: 100vw;\n                    height: 100vh;\n                    background-color: rgba(0, 0, 0, 0.7);\n                    z-index: 1499;\n                }\n                \n                /* This targets the Sound Controls panel specifically */\n                .tp-rotv[data-synth-panel=\"true\"] {\n                    max-height: 80vh !important;\n                    overflow-y: auto !important;\n                    z-index: 1500 !important;\n                    background-color: rgba(40, 40, 40, 0.95) !important;\n                    border: 1px solid rgba(255, 255, 255, 0.15) !important;\n            }\n            \n                /* Ensure panel's position doesn't get overridden during interactions */\n                .tp-rotv[data-synth-panel=\"true\"] .tp-rotv_c {\n                    position: relative !important;\n                }\n            }\n            \n            /* Desktop styles - right-aligned positioning */\n            @media (min-width: 1024px) {\n                .tp-rotv {\n                    right: 10px !important;\n                    left: auto !important;\n                    transform: none !important;\n                }\n            }\n        `;\n        document.head.appendChild(style);\n    }\n    \n    createUIElements() {\n        // Create Start Button\n        this.createStartButton();\n        \n        // Create Neuron Label Element\n        this.createNeuronLabel();\n        \n        // Create Neuron Hover Label\n        this.createNeuronHoverLabel();\n    }\n    \n    createStartButton() {\n        // Create and add the start button\n        this.startButtonContainer = document.createElement('div');\n        this.startButtonContainer.className = 'start-button-container';\n\n        const startButton = document.createElement('button');\n        startButton.className = 'start-button';\n        startButton.textContent = 'START';\n\n        startButton.addEventListener('click', async () => {\n            // Add pressed class for 8-bit pressed effect\n            startButton.classList.add('pressed');\n            \n            // Set a small delay to show the animation\n            setTimeout(async () => {\n            try {\n                await Tone.start();\n                console.log('Audio is ready');\n                if (typeof window.setupInitialNetwork === 'function') {\n                    window.setupInitialNetwork();\n                }\n                this.startButtonContainer.style.display = 'none';\n                this.networkStarted = true;\n                    \n                // Remove automatic tutorial start\n                // this.startTutorial();\n            } catch (error) {\n                console.error(\"Error during startup:\", error);\n                    // Remove pressed class if error occurs\n                    startButton.classList.remove('pressed');\n            }\n            }, 200);\n        });\n\n        this.startButtonContainer.appendChild(startButton);\n        document.body.appendChild(this.startButtonContainer);\n    }\n    \n    createNeuronLabel() {\n        // Create neuron label element\n        this.neuronLabelElement = document.createElement('div');\n        this.neuronLabelElement.id = 'neuron-label';\n        // Add our custom CSS class\n        this.neuronLabelElement.className = 'sound-control-btn';\n        \n        // Set initial positioning only - styles will come from CSS\n        this.neuronLabelElement.style.bottom = '20px';\n        this.neuronLabelElement.style.right = '20px';\n        this.neuronLabelElement.style.display = 'none';\n        \n        document.body.appendChild(this.neuronLabelElement);\n        \n        // Setup neuron label event listeners\n        this.setupNeuronLabelEvents();\n    }\n    \n    createNeuronHoverLabel() {\n        // Create neuron hover info label element\n        this.neuronHoverLabel = document.createElement('div');\n        this.neuronHoverLabel.id = 'neuron-hover-label';\n        this.neuronHoverLabel.style.position = 'fixed';\n        this.neuronHoverLabel.style.pointerEvents = 'none'; // Make sure it doesn't interfere with mouse events\n        this.neuronHoverLabel.style.padding = '5px';\n        this.neuronHoverLabel.style.backgroundColor = 'transparent';\n        this.neuronHoverLabel.style.color = 'white';\n        this.neuronHoverLabel.style.borderRadius = '4px';\n        this.neuronHoverLabel.style.display = 'none';\n        this.neuronHoverLabel.style.zIndex = '1002'; // Higher than neuron label\n        this.neuronHoverLabel.style.fontFamily = '--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace;';\n        this.neuronHoverLabel.style.fontSize = '12px'; // Slightly smaller for mobile\n        this.neuronHoverLabel.style.textShadow = '0 0 4px rgba(0,0,0,0.8)'; // Add text shadow for better visibility\n        document.body.appendChild(this.neuronHoverLabel);\n        \n        // Timer to auto-hide the label\n        this.hoverLabelTimer = null;\n        \n        // Set up the global helper function for updating the hover label\n        window.updateNeuronHoverLabel = (neuron, x, y) => {\n            // Clear any existing timer\n            if (this.hoverLabelTimer) {\n                clearTimeout(this.hoverLabelTimer);\n                this.hoverLabelTimer = null;\n            }\n            \n            if (!neuron || !neuron.neuron) {\n                this.neuronHoverLabel.style.display = 'none';\n                window.currentHoveredNeuron = null;\n                return;\n            }\n            \n            const dcInput = neuron.neuron.dcInput.toFixed(2);\n            const charge = neuron.neuron.currentCharge.toFixed(2);\n            const id = neuron.neuron.id;\n            const chargePercent = Math.round(neuron.neuron.currentCharge * 100);\n            \n            // Get preset name from userData or via the getter method\n            let presetName = '';\n            if (neuron.userData && neuron.userData.presetName) {\n                presetName = neuron.userData.presetName;\n            } else if (neuron.neuron && neuron.neuron.getPresetName && typeof neuron.neuron.getPresetName === 'function') {\n                presetName = neuron.neuron.getPresetName();\n            } else if (neuron.neuron && neuron.neuron.presetName) {\n                // Fallback to direct property if we can access it\n                presetName = neuron.neuron.presetName;\n            }\n            \n            // Get preset color and convert to CSS color\n            let colorStyle = '';\n            if (neuron.neuron.presetColor) {\n                const color = neuron.neuron.presetColor;\n                // Convert THREE.Color (0-1 range) to RGB format (0-255 range)\n                const r = Math.floor(color.r * 255);\n                const g = Math.floor(color.g * 255);\n                const b = Math.floor(color.b * 255);\n                colorStyle = `color: rgb(${r}, ${g}, ${b}); text-shadow: 0 0 2px rgba(0,0,0,0.8);`;\n            }\n            \n            // Get the note information\n            let noteInfo = '';\n            if (window.soundManager) {\n                // Try to get the note from the neuron's sound parameters\n                const params = window.soundManager.getNeuronSynthParams(neuron.neuron.id);\n                if (params && params.note) {\n                    // Convert frequency to note name\n                    const noteFreq = params.note;\n                    \n                    // Find matching note in musicalNotes array\n                    const noteObj = window.musicalNotes && window.musicalNotes.find(note => \n                        Math.abs(note.freq - noteFreq) < 0.1\n                    );\n                    \n                    if (noteObj) {\n                        noteInfo = `Note: ${noteObj.name}`;\n                    } else {\n                        noteInfo = `Note: ${noteFreq.toFixed(1)} Hz`;\n                    }\n                }\n            }\n            \n            // Update label content\n            this.neuronHoverLabel.innerHTML = `\n                ${id}<br><strong style=\"${colorStyle}\">${presetName}</strong><br>\n                ${noteInfo ? noteInfo + '<br>' : ''}DC: ${dcInput}<br>\n                ${chargePercent}%\n            `;\n            \n            if (neuron.neuron.isFiring) {\n                this.neuronHoverLabel.innerHTML += `<br><span style=\"color:#ffff00\">Firing!</span>`;\n            }\n            \n            // Check if we're on mobile\n            const isMobile = window.innerWidth < 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n            \n            // Get Tweakpane position and dimensions to prevent overlap\n            let tweakpaneRect = null;\n            if (window.pane && window.pane.element) {\n                tweakpaneRect = window.pane.element.getBoundingClientRect();\n            }\n            \n            // Position the label differently for mobile vs desktop\n            if (isMobile) {\n                // Get the neuron's world position\n                const worldPos = neuron.position.clone();\n            \n                // Project the world position to screen coordinates\n                const vector = worldPos.clone().project(this.camera);\n                \n                // Convert the normalized device coordinates to screen coordinates\n                const screenX = (vector.x + 1) / 2 * window.innerWidth;\n                const screenY = -(vector.y - 1) / 2 * window.innerHeight;\n                \n                // Position label in the upper right of the neuron\n                // Ensure it doesn't get covered by the finger during touch/drag\n                let labelX = screenX + 40; // 40px to the right\n                let labelY = screenY - 70; // 70px above\n                \n                // Check if this would overlap with Tweakpane and adjust if needed\n                if (tweakpaneRect) {\n                    // Create a temp div to measure the label's size\n                    const tempDiv = document.createElement('div');\n                    tempDiv.style.position = 'absolute';\n                    tempDiv.style.visibility = 'hidden';\n                    tempDiv.innerHTML = this.neuronHoverLabel.innerHTML;\n                    tempDiv.style.width = 'auto';\n                    tempDiv.style.padding = '5px';\n                    document.body.appendChild(tempDiv);\n                    const labelWidth = tempDiv.offsetWidth;\n                    const labelHeight = tempDiv.offsetHeight;\n                    document.body.removeChild(tempDiv);\n                    \n                    // Check for overlap with Tweakpane\n                    if (labelX < tweakpaneRect.right && \n                        labelX + labelWidth > tweakpaneRect.left && \n                        labelY < tweakpaneRect.bottom && \n                        labelY + labelHeight > tweakpaneRect.top) {\n                        \n                        // Try positioning it below the neuron instead\n                        labelY = screenY + 70; // 70px below\n                        \n                        // If still overlapping, try left side\n                        if (labelY < tweakpaneRect.bottom && \n                            labelY + labelHeight > tweakpaneRect.top) {\n                            labelX = screenX - labelWidth - 20; // 20px to the left\n                        }\n                    }\n                }\n                \n                this.neuronHoverLabel.style.left = `${labelX}px`;\n                this.neuronHoverLabel.style.top = `${labelY}px`;\n                \n                // Save these offsets for when we update during dragging\n                this.neuronHoverLabel.dataset.offsetX = labelX - screenX;\n                this.neuronHoverLabel.dataset.offsetY = labelY - screenY;\n                \n            } else {\n                // For desktop, keep the label in its original position if it's already visible,\n                // otherwise position it near the mouse pointer\n                if (this.neuronHoverLabel.style.display === 'none' && x && y) {\n                    const LABEL_OFFSET_X = 20;\n                    const LABEL_OFFSET_Y = 10;\n                    \n                    let labelX = x + LABEL_OFFSET_X;\n                    let labelY = y + LABEL_OFFSET_Y;\n                    \n                    // Check for overlap with Tweakpane\n                    if (tweakpaneRect) {\n                        // Create a temp div to measure the label's size\n                        const tempDiv = document.createElement('div');\n                        tempDiv.style.position = 'absolute';\n                        tempDiv.style.visibility = 'hidden';\n                        tempDiv.innerHTML = this.neuronHoverLabel.innerHTML;\n                        tempDiv.style.width = 'auto';\n                        tempDiv.style.padding = '5px';\n                        document.body.appendChild(tempDiv);\n                        const labelWidth = tempDiv.offsetWidth;\n                        const labelHeight = tempDiv.offsetHeight;\n                        document.body.removeChild(tempDiv);\n                        \n                        // Check for overlap with Tweakpane\n                        if (labelX < tweakpaneRect.right && \n                            labelX + labelWidth > tweakpaneRect.left && \n                            labelY < tweakpaneRect.bottom && \n                            labelY + labelHeight > tweakpaneRect.top) {\n                            \n                            // Try positioning it on the left side of the cursor\n                            labelX = x - labelWidth - 20;\n                            \n                            // If still overlapping or too close to left edge, position below cursor\n                            if ((labelX < tweakpaneRect.right && \n                                labelX + labelWidth > tweakpaneRect.left && \n                                labelY < tweakpaneRect.bottom && \n                                labelY + labelHeight > tweakpaneRect.top) || \n                                labelX < 10) {\n                                \n                                labelX = x + LABEL_OFFSET_X;\n                                labelY = y + labelHeight + 20; // Below cursor\n                            }\n                        }\n                    }\n                    \n                    this.neuronHoverLabel.style.left = `${labelX}px`;\n                    this.neuronHoverLabel.style.top = `${labelY}px`;\n            \n            // Store the offset values as data attributes for reference\n                    this.neuronHoverLabel.dataset.offsetX = labelX - x;\n                    this.neuronHoverLabel.dataset.offsetY = labelY - y;\n                }\n                // If the label is already visible, leave its position unchanged\n            }\n            \n            this.neuronHoverLabel.style.display = 'block';\n            \n            // Save the reference to the neuron for real-time updates\n            window.currentHoveredNeuron = neuron;\n            \n            // Check if the neuron is currently being dragged\n            const isDragging = neuron === window.draggedNeuron;\n            \n            // Set a timer to hide the label after 1 second, but only on mobile and if not actively dragging\n            if (isMobile && !isDragging) {\n                this.hoverLabelTimer = setTimeout(() => {\n                    this.neuronHoverLabel.style.display = 'none';\n                    window.currentHoveredNeuron = null;\n                }, 1000); // 1 second timeout\n            }\n        };\n    }\n    \n    setupNeuronLabelEvents() {\n        // Helper function to toggle synth panel\n        const toggleSynthPanelFromLabel = () => {\n            if (!window.selectedSynthFolder || !window.selectedSynthFolder.element) return;\n            const panel = window.selectedSynthFolder.element;\n            const isVisible = panel.style.display === 'block';\n            panel.style.display = isVisible ? 'none' : 'block';\n            if (!isVisible && this.isMobile() && window.updateSynthPanelMobileView) {\n                window.updateSynthPanelMobileView();\n            }\n        };\n\n        // Add click event\n        this.neuronLabelElement.addEventListener('click', toggleSynthPanelFromLabel);\n        \n        // Add touch events\n        this.neuronLabelElement.addEventListener('touchstart', (e) => {\n            e.preventDefault(); // Prevent scrolling\n            this.neuronLabelElement.classList.add('active');\n        });\n\n        this.neuronLabelElement.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            this.neuronLabelElement.classList.remove('active');\n            \n            // Simple toggle for touch events as well\n            if (window.selectedSynthFolder && window.selectedSynthFolder.element) {\n                const panel = window.selectedSynthFolder.element;\n                const isVisible = panel.style.display === 'block';\n                \n                // Simply toggle display\n                panel.style.display = isVisible ? 'none' : 'block';\n                console.log(`Sound panel toggled to (touch): ${panel.style.display}`);\n            } else {\n                console.error(\"Sound panel not available for touch!\");\n            }\n        });\n\n        // Add hover effect\n        this.neuronLabelElement.addEventListener('mouseenter', () => {\n            // Use classList to handle hover state with CSS\n            this.neuronLabelElement.classList.add('hover');\n        });\n\n        this.neuronLabelElement.addEventListener('mouseleave', () => {\n            // Remove hover class when mouse leaves\n            this.neuronLabelElement.classList.remove('hover');\n        });\n\n        // Add active effect\n        this.neuronLabelElement.addEventListener('mousedown', () => {\n            this.neuronLabelElement.classList.add('active');\n        });\n\n        this.neuronLabelElement.addEventListener('mouseup', () => {\n            this.neuronLabelElement.classList.remove('active');\n        });\n        \n        // Set up the global helper function to update the neuron label\n        window.updateNeuronLabel = (neuronId) => {\n            if (neuronId === null) {\n                this.neuronLabelElement.style.display = 'none';\n            } else {\n                // Use sliders icon instead of sound icon\n                this.neuronLabelElement.innerHTML = `neuron ${neuronId.toString().padStart(2, '0')} <i class=\"fa-solid fa-sliders\"></i>`;\n                \n                // Make sure the element has the proper class\n                if (!this.neuronLabelElement.classList.contains('sound-control-btn')) {\n                    this.neuronLabelElement.className = 'sound-control-btn';\n                }\n                \n                this.neuronLabelElement.style.display = 'block';\n                \n                // Add tooltip for clarity\n                this.neuronLabelElement.title = \"Click to toggle sound controls\";\n            }\n        };\n    }\n    \n    positionNeuronLabel() {\n        const screenWidth = window.innerWidth;\n        \n        // Position based on device size\n        if (screenWidth < 768) { // Phone\n            this.neuronLabelElement.style.bottom = '25px';\n            this.neuronLabelElement.style.right = 'auto';\n            this.neuronLabelElement.style.left = '50%';\n            this.neuronLabelElement.style.transform = 'translateX(-50%)';\n        } else if (screenWidth < 1024) { // Tablet\n            this.neuronLabelElement.style.bottom = '30px'; \n            this.neuronLabelElement.style.right = 'auto';\n            this.neuronLabelElement.style.left = '50%';\n            this.neuronLabelElement.style.transform = 'translateX(-50%)';\n        } else { // Desktop\n            // Calculate the position based on the Tweakpane panel\n            const tweakpanePanel = window.pane?.element;\n            if (tweakpanePanel) {\n                // Position below the Tweakpane panel with extra padding\n                const panelRect = tweakpanePanel.getBoundingClientRect();\n                // Add at least 20px of space below the panel\n                this.neuronLabelElement.style.top = (panelRect.bottom + 20) + 'px';\n                this.neuronLabelElement.style.right = '20px';\n                this.neuronLabelElement.style.bottom = 'auto';\n                \n                // Add a bit more padding on desktop for better visibility\n                // but don't override other styles\n                this.neuronLabelElement.style.padding = '12px 16px';\n            } else {\n                // Fallback if panel not found\n                this.neuronLabelElement.style.top = '80px';\n                this.neuronLabelElement.style.right = '20px';\n                this.neuronLabelElement.style.bottom = 'auto';\n            }\n        }\n    }\n    \n    setupEventListeners() {\n        // Position neuron label on resize\n        window.addEventListener('resize', this.positionNeuronLabel.bind(this));\n        \n\n        \n        // Set up global helper to update label position only\n        window.updateNeuronLabelPosition = () => {\n            // Only update the neuron label position, not the panel positions\n            setTimeout(() => {\n                this.positionNeuronLabel.bind(this)();\n            }, 50);\n        };\n        \n        // Set up observer to reposition when Tweakpane panel changes\n        setTimeout(() => {\n            if (window.pane && window.pane.element) {\n                const observer = new MutationObserver(this.positionNeuronLabel.bind(this));\n                observer.observe(window.pane.element, { attributes: true, subtree: true, childList: true });\n            }\n        }, 1000);\n    }\n    \n    isMobile() {\n        return window.innerWidth < 1024;\n        }\n        \n    // Helper method to enforce consistent tab widths\n    enforcePanelWidth() {\n        if (!window.selectedSynthFolder || !window.selectedSynthFolder.element) {\n            return;\n        }\n        \n        // Find all tab components and set their width\n        const tabContainers = document.querySelectorAll('.tp-tabv_c, .tp-tbiv_c');\n        tabContainers.forEach(container => {\n            container.style.width = '100%';\n            container.style.minWidth = '280px';\n        });\n            \n        // Add observers to tabs to maintain fixed width when switching\n        const tabs = document.querySelectorAll('.tp-tabv');\n        tabs.forEach(tab => {\n            if (!tab.dataset.hasWidthObserver) {\n                const observer = new MutationObserver(() => {\n                    // Force a refresh of all tab content widths\n                    const tabPages = tab.querySelectorAll('.tp-tbiv_c');\n                    tabPages.forEach(page => {\n                        page.style.width = '100%';\n                        page.style.minWidth = '280px';\n                    });\n                });\n                \n                observer.observe(tab, { childList: true, subtree: true });\n                tab.dataset.hasWidthObserver = 'true';\n            }\n        });\n    }\n    \n    toggleSynthPanelMobile() {\n        if (!window.selectedSynthFolder || !window.selectedSynthFolder.element) {\n            return;\n        }\n        \n        const panel = window.selectedSynthFolder.element;\n        const isVisible = panel.style.display === 'block';\n        \n        if (isVisible) {\n            this.hideSynthPanelOnMobile();\n        } else {\n            // Mark the panel with data attribute for CSS targeting\n            panel.dataset.synthPanel = 'true';\n            panel.style.display = 'block';\n            \n            // Handle backdrop\n            let backdrop = document.getElementById('synth-panel-backdrop');\n            if (!backdrop) {\n                backdrop = document.createElement('div');\n                backdrop.id = 'synth-panel-backdrop';\n                \n                // Close panel when clicking backdrop\n                backdrop.addEventListener('click', (e) => {\n                    e.preventDefault();\n                    this.hideSynthPanelOnMobile();\n                });\n                \n                document.body.appendChild(backdrop);\n            }\n            \n            backdrop.style.display = 'block';\n        }\n    }\n    \n    hideSynthPanelOnMobile() {\n        if (!window.selectedSynthFolder || !window.selectedSynthFolder.element) {\n            return;\n        }\n        \n        const panel = window.selectedSynthFolder.element;\n        panel.style.display = 'none';\n        \n        // Hide backdrop\n        const backdrop = document.getElementById('synth-panel-backdrop');\n        if (backdrop) {\n            backdrop.style.display = 'none';\n        }\n    }\n    \n    // Method to initialize Tweakpane with settings\n    initTweakpane(settings) {\n        // This is a placeholder - the actual implementation would come from main.js\n        console.log('Tweakpane initialization should be implemented here');\n    }\n    \n    // Setup background waveform renderer\n    setupBackgroundWaveform() {\n        // We're now using a fluid shader background instead of a static one\n        // Remove any existing background elements\n        \n        // Remove the animated waveform canvas if it exists\n        if (this.backgroundWaveformCanvas) {\n            if (this.backgroundWaveformCanvas.parentNode) {\n                this.backgroundWaveformCanvas.parentNode.removeChild(this.backgroundWaveformCanvas);\n            }\n            this.backgroundWaveformCanvas = null;\n        }\n        \n        // Cancel any existing animation frame\n        if (this.backgroundWaveformAnimationFrame) {\n            cancelAnimationFrame(this.backgroundWaveformAnimationFrame);\n            this.backgroundWaveformAnimationFrame = null;\n        }\n        \n        // Remove the static background element if it exists\n        const existingBackground = document.getElementById('static-background');\n        if (existingBackground && existingBackground.parentNode) {\n            existingBackground.parentNode.removeChild(existingBackground);\n        }\n        \n        // The fluid background is now handled by the SceneManager\n        console.log('Using fluid background shader for interactive effects');\n    }\n    \n    // Tutorial methods\n    startTutorial() {\n        console.log('Starting tutorial');\n        this.tutorialActive = true;\n        this.tutorialStep = 0;\n        this.showTutorialStep(this.tutorialStep);\n    }\n    \n    showTutorialStep(step) {\n        // Clear any previous tutorial UI\n        this.clearTutorialUI();\n        \n        // Tutorial steps content\n        const tutorialSteps = [\n            {\n                title: \"Creating Neurons\",\n                content: \"Double-click anywhere on the canvas to create a new neuron.\",\n                nextLabel: \"Next\",\n                skipLabel: \"Skip Tutorial\",\n                highlight: { type: \"canvas\" }\n            },\n            {\n                title: \"Connecting Neurons\",\n                content: \"Drag one neuron close to another.\",\n                nextLabel: \"Next\",\n                skipLabel: \"Skip\"\n            },\n            {\n                title: \"Adjusting Connection Weight\",\n                content: \"Mouse wheel when hovering over the connection arrow increases the amount of charge sent.\",\n                nextLabel: \"Next\",\n                skipLabel: \"Skip\"\n            },\n            {\n                title: \"Setting DC Input\",\n                content: \"Mouse wheel over a neuron to apply stimuli, so the neuron fires on its own.\",\n                nextLabel: \"Next\",\n                skipLabel: \"Skip\"\n            },\n            {\n                title: \"Adjusting Sound\",\n                content: \"Use the control panel to adjust its sound properties like pitch, envelope, and effects.\",\n                nextLabel: \"Next\",\n                skipLabel: \"Skip\",\n                highlight: { type: \"controlPanel\" }\n            },\n        ];\n        \n        // If we've reached the end of the tutorial, clean up and return\n        if (step >= tutorialSteps.length) {\n            this.endTutorial();\n            return;\n        }\n        \n        const currentStep = tutorialSteps[step];\n        \n        // Create the tutorial overlay - make it non-blocking\n        const overlay = document.createElement('div');\n        overlay.className = 'tutorial-overlay';\n        overlay.style.backgroundColor = 'transparent';\n        overlay.style.pointerEvents = 'none'; // Make it non-blocking\n        \n        // Create the tutorial container positioned at the bottom\n        const container = document.createElement('div');\n        container.className = 'tutorial-container';\n        container.style.position = 'absolute';\n        container.style.bottom = '10%';\n        container.style.left = '50%';\n        container.style.transform = 'translateX(-50%)';\n        container.style.maxWidth = '80%';\n        container.style.width = 'auto';\n        container.style.backgroundColor = 'transparent';\n        container.style.borderRadius = '10px';\n        container.style.padding = '15px';\n        container.style.textAlign = 'center';\n        container.style.pointerEvents = 'auto'; // Make buttons clickable\n        \n        // Create title\n        const header = document.createElement('div');\n        header.className = 'tutorial-header';\n        header.textContent = currentStep.title;\n        header.style.fontSize = '14px';\n        header.style.marginBottom = '10px';\n        header.style.color = '#ffffff';\n        container.appendChild(header);\n        \n        // Create content\n        const content = document.createElement('div');\n        content.className = 'tutorial-content';\n        content.textContent = currentStep.content;\n        content.style.fontSize = '14px';\n        content.style.marginBottom = '15px';\n        content.style.color = '#ffffff';\n        container.appendChild(content);\n        \n        // Create buttons container\n        const buttonsContainer = document.createElement('div');\n        buttonsContainer.className = 'tutorial-buttons';\n        buttonsContainer.style.display = 'flex';\n        buttonsContainer.style.justifyContent = 'center';\n        buttonsContainer.style.gap = '10px';\n        \n        // Create next button\n        const nextButton = document.createElement('button');\n        nextButton.className = 'tutorial-button';\n        nextButton.textContent = 'next';\n        nextButton.style.fontSize = '12px';\n        nextButton.style.padding = '6px 12px';\n        nextButton.addEventListener('click', () => this.nextTutorialStep());\n        buttonsContainer.appendChild(nextButton);\n        \n        container.appendChild(buttonsContainer);\n        overlay.appendChild(container);\n        document.body.appendChild(overlay);\n        \n        // Store reference to the tutorial overlay\n        this.tutorialOverlay = overlay;\n        \n        // Add highlight if specified\n        if (currentStep.highlight) {\n            this.addHighlight(currentStep.highlight);\n        }\n    }\n    \n    nextTutorialStep() {\n        this.tutorialStep++;\n        this.showTutorialStep(this.tutorialStep);\n    }\n    \n    endTutorial() {\n        this.tutorialActive = false;\n        this.clearTutorialUI();\n        \n        // Create completion message in tutorial style\n        const overlay = document.createElement('div');\n        overlay.className = 'tutorial-overlay';\n        overlay.style.backgroundColor = 'transparent';\n        overlay.style.pointerEvents = 'none';\n        \n        const container = document.createElement('div');\n        container.className = 'tutorial-container';\n        container.style.position = 'absolute';\n        container.style.bottom = '10%';\n        container.style.left = '50%';\n        container.style.transform = 'translateX(-50%)';\n        container.style.maxWidth = '80%';\n        container.style.width = 'auto';\n        container.style.backgroundColor = 'transparent';\n        container.style.borderRadius = '10px';\n        container.style.padding = '15px';\n        container.style.textAlign = 'center';\n        container.style.pointerEvents = 'auto';\n        \n        const content = document.createElement('div');\n        content.className = 'tutorial-content';\n        content.textContent = \"Tutorial completed!\";\n        content.style.fontSize = '14px';\n        content.style.color = '#ffffff';\n        content.style.textShadow = '0 0 4px rgba(0,0,0,0.8)';\n        \n        container.appendChild(content);\n        overlay.appendChild(container);\n        document.body.appendChild(overlay);\n        \n        // Remove after 3 seconds\n        setTimeout(() => {\n            if (overlay.parentNode) {\n                document.body.removeChild(overlay);\n            }\n        }, 3000);\n    }\n    \n    clearTutorialUI() {\n        if (this.tutorialOverlay) {\n            document.body.removeChild(this.tutorialOverlay);\n            this.tutorialOverlay = null;\n        }\n        \n        // Remove any highlights\n        const highlights = document.querySelectorAll('.tutorial-highlight');\n        highlights.forEach(highlight => {\n            document.body.removeChild(highlight);\n        });\n    }\n    \n    addHighlight(highlightInfo) {\n        const highlight = document.createElement('div');\n        highlight.className = 'tutorial-highlight';\n        \n        // Position based on type\n        if (highlightInfo.type === 'canvas') {\n            // Highlight the canvas area\n            highlight.style.position = 'fixed';\n            highlight.style.top = '0';\n            highlight.style.left = '0';\n            highlight.style.width = '100%';\n            highlight.style.height = '100%';\n            highlight.style.border = 'none';\n            highlight.style.boxShadow = 'inset 0 0 30px rgba(0, 170, 255, 0.4)';\n        } else if (highlightInfo.type === 'controlPanel') {\n            // Highlight the control panel\n            if (window.pane && window.pane.element) {\n                const rect = window.pane.element.getBoundingClientRect();\n                highlight.style.top = `${rect.top - 5}px`;\n                highlight.style.left = `${rect.left - 5}px`;\n                highlight.style.width = `${rect.width + 10}px`;\n                highlight.style.height = `${rect.height + 10}px`;\n            }\n        }\n        \n        document.body.appendChild(highlight);\n    }\n    \n    showNotification(message, duration = 3000) {\n        // Create a notification element\n        const notification = document.createElement('div');\n        notification.style.position = 'fixed';\n        notification.style.bottom = '20px';\n        notification.style.left = '50%';\n        notification.style.transform = 'translateX(-50%)';\n        notification.style.backgroundColor = '#00aaff';\n        notification.style.color = 'white';\n        notification.style.padding = '10px 20px';\n        notification.style.borderRadius = '4px';\n        notification.style.zIndex = '2000';\n        notification.style.fontFamily = 'sans-serif';\n        notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.3)';\n        notification.textContent = message;\n        \n        document.body.appendChild(notification);\n        \n        // Remove after duration\n        setTimeout(() => {\n            if (notification.parentNode) {\n                document.body.removeChild(notification);\n            }\n        }, duration);\n    }\n} ","import * as THREE from 'three';\nimport { gsap } from 'gsap';\n\nexport class ConnectionManager {\n    constructor(scene, camera, renderer) {\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.connections = new Map();\n        \n        // Don't create a new SoundManager here, just reference the global one\n        this.soundManager = window.soundManager;\n        \n        // Log if soundManager is available\n        console.log('SoundManager available:', !!this.soundManager);\n        if (this.soundManager) {\n            console.log('WaveformAnalyzer available:', !!this.soundManager.waveformAnalyzer);\n            \n            // Diagnostic - check structure of sound manager after a brief delay\n            setTimeout(() => this.logSoundManagerInfo(), 2000);\n        }\n        \n        // Arrow position caching to prevent flickering\n        this.arrowPositionCache = new Map();\n        this.lastSourcePositions = new Map();\n        this.lastTargetPositions = new Map();\n        this.lastSourceDC = new Map();\n        this.lastTargetDC = new Map();\n        this.lastConnectionSpeed = new Map();\n        this.lastConnectionWeight = new Map();\n        \n        // Core properties\n        this.raycaster = new THREE.Raycaster();\n        this.raycaster.params.Line.threshold = 10;\n        this.mouse = new THREE.Vector2();\n        \n        // State\n        this.isDraggingArrow = false;\n        this.isDraggingNeuron = false; // Track neuron dragging state\n        this.selectedArrow = null;\n        this.selectedConnection = null;\n        this.isDraggingBeforeStart = false;\n        this.lastTapTime = 0;\n        this.doubleTapDelay = 300;\n        this.lastTapPosition = { x: 0, y: 0 };\n        this.tapDistanceThreshold = 30;\n        \n        // Long press detection for mobile\n        this.longPressTimeout = null;\n        this.longPressDelay = 700; // milliseconds\n        this.isLongPressing = false;\n        this.longPressStartPosition = { x: 0, y: 0 };\n        this.longPressThreshold = 15; // pixels of movement allowed\n\n        // Performance\n        this.frameCount = 0;\n        this.updateInterval = 1;\n        this.needsUpdate = true;\n        this.lastUpdateTime = 0;\n        this.updateThreshold = 1000 / 120;\n        \n        // Cache\n        this.arrowsCache = [];\n        this.lastConnectionCount = 0;\n        this.cachedRect = this.renderer.domElement.getBoundingClientRect();\n        this.lastRectUpdate = 0;\n        this.rectUpdateInterval = 1000;\n        \n        // Waveform properties\n        this.waveformResolution = 30; // Doubled from 30 for smoother waveforms\n        this.waveformHeight = 5.5; // Increased from 0.75 to 1.5 for more dramatic waveforms\n        this.waveformThickness = 0.025; // Tube radius - controls the thickness of the waveform\n        this.defaultWaveform = this.generateDefaultWaveform();\n        \n        // Connection opacity settings\n        this.activeOpacity = 0.95;       // Opacity when a connection is fully active\n        this.inactiveOpacity = 0.25;      // Opacity when a connection is inactive\n        this.fadeDuration = 500;        // Duration of fade out in milliseconds - increased from 300ms for smoother transitions\n        \n        this.setupGeometry();\n        this.setupEventListeners();\n        \n        // Validation interval\n        this.validationInterval = setInterval(() => this.validateConnections(), 5000);\n\n        // In InputManager.js constructor, add this with the other properties\n        this.lastDoubleClickTime = 0;\n\n        // Add a flag to track if we're currently creating a neuron to prevent duplicates\n        this.isCreatingNeuron = false;\n        \n        // Track when a connection is being scrolled over\n        this.scrollingConnections = new Set();\n    }\n\n    // Generate a default flat waveform for when no sound is playing\n    generateDefaultWaveform() {\n        const points = [];\n        for (let i = 0; i < this.waveformResolution; i++) {\n            points.push(0);\n        }\n        return points;\n    }\n\n    // Get the current waveform data for a neuron\n    getWaveformForNeuron(neuronId) {\n        // If sound manager or waveform analyzer is not available, return the default waveform\n        if (!window.soundManager || !window.soundManager.waveformAnalyzer) {\n            return this.defaultWaveform;\n        }\n        \n        try {\n            // Get the current waveform from the analyzer\n            const fullWaveform = window.soundManager.waveformAnalyzer.getValue();\n            \n            // Check if there's any actual signal\n            let hasSignal = false;\n            if (fullWaveform) {\n                for (let i = 0; i < fullWaveform.length; i++) {\n                    if (Math.abs(fullWaveform[i]) > 0.01) {\n                        hasSignal = true;\n                        break;\n                    }\n                }\n            }\n            \n            if (!fullWaveform || !hasSignal) {\n                return this.defaultWaveform;\n            }\n            \n            // Return the raw waveform so we can process it in updateConnectionWaveform\n            return fullWaveform;\n            \n        } catch (error) {\n            console.warn('Error getting waveform data:', error);\n            return this.defaultWaveform;\n        }\n    }\n    \n    // Get waveform directly from SoundManager for a specific neuron\n    getDirectWaveform(neuronId) {\n        if (!window.soundManager) return null;\n        \n        try {\n            // Check if there's a direct method to get waveform for a neuron\n            if (typeof window.soundManager.getWaveformForNeuron === 'function') {\n                return window.soundManager.getWaveformForNeuron(neuronId);\n            }\n            \n            // If there's an oscillator for this neuron, try to get its waveform\n            if (window.soundManager.oscillators && window.soundManager.oscillators[neuronId]) {\n                const oscillator = window.soundManager.oscillators[neuronId];\n                if (oscillator && oscillator.waveform) {\n                    return oscillator.waveform;\n                }\n            }\n            \n            // Fall back to the global analyzer if no neuron-specific data\n            if (window.soundManager.waveformAnalyzer) {\n                return window.soundManager.waveformAnalyzer.getValue();\n            }\n        } catch (error) {\n            console.warn(`Error getting direct waveform for neuron ${neuronId}:`, error);\n        }\n        \n        return null;\n    }\n\n    setupGeometry() {\n          // Check if device is mobile\n        const isMobile = 'ontouchstart' in window;\n        \n        // Set size multiplier based on device type\n        const sizeMultiplier = isMobile ? 0.5 : 0.5; // 15% larger for mobile\n        \n        this.arrowShape = new THREE.Shape();\n        this.arrowShape.moveTo(1.4 * sizeMultiplier, 0);\n        this.arrowShape.lineTo(-0.7 * sizeMultiplier, 1.05 * sizeMultiplier);\n        this.arrowShape.lineTo(-0.7 * sizeMultiplier, -1.05 * sizeMultiplier);\n        this.arrowShape.lineTo(1.0 * sizeMultiplier, 0);\n\n        const extrudeSettings = {\n            steps: 1,\n            depth: 0.2,\n            bevelEnabled: false\n        };\n        \n        this.arrowGeometry = new THREE.ExtrudeGeometry(this.arrowShape, extrudeSettings);\n        this.arrowGeometry.computeBoundingSphere();\n        this.arrowGeometry.computeBoundingBox();\n        \n        this.arrowMaterial = new THREE.MeshBasicMaterial({ \n            color: 0x00ff00, // Change to cyan to match waveforms (was 0xaaaaaa)\n            transparent: true,\n            opacity: 0.005, // Lower initial opacity\n            depthTest: true,\n            depthWrite: true,\n            precision: 'lowp'\n        });\n    }\n\n    setupEventListeners() {\n        const canvas = this.renderer.domElement;\n        \n        // Bind methods\n        this.handlePointerDown = this.handlePointerDown.bind(this);\n        this.handlePointerMove = this.handlePointerMove.bind(this);\n        this.handlePointerUp = this.handlePointerUp.bind(this);\n        this.handleWheel = this.handleWheel.bind(this);\n        this.handleRightClick = this.handleRightClick.bind(this);\n\n        // Use eventManager for event handling\n        if (window.eventManager) {\n            const componentId = 'connectionManager';\n            \n            // Register with event manager\n            window.eventManager.registerComponent(componentId, this);\n            \n            // Mouse events - use throttling for move events\n            window.eventManager.addEventListener(canvas, 'mousedown', this.handlePointerDown, {}, componentId);\n            window.eventManager.addThrottledEventListener(canvas, 'mousemove', this.handlePointerMove, 16, {}, componentId);\n            window.eventManager.addEventListener(canvas, 'mouseup', this.handlePointerUp, {}, componentId);\n            // Add passive: false option to allow preventDefault() to work\n            window.eventManager.addThrottledEventListener(canvas, 'wheel', this.handleWheel, 50, {passive: false}, componentId);\n            \n            // Touch events with throttling\n            window.eventManager.addEventListener(canvas, 'touchstart', this.handlePointerDown, {passive: false}, componentId);\n            window.eventManager.addThrottledEventListener(canvas, 'touchmove', this.handlePointerMove, 16, {passive: false}, componentId);\n            window.eventManager.addEventListener(canvas, 'touchend', this.handlePointerUp, {}, componentId);\n            \n            // Right click/context menu\n            window.eventManager.addEventListener(canvas, 'contextmenu', this.handleRightClick, {}, componentId);\n            \n            // Mouse leave for hiding weight label\n            window.eventManager.addEventListener(canvas, 'mouseleave', () => this.hideWeightLabel(), {}, componentId);\n        } else {\n            // Fallback to direct event listeners if eventManager not available\n            // Mouse events\n            canvas.addEventListener('mousedown', this.handlePointerDown);\n            canvas.addEventListener('mousemove', this.handlePointerMove);\n            canvas.addEventListener('mouseup', this.handlePointerUp);\n            // Add passive: false option to allow preventDefault() to work\n            canvas.addEventListener('wheel', this.handleWheel, { passive: false });\n            canvas.addEventListener('mouseleave', () => this.hideWeightLabel());\n\n            // Touch events\n            canvas.addEventListener('touchstart', this.handlePointerDown);\n            canvas.addEventListener('touchmove', this.handlePointerMove);\n            canvas.addEventListener('touchend', this.handlePointerUp);\n            \n            // Replace the default context menu prevention with our handler\n            canvas.addEventListener('contextmenu', this.handleRightClick);\n        }\n        \n        canvas.style.touchAction = 'none';\n    }\n\n    updateMousePosition(event) {\n        const now = performance.now();\n        \n        if (now - this.lastRectUpdate > this.rectUpdateInterval) {\n            this.cachedRect = this.renderer.domElement.getBoundingClientRect();\n            this.lastRectUpdate = now;\n        }\n        \n        if (event.touches) {\n            const touch = event.touches[0];\n            this.mouse.x = ((touch.clientX - this.cachedRect.left) / this.cachedRect.width) * 2 - 1;\n            this.mouse.y = -((touch.clientY - this.cachedRect.top) / this.cachedRect.height) * 2 + 1;\n        } else {\n            this.mouse.x = ((event.clientX - this.cachedRect.left) / this.cachedRect.width) * 2 - 1;\n            this.mouse.y = -((event.clientY - this.cachedRect.top) / this.cachedRect.height) * 2 + 1;\n        }\n    }\n\n\n    checkProximityConnection(neuron) {\n        if (!neuron || !neuron.position || !neuron.parent) return;\n\n        const circles = window.circles || [];\n        circles.forEach(otherNeuron => {\n            if (!otherNeuron || !otherNeuron.position || !otherNeuron.parent) return;\n            if (neuron === otherNeuron) return;\n            \n            // Safety check for neuron objects\n            if (!neuron.neuron || !otherNeuron.neuron) return;\n\n            const distance = neuron.position.distanceTo(otherNeuron.position);\n            const threshold = 0.5;\n\n            // Check for existing connections in both directions\n            let sourceToTargetConnection = null;\n            let targetToSourceConnection = null;\n            let sourceToTargetGroup = null;\n            let targetToSourceGroup = null;\n            \n            this.connections.forEach((connection, group) => {\n                if (!connection.source || !connection.target) return;\n                \n                if (connection.source === neuron && connection.target === otherNeuron) {\n                    sourceToTargetConnection = connection;\n                    sourceToTargetGroup = group;\n                }\n                \n                if (connection.source === otherNeuron && connection.target === neuron) {\n                    targetToSourceConnection = connection;\n                    targetToSourceGroup = group;\n                }\n            });\n\n            // If we have a connection in one direction but not the other,\n            // and we're close enough, reverse the connection\n            if (distance < threshold) {\n                if (sourceToTargetConnection) {\n                    // We already have a connection from neuron to otherNeuron\n                    // No need to do anything\n                    return;\n                } else if (targetToSourceConnection) {\n                    // We have a connection from otherNeuron to neuron\n                    // Reverse it!\n                    \n                    // Visual feedback\n                    const triggerVisualFeedback = (targetNeuron) => {\n                        const originalColor = targetNeuron.material.color.clone();\n                        const originalScale = targetNeuron.scale.clone();\n                        \n                        gsap.timeline()\n                            .to(targetNeuron.material.color, {\n                                r: 1,\n                                g: 0.5,\n                                b: 0,\n                                duration: 0.2\n                            }, 0)\n                            .to(targetNeuron.material.color, {\n                                r: originalColor.r,\n                                g: originalColor.g,\n                                b: originalColor.b,\n                                duration: 0.2\n                            }, 0.2);\n                    };\n                    \n                    triggerVisualFeedback(neuron);\n                    triggerVisualFeedback(otherNeuron);\n                    \n                    // Get the existing connection properties\n                    const weight = targetToSourceConnection.weight;\n                    const speed = targetToSourceConnection.speed;\n                    \n                    // Remove the connection from target to source\n                    const sourceIndex = window.circles.indexOf(neuron);\n                    otherNeuron.neuron.removeConnection(sourceIndex);\n                    this.disposeConnection(targetToSourceConnection, targetToSourceGroup);\n                    \n                    // Instead of manually creating a connection, use the existing createConnection method\n                    // and then update its properties to match the previous connection\n                    const connectionGroup = this.createConnection(neuron, otherNeuron);\n                    \n                    if (connectionGroup) {\n                        const connection = this.connections.get(connectionGroup);\n                        if (connection) {\n                            connection.weight = weight;\n                            connection.speed = speed;\n                            \n                            // Update the weight and speed in the neuron\n                            const targetIndex = window.circles.indexOf(otherNeuron);\n                            neuron.neuron.updateConnectionWeight(targetIndex, weight);\n                            neuron.neuron.updateConnectionSpeed(targetIndex, speed);\n                            \n                            // Force an update\n                            this.updateConnection(connectionGroup);\n                        }\n                    }\n                    \n                    // Play a sound or visual effect to indicate reversal\n                    if (window.soundManager && typeof window.soundManager.playSmallSound === 'function') {\n                        try {\n                            window.soundManager.playSmallSound(0.8, 0.2, 0.2);\n                        } catch (error) {\n                            console.warn('Error playing connection reversal sound:', error);\n                        }\n                    }\n                    \n                    return;\n                } else {\n                    // No connection in either direction - create a new one\n                    const triggerVisualFeedback = (targetNeuron) => {\n                        const originalColor = targetNeuron.material.color.clone();\n                        const originalScale = targetNeuron.scale.clone();\n                        \n                        gsap.timeline()\n                            .to(targetNeuron.scale, {\n                                x: originalScale.x * 1.3,\n                                y: originalScale.y * 1.3,\n                                z: originalScale.z * 1.3,\n                                duration: 0.2,\n                                ease: \"power2.out\"\n                            }, 0)\n                            .to(targetNeuron.material.color, {\n                                r: 0,\n                                g: 1,\n                                b: 0,\n                                duration: 0.2\n                            }, 0)\n                            .to(targetNeuron.scale, {\n                                x: originalScale.x,\n                                y: originalScale.y,\n                                z: originalScale.z,\n                                duration: 0.2,\n                                ease: \"power2.in\"\n                            }, 0.2)\n                            .to(targetNeuron.material.color, {\n                                r: originalColor.r,\n                                g: originalColor.g,\n                                b: originalColor.b,\n                                duration: 0.2\n                            }, 0.2);\n                    };\n\n                    // Create a particle explosion animation on the target neuron\n                    const createParticleExplosion = (neuron) => {\n                        if (!neuron || !neuron.position) return;\n                        \n                        // Create 8 particles in a burst around the neuron\n                        const numParticles = 8;\n                        const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);\n                        \n                        // Create bright cyan material for particles\n                        const particleMaterial = new THREE.MeshBasicMaterial({\n                            color: new THREE.Color(0, 1.5, 1.5), // Bright cyan\n                            transparent: true,\n                            opacity: 0.9\n                        });\n                        \n                        for (let i = 0; i < numParticles; i++) {\n                            const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());\n                            const angle = (i / numParticles) * Math.PI * 2;\n                            const radius = 0.2;\n                            \n                            // Position around the neuron in a circle\n                            particle.position.set(\n                                neuron.position.x + Math.cos(angle) * radius,\n                                neuron.position.y,\n                                neuron.position.z + Math.sin(angle) * radius\n                            );\n                            \n                            // Set rotation to face camera\n                            particle.rotation.x = -Math.PI / 2;\n                            \n                            // Add to scene\n                            this.scene.add(particle);\n                            \n                            // Animate outward in a straight line\n                            gsap.to(particle.position, {\n                                x: neuron.position.x + Math.cos(angle) * (radius * 4),\n                                z: neuron.position.z + Math.sin(angle) * (radius * 4),\n                                duration: 1,\n                                ease: \"power2.out\"\n                            });\n                            \n                            // Fade out and remove\n                            gsap.to(particle.material, {\n                                opacity: 0,\n                                duration: 1,\n                                ease: \"power2.out\",\n                                onComplete: () => {\n                                    this.scene.remove(particle);\n                                    particle.material.dispose();\n                                    particle.geometry.dispose();\n                                }\n                            });\n                        }\n                    };\n\n                    // Create connection from the dragged neuron to the other\n                    triggerVisualFeedback(neuron);\n                    triggerVisualFeedback(otherNeuron);\n                    \n                    // Add particle explosion effect on the target neuron only\n                    createParticleExplosion(otherNeuron);\n                    \n                    this.createConnection(neuron, otherNeuron);\n                }\n            }\n        });\n    }\n\n    updateConnectionProperties(weight, speed) {\n        if (this.selectedConnection) {\n            if (weight !== undefined) {\n                this.selectedConnection.weight = weight;\n                const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n                if (this.selectedConnection.source?.neuron) {\n                    this.selectedConnection.source.neuron.updateConnectionWeight(targetIndex, weight);\n                }\n            }\n    \n            if (speed !== undefined) {\n                this.selectedConnection.speed = speed;\n                const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n                if (this.selectedConnection.source?.neuron) {\n                    this.selectedConnection.source.neuron.updateConnectionSpeed(targetIndex, speed);\n                }\n    \n                // Update arrow position based on speed\n                if (this.selectedConnection.arrow) {\n                    const source = this.selectedConnection.source.position;\n                    const target = this.selectedConnection.target.position;\n                    const position = new THREE.Vector3().lerpVectors(\n                        source,\n                        target,\n                        0.2 + (speed * 0.6)  // Map 0-1 to 0.2-0.8 range\n                    );\n                    this.selectedConnection.arrow.position.copy(position);\n                    this.selectedConnection.arrow.position.y = 0.5; // Position above the neuron plane\n                }\n            }\n    \n            // Update GUI to reflect current values\n            if (window.settings) {\n                window.settings.selectedConnection = this.selectedConnection;\n                if (weight !== undefined) window.settings.selectedWeight = weight;\n                if (speed !== undefined) window.settings.selectedSpeed = speed;\n            }\n    \n            const connectionGroup = Array.from(this.connections.entries())\n                .find(([_, conn]) => conn === this.selectedConnection)?.[0];\n            if (connectionGroup) {\n                this.updateConnection(connectionGroup);\n            }\n\n            // Show updated weight label if visible\n            if (this.weightLabel && this.selectedConnection.arrow) {\n                this.showWeightLabel(this.selectedConnection.arrow, this.selectedConnection.weight);\n            }\n        }\n    }\n\n    shouldUpdateArrow(group, connection) {\n        // Always update if dragging an arrow\n        if (this.isDraggingArrow) {\n            return true;\n        }\n        \n        // Also always update if we're dragging a neuron that's part of this connection\n        if (this.isDraggingNeuron && \n            (window.draggedNeuron === connection.source || \n             window.draggedNeuron === connection.target)) {\n            // Clear cached positions to force a fresh calculation\n            const connectionId = connection.source?.neuron?.id + \"_\" + connection.target?.neuron?.id;\n            if (connectionId) {\n                this.arrowPositionCache.delete(connectionId);\n            }\n            return true;\n        }\n        \n        // Force updates every 60 frames as a safety measure\n        if (this.frameCount % 60 === 0) {\n            return true;\n        }\n        \n        // Get source and target neurons\n        const sourceNeuron = connection.source?.neuron;\n        const targetNeuron = connection.target?.neuron;\n        if (!sourceNeuron || !targetNeuron) {\n            return true; // Always update if we don't have neurons for caching\n        }\n        \n        // Check if source position has changed\n        const sourcePos = connection.source.position;\n        const lastSourcePos = this.lastSourcePositions.get(sourceNeuron.id);\n        if (!lastSourcePos || \n            lastSourcePos.x !== sourcePos.x || \n            lastSourcePos.z !== sourcePos.z) {\n            // Position has changed, update cache and return true\n            this.lastSourcePositions.set(sourceNeuron.id, sourcePos.clone());\n            return true;\n        }\n        \n        // Check if target position has changed\n        const targetPos = connection.target.position;\n        const lastTargetPos = this.lastTargetPositions.get(targetNeuron.id);\n        if (!lastTargetPos || \n            lastTargetPos.x !== targetPos.x || \n            lastTargetPos.z !== targetPos.z) {\n            // Position has changed, update cache and return true\n            this.lastTargetPositions.set(targetNeuron.id, targetPos.clone());\n            return true;\n        }\n        \n        // Check if source DC input has changed\n        const sourceDC = sourceNeuron.dcInput || 0;\n        const lastSourceDC = this.lastSourceDC.get(sourceNeuron.id);\n        if (lastSourceDC === undefined || Math.abs(lastSourceDC - sourceDC) > 0.001) {\n            this.lastSourceDC.set(sourceNeuron.id, sourceDC);\n            return true;\n        }\n        \n        // Check if target DC input has changed\n        const targetDC = targetNeuron.dcInput || 0;\n        const lastTargetDC = this.lastTargetDC.get(targetNeuron.id);\n        if (lastTargetDC === undefined || Math.abs(lastTargetDC - targetDC) > 0.001) {\n            this.lastTargetDC.set(targetNeuron.id, targetDC);\n            return true;\n        }\n        \n        // Check if connection weight or speed has changed\n        const weight = connection.weight || 0.5;\n        const speed = connection.speed || 0.5;\n        const lastWeight = this.lastConnectionWeight.get(group);\n        const lastSpeed = this.lastConnectionSpeed.get(group);\n        \n        if (lastWeight === undefined || Math.abs(lastWeight - weight) > 0.001) {\n            this.lastConnectionWeight.set(group, weight);\n            return true;\n        }\n        \n        if (lastSpeed === undefined || Math.abs(lastSpeed - speed) > 0.001) {\n            this.lastConnectionSpeed.set(group, speed);\n            return true;\n        }\n        \n        // Nothing has changed, don't update\n        return false;\n    }\n    \n    updateArrowsCache() {\n        // Only rebuild the cache if the connection count has changed, or if the cache is empty\n        if (this.connections.size !== this.lastConnectionCount || !this.arrowsCache.length) {\n            this.arrowsCache = Array.from(this.connections.values())\n                .map(connection => connection.arrow)\n                .filter(Boolean);\n            this.lastConnectionCount = this.connections.size;\n        }\n        return this.arrowsCache;\n    }\n\n    showWeightLabel(arrow, weight) {\n        if (!this.weightLabel) {\n            this.weightLabel = document.createElement('div');\n            this.weightLabel.style.position = 'absolute';\n            this.weightLabel.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';\n            this.weightLabel.style.padding = '5px';\n            this.weightLabel.style.color = 'white';\n            this.weightLabel.style.borderRadius = '3px';\n            this.weightLabel.style.fontSize = '14px';\n            this.weightLabel.style.fontFamily = 'Consolas, monospace';\n            this.weightLabel.style.pointerEvents = 'none';\n            document.body.appendChild(this.weightLabel);\n        }\n\n        let speed = 0;\n        this.connections.forEach((connection) => {\n            if (connection.arrow === arrow) {\n                speed = connection.speed;\n            }\n        });\n\n        this.weightLabel.innerHTML = `Weight: ${weight.toFixed(1)}<br>Speed: ${speed.toFixed(1)}`;\n        const vector = new THREE.Vector3();\n        arrow.getWorldPosition(vector);\n        vector.project(this.camera);\n\n        const x = (vector.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;\n        const y = (-vector.y * 0.5 + 0.5) * this.renderer.domElement.clientHeight;\n\n        this.weightLabel.style.left = `${x}px`;\n        this.weightLabel.style.top = `${y - 50}px`;\n    }\n\n    hideWeightLabel() {\n        if (this.weightLabel) {\n            document.body.removeChild(this.weightLabel);\n            this.weightLabel = null;\n        }\n    }\n\n    handlePointerDown(event) {\n        const isTouch = event.type === 'touchstart';\n\n        \n        // Handle long press detection for touch events\n        if (isTouch) {\n            if (this.longPressTimeout) {\n                clearTimeout(this.longPressTimeout);\n            }\n            \n            const touch = event.touches[0];\n            this.longPressStartPosition = { \n                x: touch.clientX, \n                y: touch.clientY \n            };\n            \n            this.longPressTimeout = setTimeout(() => {\n                // Check if we're still in roughly the same position\n                if (this.selectedConnection) {\n                    this.isLongPressing = true;\n                    this.handleLongPress(this.selectedConnection);\n                }\n            }, this.longPressDelay);\n        }\n        \n        // Skip if middle button is pressed\n        if (!isTouch && event.button === 1) return;\n        \n        // Only check for arrow clicks on left-click\n        if (!isTouch && event.button !== 0) return;\n        \n        // If we're already dragging, don't start a new interaction\n        if (this.isDraggingArrow) return;\n        \n        // Get the pointer for either mouse or touch\n        const pointer = isTouch ? event.touches[0] : event;\n        \n        // Flag for double-tap detection\n        let isDoubleTap = false;\n        \n        if (isTouch) {\n            const currentTime = new Date().getTime();\n            const tapDistance = Math.sqrt(\n                Math.pow(pointer.clientX - this.lastTapPosition.x, 2) +\n                Math.pow(pointer.clientY - this.lastTapPosition.y, 2)\n            );\n            \n            // Check if the current tap is close enough to the last one\n            // and within the time threshold to be a double tap\n            if (currentTime - this.lastTapTime < this.doubleTapDelay && \n                tapDistance < this.tapDistanceThreshold) {\n                console.log(\"Double tap detected!\");\n                isDoubleTap = true;\n            }\n            \n            // Update last tap info\n            this.lastTapTime = currentTime;\n            this.lastTapPosition = { x: pointer.clientX, y: pointer.clientY };\n        }\n        \n        this.updateMousePosition(event);\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Add increased Line threshold for better arrow detection\n        const originalThreshold = this.raycaster.params.Line ? this.raycaster.params.Line.threshold : 1;\n        if (this.raycaster.params.Line) {\n            this.raycaster.params.Line.threshold = isTouch ? 8 : 5;\n        }\n        \n        // Get arrows using the arrow cache mechanism\n        const arrows = this.updateArrowsCache();\n        const intersects = this.raycaster.intersectObjects(arrows, false);\n        \n        // Reset threshold\n        if (this.raycaster.params.Line) {\n            this.raycaster.params.Line.threshold = originalThreshold;\n        }\n        \n        if (intersects.length > 0) {\n            // Prevent default event handling\n            event.preventDefault();\n            event.stopPropagation();\n            \n            console.log(\"Arrow intersected, starting drag operation\");\n            \n            // Start dragging the arrow to adjust the connection speed\n            const arrow = intersects[0].object;\n            \n            // Find the corresponding connection\n            for (const [group, connection] of this.connections.entries()) {\n                if (connection.arrow === arrow) {\n                    console.log(\"Selected connection for arrow:\", connection.source?.neuron?.id, \"->\", connection.target?.neuron?.id);\n                    \n                    // Flag that we're now dragging this arrow\n                    this.isDraggingArrow = true;\n                    this.isDraggingBeforeStart = true;\n                    this.selectedArrow = arrow;\n                    this.selectedConnection = connection;\n                    \n                    // Make the arrow fully visible during dragging\n                    arrow.material.opacity = 1.0;\n                    arrow.material.color.setHex(0x00ff00);\n                    \n                    // Update UI\n                    this.showWeightLabel(arrow, connection.weight);\n                    \n                    // Update global settings\n                    if (window.settings) {\n                        window.settings.selectedConnection = connection;\n                        window.settings.selectedWeight = connection.weight || 0.5;\n                        window.settings.selectedSpeed = connection.speed || 0.5;\n                        \n                        // Refresh tweakpane if available\n                        if (window.pane) {\n                            window.pane.refresh();\n                        }\n                    }\n                    \n                    // Force an immediate update to ensure the connection is visible and properly initialized\n                    this.updateConnection(group);\n                    \n                    // Force a secondary update after a short delay to ensure everything is loaded correctly\n                    // This helps with the neuron 03 to neuron 01 connection issue\n                    setTimeout(() => {\n                        if (this.isDraggingArrow && this.selectedConnection === connection) {\n                            this.updateConnection(group);\n                        }\n                    }, 50);\n                    \n                    break;\n                }\n            }\n        }\n    }\n\n    handlePointerMove(event) {\n        const isTouch = event.type === 'touchmove';\n        const pointer = isTouch ? event.touches[0] : event;\n        \n        // If we have a long press timer running and this is a touch event, check if we've moved too far\n        if (this.longPressTimeout && isTouch) {\n            const distance = Math.sqrt(\n                Math.pow(pointer.clientX - this.longPressStartPosition.x, 2) +\n                Math.pow(pointer.clientY - this.longPressStartPosition.y, 2)\n            );\n            \n            // If moved beyond threshold, cancel the long press\n            if (distance > this.longPressThreshold) {\n                clearTimeout(this.longPressTimeout);\n                this.longPressTimeout = null;\n            }\n        }\n    \n        if (!this.isDraggingArrow || !this.selectedArrow || !this.selectedConnection) {\n            this.updateMousePosition(event);\n            this.raycaster.setFromCamera(this.mouse, this.camera);\n            \n            // Set threshold for better detection\n            const originalThreshold = this.raycaster.params.Line ? this.raycaster.params.Line.threshold : 1;\n            if (this.raycaster.params.Line) {\n                this.raycaster.params.Line.threshold = isTouch ? 8 : 5;\n            }\n            \n            // Get arrows only\n            const arrows = this.updateArrowsCache();\n            const intersects = this.raycaster.intersectObjects(arrows, false);\n            \n            // Reset threshold\n            if (this.raycaster.params.Line) {\n                this.raycaster.params.Line.threshold = originalThreshold;\n            }\n            \n            // Only show weight label when hovering over an arrow\n            if (intersects.length > 0) {\n                const arrow = intersects[0].object;\n                const connection = Array.from(this.connections.values())\n                    .find(conn => conn.arrow === arrow);\n                if (connection) {\n                    this.showWeightLabel(arrow, connection.weight);\n                }\n            } else {\n                this.hideWeightLabel();\n            }\n            return;\n        }\n\n        // Only prevent default if we're actually dragging an arrow \n        if (this.isDraggingArrow) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        \n        // Safety check - ensure arrow exists\n        if (!this.selectedArrow || !this.selectedArrow.material) {\n            console.warn(\"Arrow lost during drag operation\");\n            this.isDraggingArrow = false;\n            return;\n        }\n        \n        // Ensure the arrow is visible during dragging\n        this.selectedArrow.material.opacity = 1.0;\n        this.selectedArrow.material.color.setHex(0x00ff00);\n        \n        const rect = this.renderer.domElement.getBoundingClientRect();\n        const mouseX = pointer.clientX - rect.left;\n        const mouseZ = pointer.clientY - rect.top;\n\n        if (!this.selectedConnection.source || !this.selectedConnection.target) {\n            console.warn(\"Connection endpoints lost during dragging\");\n            this.isDraggingArrow = false;\n            return;\n        }\n\n        const source = this.selectedConnection.source.position.clone();\n        const target = this.selectedConnection.target.position.clone();\n        \n        source.project(this.camera);\n        target.project(this.camera);\n        \n        const sourceScreen = {\n            x: (source.x + 1) * rect.width / 2,\n            y: (-source.y + 1) * rect.height / 2\n        };\n        \n        const targetScreen = {\n            x: (target.x + 1) * rect.width / 2,\n            y: (-target.y + 1) * rect.height / 2\n        };\n\n        const dragResult = this.calculateDragPosition(mouseX, mouseZ, sourceScreen, targetScreen);\n        \n        // Create a new world position for the arrow\n        const worldPos = new THREE.Vector3();\n        worldPos.copy(this.selectedConnection.source.position);\n        \n        const direction = new THREE.Vector3().subVectors(\n            this.selectedConnection.target.position,\n            this.selectedConnection.source.position\n        ).normalize();\n        \n        const distance = this.selectedConnection.source.position.distanceTo(\n            this.selectedConnection.target.position\n        );\n        \n        worldPos.add(direction.multiplyScalar(dragResult.percentage * distance));\n        \n        // CRITICAL: Always maintain the y-position of the arrow above the neuron plane\n        worldPos.y = 0.5;\n        this.selectedArrow.position.copy(worldPos);\n        \n        // Log the arrow position for debugging\n        // console.log(\"Arrow positioned at:\", worldPos.x.toFixed(2), worldPos.y.toFixed(2), worldPos.z.toFixed(2));\n\n        // Update the connection speed\n        this.selectedConnection.speed = dragResult.normalizedSpeed;\n        \n        if (window.settings) {\n            window.settings.selectedSpeed = dragResult.normalizedSpeed;\n        }\n\n        // Force an update \n        this.needsUpdate = true;\n\n        // Update the connection in the neuron\n        const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n        if (this.selectedConnection.source?.neuron) {\n            this.selectedConnection.source.neuron.updateConnectionSpeed(targetIndex, dragResult.normalizedSpeed);\n        }\n\n        // Update the UI\n        this.showWeightLabel(this.selectedArrow, this.selectedConnection.weight);\n        \n        // Force the connection group to update\n        const connectionGroup = Array.from(this.connections.entries())\n            .find(([_, conn]) => conn === this.selectedConnection)?.[0];\n        if (connectionGroup) {\n            this.updateConnection(connectionGroup);\n        }\n    }\n\n    handlePointerUp(event) {\n        // Clear any long press timeout\n        if (this.longPressTimeout) {\n            clearTimeout(this.longPressTimeout);\n            this.longPressTimeout = null;\n        }\n        \n        if (!this.isDraggingArrow) return;\n        \n        event.preventDefault();\n        event.stopPropagation();\n        \n        // Only access speed if selectedConnection exists\n        if (this.selectedConnection) {\n            const speed = this.selectedConnection.speed;\n            console.log(\"Arrow drag ended, final speed:\", speed);\n            \n            const targetIndex = window.circles.indexOf(this.selectedConnection.target);\n            if (this.selectedConnection.source?.neuron) {\n                this.selectedConnection.source.neuron.updateConnectionSpeed(targetIndex, speed);\n            }\n            \n            // Update global settings\n            if (window.settings) {\n                window.settings.selectedConnection = this.selectedConnection;\n                window.settings.selectedWeight = this.selectedConnection.weight;\n                window.settings.selectedSpeed = speed;\n                \n                // Refresh the panel\n                if (window.pane) {\n                    window.pane.refresh();\n                }\n            }\n            \n            // Force a final update to ensure visibility\n            const connectionGroup = Array.from(this.connections.entries())\n                .find(([_, conn]) => conn === this.selectedConnection)?.[0];\n            if (connectionGroup) {\n                this.updateConnection(connectionGroup);\n            }\n        }\n        \n        // Keep selected connection arrow visible with green color\n        if (this.selectedConnection && this.selectedArrow) {\n            console.log(\"Keeping arrow visible after drag\");\n            this.selectedArrow.material.color.setHex(0x00ff00);\n            // Ensure arrow remains visible after drag ends\n            this.selectedArrow.material.opacity = 1.0;\n        }\n        \n        this.isDraggingArrow = false;\n        this.isDraggingBeforeStart = false;\n        this.hideWeightLabel();\n    }\n\n    handleWheel(event) {\n        if (this.isDraggingArrow) return;\n        event.preventDefault();\n        \n        this.updateMousePosition(event);\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Set threshold for better detection\n        const originalThreshold = this.raycaster.params.Line ? this.raycaster.params.Line.threshold : 1;\n        if (this.raycaster.params.Line) {\n            this.raycaster.params.Line.threshold = 5; // Increased threshold for easier detection\n        }\n        \n        const arrows = this.updateArrowsCache();\n        const intersects = this.raycaster.intersectObjects(arrows);\n        \n        // Reset threshold\n        if (this.raycaster.params.Line) {\n            this.raycaster.params.Line.threshold = originalThreshold;\n        }\n        \n        if (intersects.length > 0) {\n            const arrow = intersects[0].object;\n            let connectionGroup = null;\n            \n            this.connections.forEach((connection, group) => {\n                if (connection.arrow === arrow) {\n                    // First, make sure this connection is selected\n                    this.selectConnection(connection);\n                    connectionGroup = group;\n                    \n                    if (connection.source.neuron) {\n                        connection.source.neuron.isScrolling = true;\n                        if (connection.source.neuron.scrollTimeout) {\n                            clearTimeout(connection.source.neuron.scrollTimeout);\n                        }\n                    }\n\n                    // Add to scrolling connections set\n                    this.scrollingConnections.add(connection);\n                    \n                    // Make sure the arrow is fully visible\n                    connection.arrow.material.opacity = 1.0;\n                    \n                    const delta = event.deltaY > 0 ? -0.1 : 0.1;\n                    const currentWeight = connection.weight ?? 0.5;\n                    let newWeight = Math.max(0, Math.min(1, currentWeight + delta));\n                    \n                    connection.weight = newWeight;\n                    if (window.settings) {\n                        window.settings.selectedWeight = newWeight;\n                        \n                        // Make sure to refresh the panel\n                        if (window.pane) {\n                            window.pane.refresh();\n                        }\n                    }\n                    \n                    const targetIndex = window.circles.indexOf(connection.target);\n                    connection.source.neuron.updateConnectionWeight(targetIndex, newWeight);\n                    \n                    // Force an update on the connection\n                    this.updateConnection(group);\n                    this.showWeightLabel(arrow, newWeight);\n                    \n                    // Schedule reset isScrolling flag\n                    if (connection.source.neuron) {\n                        connection.source.neuron.scrollTimeout = setTimeout(() => {\n                            if (connection.source.neuron) {\n                                connection.source.neuron.isScrolling = false;\n                            }\n                            // Remove from scrolling connections set after delay\n                            this.scrollingConnections.delete(connection);\n                        }, 500);\n                    }\n                }\n            });\n            \n            // Force another update after a short delay to ensure proper initialization\n            // This helps with the neuron 03 to neuron 01 connection issue\n            if (connectionGroup) {\n                setTimeout(() => {\n                    this.updateConnection(connectionGroup);\n                }, 50);\n            }\n        }\n    }\n\n    handleDoubleClick(event) {\n        event.preventDefault();\n        console.log(\"Double click event received\");\n        \n        // Prevent multiple creation calls\n        if (this.isCreatingNeuron) {\n            console.log(\"Already creating a neuron, ignoring additional click\");\n            return;\n        }\n        \n        this.isCreatingNeuron = true;\n        \n        // Get mouse position in normalized device coordinates (-1 to +1)\n        this.updateMousePosition(event);\n        \n        // Set up raycaster\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Create a plane at y=0 to intersect with\n        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\n        const intersectionPoint = new THREE.Vector3();\n        this.raycaster.ray.intersectPlane(plane, intersectionPoint);\n        \n        // Check if we clicked on empty space (not on existing neurons)\n        const intersects = this.raycaster.intersectObjects(window.circles);\n        if (intersects.length === 0) {\n            console.log(\"Creating new neuron at\", intersectionPoint.x, intersectionPoint.z);\n            \n            // Create new neuron at intersection point\n            const neuron = window.settings.addNeuron(intersectionPoint);\n            if (neuron) {\n                // Set position properly\n                neuron.position.copy(intersectionPoint);\n                neuron.position.y = 0.1;\n                \n                // Update touch area position\n                if (neuron.touchArea) {\n                    neuron.touchArea.position.copy(neuron.position);\n                    neuron.touchArea.position.y = 0.1;\n                }\n                \n                console.log(\"Created neuron:\", neuron.neuron.id);\n            }\n        }\n        \n        // Reset the flag after a short delay to prevent further events\n        setTimeout(() => {\n            this.isCreatingNeuron = false;\n        }, 300);\n    }\n\n    calculateDragPosition(mouseX, mouseY, sourceScreen, targetScreen) {\n        const screenVector = {\n            x: targetScreen.x - sourceScreen.x,\n            y: targetScreen.y - sourceScreen.y\n        };\n\n        const mouseVector = {\n            x: mouseX - sourceScreen.x,\n            y: mouseY - sourceScreen.y\n        };\n\n        const screenVectorLength = Math.sqrt(screenVector.x * screenVector.x + screenVector.y * screenVector.y);\n        const dotProduct = mouseVector.x * screenVector.x + mouseVector.y * screenVector.y;\n        \n        let rawPercentage = dotProduct / (screenVectorLength * screenVectorLength);\n\n        const sourceGrowth = this.selectedConnection.source.neuron ? \n            this.selectedConnection.source.neuron.baseScale + \n            (this.selectedConnection.source.neuron.dcInput * 0.2) : 0.2;\n        const targetGrowth = this.selectedConnection.target.neuron ? \n            this.selectedConnection.target.neuron.baseScale + \n            (this.selectedConnection.target.neuron.dcInput * 0.2) : 0.2;\n\n        const MIN_VISUAL = sourceGrowth;\n        const MAX_VISUAL = 1 - targetGrowth;\n        \n        rawPercentage = Math.max(MIN_VISUAL, Math.min(MAX_VISUAL, rawPercentage));\n        \n        const normalizedSpeed = (rawPercentage - MIN_VISUAL) / (MAX_VISUAL - MIN_VISUAL);\n        \n        return {\n            percentage: rawPercentage,\n            normalizedSpeed: Math.max(0, Math.min(1, normalizedSpeed))\n        };\n    }\n\n    updateAllConnections() {\n        // Check if we should update based on time\n        const now = performance.now();\n        const timeDelta = now - this.lastUpdateTime;\n        \n        // If we're dragging or time threshold is met, do a full update\n        if (this.isDraggingArrow || this.needsUpdate || timeDelta > this.updateThreshold) {\n            this.lastUpdateTime = now;\n            this.needsUpdate = false;\n            \n            // Validate cache if the number of connections has changed\n            if (this.connections.size !== this.lastConnectionCount) {\n                this.arrowsCache = this.updateArrowsCache();\n                this.lastConnectionCount = this.connections.size;\n            }\n            \n            // Track problematic connection\n            let problematicConnection = null;\n            let problematicConnectionGroup = null;\n            \n            // Update all connections\n            for (const [group, connection] of this.connections.entries()) {\n                try {\n                    // Check for the problematic connection (neuron 03 to neuron 01)\n                    if (connection.source?.neuron?.id === '03' && connection.target?.neuron?.id === '01') {\n                        problematicConnection = connection;\n                        problematicConnectionGroup = group;\n                    }\n                    \n                    // Only update static position if something has changed or it's been a while\n                    const shouldUpdateArrow = this.shouldUpdateArrow(group, connection);\n                    \n                    // Update the static line and arrow positions only when needed\n                    if (shouldUpdateArrow) {\n                        this.updateConnection(group);\n                    }\n                    \n                    // Update waveforms every frame for smoother animations during rapid firing\n                    // Changed from frameCount % 2 to update every frame\n                    if (this.frameCount % 1 === 0) {\n                        this.updateConnectionWaveform(connection);\n                    }\n                } catch (error) {\n                    console.warn('Error updating connection:', error);\n                }\n            }\n            \n            // Extra update for the problematic connection (only check opacity)\n            if (problematicConnection && problematicConnectionGroup) {\n                // Check if the arrow has the right opacity\n                if (problematicConnection.arrow && \n                    problematicConnection.arrow.material.opacity < 0.2) {\n                    \n                    console.log(\"Fixing problematic connection (neuron 03 to neuron 01)\");\n                    \n                    // Ensure the arrow is properly visible\n                    problematicConnection.arrow.material.opacity = 0.4;\n                    \n                    // Force update cached position\n                    const connectionId = problematicConnection.source?.neuron?.id + \"_\" + problematicConnection.target?.neuron?.id;\n                    if (connectionId) {\n                        // Remove from cache to force recalculation\n                        this.arrowPositionCache.delete(connectionId);\n                        \n                        // Force another update\n                        this.updateConnection(problematicConnectionGroup);\n                    }\n                }\n            }\n            \n            this.frameCount++;\n            \n            // Reset drag state after the update\n            if (this.isDraggingNeuron && !window.draggedNeuron) {\n                this.isDraggingNeuron = false;\n            }\n        }\n    }\n\n    // Update a connection's waveform visualization\n    updateConnectionWaveform(connection) {\n        if (!connection || !connection.waveformLine) return;\n        \n        // Get the source and target positions\n        const sourcePos = connection.source.position;\n        const targetPos = connection.target.position;\n        \n        // Check if neuron is currently firing or fired very recently\n        let isActive = false;\n        if (connection.source.neuron) {\n            const now = performance.now();\n            // Consider neuron active if it fired in the last 200ms (increased from 100ms)\n            // This helps maintain waveform visibility during rapid firing\n            isActive = connection.source.neuron.isFiring || (now - (connection.source.neuron.lastFiredTime || 0) < 200);\n            \n            // Store the active state directly on the connection for animation consistency\n            connection.isActive = isActive;\n        }\n        \n        // Calculate distance between neurons for color gradient\n        const dx = targetPos.x - sourcePos.x;\n        const dz = targetPos.z - sourcePos.z;\n        const neuronDistance = Math.sqrt(dx * dx + dz * dz);\n        \n        // Set color based on distance - cyan (near) to grey (far)\n        const nearColor = new THREE.Color(0x00FF00);  // Cyan\n        const farColor = new THREE.Color(0x808080);   // Grey\n        \n        // Normalize distance for color interpolation\n        // 2.0 units = close, 10.0 units = far\n        const minDist = 2.0;\n        const maxDist = 10.0;\n        const normDist = Math.min(1.0, Math.max(0.0, (neuronDistance - minDist) / (maxDist - minDist)));\n        \n        // Set the color by lerping between green and grey based on distance\n        connection.waveformLine.material.color.lerpColors(nearColor, farColor, normDist);\n        \n        // Track last active time to create smooth fade out effect\n        if (!connection.lastActiveTime) connection.lastActiveTime = 0;\n        if (isActive) {\n            connection.lastActiveTime = performance.now();\n        }\n        \n        // Calculate fade factor - smooth transition over longer period after neuron stops firing\n        const timeSinceActive = performance.now() - connection.lastActiveTime;\n        const fadeFactor = isActive ? 1.0 : Math.max(0, 1 - (timeSinceActive / this.fadeDuration));\n        \n        // Cache the fade factor for animation consistency between frames\n        connection.fadeFactor = fadeFactor;\n        \n        // Get actual waveform data from the source neuron's sound\n        let waveform = [];\n        const neuronId = connection.source.neuron ? connection.source.neuron.id : null;\n        \n        // Check if this is an instant connection\n        const speed = connection.speed || 0.5; \n        const isInstantConnection = speed >= 0.99;\n        \n        // IMPORTANT: Only process waveform if the neuron is active or recently active (still fading)\n        // Lowered threshold from 0.01 to 0.001 to ensure smoother transitions during rapid firing\n        if (fadeFactor > 0.001) {\n            // Try to get direct waveform first\n            const directWaveform = this.getDirectWaveform(neuronId);\n            \n            if (directWaveform && directWaveform.length > 0) {\n                // We got direct waveform data, process it\n                const stepSize = Math.floor(directWaveform.length / this.waveformResolution);\n                \n                for (let i = 0; i < this.waveformResolution; i++) {\n                    const index = i * stepSize;\n                    if (index < directWaveform.length) {\n                        // Scale up the waveform value and apply weight/fade factor\n                        const scaleFactor = this.waveformHeight * fadeFactor * (connection.weight || 0.5);\n                        waveform.push(directWaveform[index] * scaleFactor);\n                    } else {\n                        waveform.push(0);\n                    }\n                }\n            } else if (window.soundManager && window.soundManager.waveformAnalyzer) {\n                // Fall back to global analyzer\n                try {\n                    // Get the current waveform from the analyzer\n                    const fullWaveform = window.soundManager.waveformAnalyzer.getValue();\n                    \n                    // Only use real waveform if we have data and neuron is active\n                    if (fullWaveform && fullWaveform.length > 0) {\n                        // Sample the waveform data to our desired resolution\n                        const stepSize = Math.floor(fullWaveform.length / this.waveformResolution);\n                        \n                        for (let i = 0; i < this.waveformResolution; i++) {\n                            const index = i * stepSize;\n                            if (index < fullWaveform.length) {\n                                // Scale up the waveform value and apply weight/fade factor\n                                const scaleFactor = this.waveformHeight * fadeFactor * (connection.weight || 0.5);\n                                waveform.push(fullWaveform[index] * scaleFactor);\n                            } else {\n                                waveform.push(0);\n                            }\n                        }\n                    }\n                } catch (error) {\n                    console.warn('Error getting waveform data:', error);\n                    waveform = [];\n                }\n            }\n        }\n        \n        // If we have no waveform data yet and we're active, create a synthetic one\n        if (waveform.length === 0 && fadeFactor > 0.01) {\n            // Add animation phase based on time for moving wave effect\n            const currentTime = performance.now() / 1000; // Convert to seconds\n            const animationSpeed = isInstantConnection ? \n                12 : // Very fast animation for instant connections\n                2 + (speed * 6); // Regular speed scaling for normal connections\n                \n            const phase = (currentTime * animationSpeed) % (Math.PI * 2);\n            \n            // Calculate base amplitude - fades out when neuron stops firing\n            // Use a higher minimum amplitude for better visibility\n            const weight = connection.weight || 0.5;\n            const baseAmplitude = fadeFactor * (0.5 + weight * 1.5); // Increased base amplitude\n            \n            // Create a more distinct traveling wave with higher amplitude\n            for (let i = 0; i < this.waveformResolution; i++) {\n                // Create a wave based on the connection properties\n                const t = i / (this.waveformResolution - 1);\n                \n                // Use a clearer sine wave pattern with higher frequency based on weight\n                // For instant connections, use higher frequency\n                const frequency = isInstantConnection ?\n                    4 + (weight * 4) : // Higher frequency for instant connections\n                    2 + (weight * 3); // Normal frequency for regular connections\n                \n                // This creates a traveling wave moving from source to target\n                // The wave should travel in the direction of the connection\n                const animatedPhase = phase - (t * Math.PI * 2); \n                \n                // Create a clearer sine wave with higher amplitude\n                const waveValue = Math.sin(t * frequency * Math.PI * 2 + animatedPhase);\n                \n                // Apply a \"bump\" function to make center of wave more pronounced\n                const bump = 0.5 + 0.5 * Math.sin((t - 0.5) * Math.PI);\n                \n                // Scale wave by fade factor and add the bump effect\n                waveform.push(waveValue * baseAmplitude * (0.8 + 0.2 * bump));\n            }\n        } else if (waveform.length === 0) {\n            // Create a flat line when neuron is inactive\n            for (let i = 0; i < this.waveformResolution; i++) {\n                waveform.push(0);\n            }\n        }\n        \n        // Calculate direction vector from source to target\n        const dirX = targetPos.x - sourcePos.x;\n        const dirZ = targetPos.z - sourcePos.z;\n        const distance = Math.sqrt(dirX * dirX + dirZ * dirZ);\n        \n        // Create normalized direction and perpendicular vectors\n        const normalizedDirX = dirX / distance;\n        const normalizedDirZ = dirZ / distance;\n        const perpX = -normalizedDirZ;\n        const perpZ = normalizedDirX;\n        \n        // Check if we have the new tube geometry setup\n        if (connection.waveformLine.userData.points && connection.waveformLine.userData.path) {\n            // Update the points for the CatmullRomCurve3\n            const points = connection.waveformLine.userData.points;\n            \n            // Start at source\n            for (let i = 0; i < this.waveformResolution; i++) {\n                const t = i / (this.waveformResolution - 1); // Normalize to 0-1\n                \n                // Base position along straight line from source to target\n                const x = sourcePos.x + (dirX * t);\n                const z = sourcePos.z + (dirZ * t);\n                \n                // Apply waveform displacement perpendicular to the direction\n                const displacement = waveform[i];\n                \n                // Update the point position\n                points[i].set(\n                    x + (perpX * displacement),\n                    -10, // Keep waveform at neuron plane level\n                    z + (perpZ * displacement)\n                );\n            }\n            \n            // Update the path from the modified points\n            connection.waveformLine.userData.path.points = points;\n            \n            // Recreate the tube geometry\n            const newTubeGeometry = new THREE.TubeGeometry(\n                connection.waveformLine.userData.path,\n                this.waveformResolution,  // tubularSegments\n                this.waveformThickness * (isInstantConnection ? 1.5 : 1), // Thicker for instant connections\n                8,                       // radialSegments\n                false                    // closed\n            );\n            \n            // Update the geometry\n            connection.waveformLine.geometry.dispose();\n            connection.waveformLine.geometry = newTubeGeometry;\n        } else {\n            // Legacy support for regular line geometry\n            console.warn('Using legacy line geometry update - tube geometry not found');\n            \n            // If using the old approach with direct buffer geometry\n            if (connection.waveformLine.geometry.attributes && \n                connection.waveformLine.geometry.attributes.position) {\n                \n                const positions = connection.waveformLine.geometry.attributes.position.array;\n                \n                // Start at source\n                for (let i = 0; i < this.waveformResolution; i++) {\n                    const t = i / (this.waveformResolution - 1); // Normalize to 0-1\n                    \n                    // Base position along straight line from source to target\n                    const x = sourcePos.x + (dirX * t);\n                    const z = sourcePos.z + (dirZ * t);\n                    \n                    // Apply waveform displacement perpendicular to the direction\n                    const displacement = waveform[i];\n                    \n                    const index = i * 3;\n                    positions[index] = x + (perpX * displacement);\n                    positions[index + 1] = 0.5;\n                    positions[index + 2] = z + (perpZ * displacement);\n                }\n                \n                connection.waveformLine.geometry.attributes.position.needsUpdate = true;\n            }\n        }\n        \n        // Make sure the arrow color matches the waveform color\n        if (connection.arrow && connection.arrow.material) {\n            // Apply the same color as the waveform\n            connection.arrow.material.color.copy(connection.waveformLine.material.color);\n        }\n        \n        // Set final opacity based on activity\n        if (connection.waveformLine && connection.waveformLine.material) {\n            // Check if this connection is being scrolled over\n            const isBeingScrolled = this.scrollingConnections.has(connection);\n            \n            if (isBeingScrolled) {\n                // Keep full opacity when scrolling\n                connection.waveformLine.material.opacity = 1.0;\n                if (connection.arrow && connection.arrow.material) {\n                    connection.arrow.material.opacity = 1.0;\n                }\n            } else {\n                // Update opacity based on fade factor\n                const minOpacity = this.inactiveOpacity;\n                const maxOpacity = this.activeOpacity;\n                const weight = connection.weight || 0.5;\n                // Weight affects maximum opacity\n                const targetOpacity = minOpacity + ((maxOpacity - minOpacity) * fadeFactor * weight * 1.2);\n                \n                // Update material opacity\n                connection.waveformLine.material.opacity = targetOpacity;\n                \n                // Update arrow opacity to match\n                if (connection.arrow && connection.arrow.material) {\n                    connection.arrow.material.opacity = targetOpacity;\n                }\n            }\n        }\n        \n        // Request animation frame to ensure continuous updates while firing or fading\n        if (fadeFactor > 0) {\n            this.needsUpdate = true;\n        }\n    }\n\n    updateConnection(connectionGroup) {\n        const connection = this.connections.get(connectionGroup);\n        if (!connection) return;\n\n        const { source, target, line, arrow, waveformLine } = connection;\n        \n        // Check for missing elements\n        if (!source || !target || !line || !arrow) {\n            console.warn(\"Connection has missing elements:\", !!source, !!target, !!line, !!arrow);\n            return;\n        }\n        \n        // Update the straight reference line (keep invisible)\n        const positions = line.geometry.attributes.position.array;\n        positions[0] = source.position.x;\n        positions[1] = -10; // Keep the line at neuron plane level\n        positions[2] = source.position.z;\n        positions[3] = target.position.x;\n        positions[4] = -10; // Keep the line at neuron plane level\n        positions[5] = target.position.z;\n        line.geometry.attributes.position.needsUpdate = true;\n        \n        const direction = new THREE.Vector3().subVectors(target.position, source.position).normalize();\n\n        const sourceGrowth = source.neuron ? \n            source.neuron.baseScale + (source.neuron.dcInput * 0.2) : 0.2;\n        const targetGrowth = target.neuron ? \n            target.neuron.baseScale + (target.neuron.dcInput * 0.2) : 0.2;\n\n        const minPosition = sourceGrowth;\n        const maxPosition = 1 - targetGrowth;\n\n        // Set opacity based on weight\n        const weight = connection.weight ?? 0.1;\n        const baseOpacity = 0.1;\n        const maxOpacity = 1.0;\n        \n        // Check if this is an instant connection\n        const speed = connection.speed ?? 0.5; \n        const isInstantConnection = speed >= 0.99;\n        \n        // Ensure arrow is visible while dragging or selected\n        if (this.isDraggingArrow && arrow === this.selectedArrow) {\n            arrow.material.opacity = 1.0; // Always fully visible when dragging\n            arrow.material.color.setHex(0x00ff00); // Green for selected\n            arrow.scale.setScalar(0.3); // Make it larger when selected for better visibility\n            \n            // Make waveform line match with higher brightness when selected\n            if (waveformLine) {\n                waveformLine.material.opacity = maxOpacity;\n                waveformLine.material.color.setHex(0x00ffff); // Bright cyan for selected\n            }\n        } else {\n            // Check if the neuron is firing - for consistent coloring with updateConnectionWaveform\n            const isActive = source.neuron && source.neuron.isFiring;\n            \n            // Check for harmonic relationship if harmonicSystem exists\n            let isHarmonic = false;\n            if (window.harmonicSystem && source.neuron && target.neuron) {\n                // Calculate distance between neurons\n                const distance = source.position.distanceTo(target.position);\n                \n                // Check if in harmonic proximity\n                if (window.harmonicSystem.isInHarmonicProximity(distance)) {\n                    const relationship = window.harmonicSystem.getHarmonicRelationship(\n                        source.neuron.id,\n                        target.neuron.id\n                    );\n                    \n                    if (relationship) {\n                                        // This is a harmonic connection - use cyan for the arrow too\n                const harmonyColor = new THREE.Color(0x00ffff); // Pure cyan\n                        const normalColor = new THREE.Color(0x00ffff);  // Cyan for regular\n                        const strength = Math.min(1.0, relationship.strength * 3);\n                        \n                        // Apply harmonic coloring\n                        arrow.material.color.lerpColors(normalColor, harmonyColor, strength);\n                        isHarmonic = true;\n                    }\n                }\n            }\n            \n            // Only set default colors if not a harmonic connection\n            if (!isHarmonic) {\n                // For instant connections, use a bright white-blue color \n                if (isInstantConnection) {\n                    arrow.material.color.setHex(0x40e0ff); // Light cyan/electric blue for instant connections\n                } else {\n                    // Default color is grey for normal connections\n                    arrow.material.color.setHex(0x808080); // Grey (was cyan)\n                }\n            }\n            \n            // Instant connections should be more visible\n            const opacity = isInstantConnection ? \n                Math.max(0.5, baseOpacity + (weight * (maxOpacity - baseOpacity))) : // Higher minimum for instant\n                Math.max(0.3, baseOpacity + (weight * (maxOpacity - baseOpacity))); // Regular minimum\n            \n            arrow.material.opacity = opacity;\n            \n            // Adjust scale based on weight and speed - instant connections get larger arrows\n            const baseScale = isInstantConnection ? 0.2 : 0.15;\n            const maxScale = isInstantConnection ? 0.45 : 0.35;\n            const scale = baseScale + (weight * (maxScale - baseScale));\n            arrow.scale.setScalar(scale);\n        }\n\n        // Only update arrow position if not being dragged\n        if (!this.isDraggingArrow || arrow !== this.selectedArrow) {\n            // Check if we have a cached position for this arrow\n            const connectionId = connection.source?.neuron?.id + \"_\" + connection.target?.neuron?.id;\n            \n            // Only recalculate position if needed or if a neuron in this connection is being dragged\n            if (!this.arrowPositionCache.has(connectionId) || \n                this.frameCount % 60 === 0 ||\n                this.isDraggingNeuron ||\n                window.draggedNeuron === connection.source ||\n                window.draggedNeuron === connection.target) {\n                \n                // Position the arrow differently for instant connections\n                let restrictedPosition;\n                \n                if (isInstantConnection) {\n                    // For instant connections, position arrow much closer to target\n                    restrictedPosition = 0.75; // Fixed position at 75% of the way to target\n                } else {\n                    // Normal positioning based on speed - use Math.round to ensure consistency\n                    const normalizedSpeed = Math.round(speed * 1000) / 1000; // Round to 3 decimal places\n                    restrictedPosition = minPosition + (normalizedSpeed * (maxPosition - minPosition));\n                }\n                \n                // Use a temp vector to avoid modifying source/target\n                const tempPos = new THREE.Vector3();\n                tempPos.lerpVectors(\n                    source.position,\n                    target.position,\n                    restrictedPosition\n                );\n                \n                // Round position to avoid minor floating point differences\n                tempPos.x = Math.round(tempPos.x * 1000) / 1000;\n                tempPos.z = Math.round(tempPos.z * 1000) / 1000;\n                tempPos.y = 0.5; // Fixed Y position ABOVE the neuron plane\n                \n                // Cache the calculated position\n                this.arrowPositionCache.set(connectionId, tempPos.clone());\n                \n                // Direct copy instead of component-wise assignment\n                arrow.position.copy(tempPos);\n            } else {\n                // Use cached position\n                arrow.position.copy(this.arrowPositionCache.get(connectionId));\n            }\n        }\n\n        const angle = Math.atan2(direction.z, direction.x);\n        arrow.rotation.set(-Math.PI/2, 0, -angle);\n        \n        // Keep regular line invisible since we're using waveform line instead\n        line.material.opacity = 0;\n    }\n\n    createConnection(sourceNeuron, targetNeuron) {\n        if (!sourceNeuron || !sourceNeuron.position || \n            !targetNeuron || !targetNeuron.position) {\n            console.warn('Invalid neurons for connection');\n            return null;\n        }\n    \n        // Generate random speed between 0.3 and 0.8\n        const randomSpeed = 0.3 + Math.random() * 0.5;  // This gives us a range of 0.3 to 0.8\n        \n        const connectionGroup = new THREE.Group();\n        \n        // Create regular line (keep but make invisible)\n        const line = new THREE.Line(\n            new THREE.BufferGeometry(),\n            new THREE.MeshBasicMaterial({\n                color: 0xaaaaaa,\n                transparent: true,\n                opacity: 0, // Make invisible\n                depthTest: true,\n                depthWrite: true\n            })\n        );\n        \n        const positions = new Float32Array(6);\n        line.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        \n        // Create initial waveform points - will be updated in updateConnectionWaveform\n        const waveformPoints = [];\n        for (let i = 0; i < this.waveformResolution; i++) {\n            // Create flat line initially\n            const t = i / (this.waveformResolution - 1);\n            waveformPoints.push(new THREE.Vector3(t, 0, 0));\n        }\n        \n        // Create a tube geometry for thicker lines\n        const waveformPath = new THREE.CatmullRomCurve3(waveformPoints);\n        const tubeGeometry = new THREE.TubeGeometry(\n            waveformPath,\n            this.waveformResolution,  // tubularSegments\n            this.waveformThickness,   // radius - use the configurable thickness property\n            8,                       // radialSegments\n            false                    // closed\n        );\n        \n        // Create waveform with tube geometry - use grey\n        const waveformLine = new THREE.Mesh(\n            tubeGeometry,\n            new THREE.MeshBasicMaterial({\n                color: 0x808080,  // Grey color (was cyan)\n                transparent: true,\n                opacity: 0, // Start fully transparent\n                depthTest: true,\n                depthWrite: true\n            })\n        );\n        \n        // Store path and points for updates\n        waveformLine.userData.path = waveformPath;\n        waveformLine.userData.points = waveformPoints;\n        \n        // Use grey for arrow too\n        const arrow = new THREE.Mesh(this.arrowGeometry, this.arrowMaterial.clone());\n        arrow.userData.isConnectionArrow = true;\n        arrow.matrixAutoUpdate = true;\n        arrow.raycast = THREE.Mesh.prototype.raycast;\n        arrow.material.opacity = 0; // Start fully transparent\n        arrow.material.color.setHex(0x808080); // Grey (was cyan)\n        \n        // Set initial arrow position above the neuron plane\n        arrow.position.y = 0.5;\n        \n        connectionGroup.add(line);\n        connectionGroup.add(waveformLine);\n        connectionGroup.add(arrow);\n        \n        const connection = {\n            source: sourceNeuron,\n            target: targetNeuron,\n            line: line,\n            waveformLine: waveformLine,\n            arrow: arrow,\n            weight: 0.4,\n            speed: randomSpeed  // Use the random speed\n        };\n        this.connections.set(connectionGroup, connection);\n        \n        // Initialize the waveform\n        this.updateConnectionWaveform(connection);\n        \n        this.scene.add(connectionGroup);\n    \n        const targetIndex = window.circles.indexOf(targetNeuron);\n        \n        // CRITICAL FIX: Add connection WITHOUT causing any pause in neuron firing\n        // The improved addConnection method now ensures no disruption to DC neuron timing\n        console.log(`[ConnectionManager] Creating connection from ${sourceNeuron?.neuron?.id} to ${targetNeuron?.neuron?.id}`);\n        console.log(`[ConnectionManager] Checking for centralized system: ${!!window.neuralSystem}`);\n        \n        if (window.neuralSystem) {\n            // Get the source neuron ID properly - it could be either in neuronId or in neuron.id\n            const sourceId = sourceNeuron.neuronId || (sourceNeuron.neuron ? sourceNeuron.neuron.id : null);\n            \n            // CRITICAL FIX: Get the target neuron ID instead of using array index\n            const targetId = targetNeuron.neuronId || (targetNeuron.neuron ? targetNeuron.neuron.id : null);\n            \n            console.log(`[ConnectionManager] Using centralized system - sourceId: ${sourceId}, targetId: ${targetId}`);\n            \n            // Use the centralized neural system\n            if (sourceId !== null && targetId !== null) {\n                // Ensure both neurons exist in the centralized system\n                const sourceExists = this.ensureNeuronExists(sourceId, sourceNeuron);\n                const targetExists = this.ensureNeuronExists(targetId, targetNeuron);\n                \n                if (sourceExists && targetExists) {\n                    window.neuralSystem.adapter.createConnection(\n                        sourceId, \n                        targetId, \n                        connection.weight, \n                        connection.speed\n                    );\n                    console.log(`[ConnectionManager] Connection created via centralized system`);\n                } else {\n                    console.warn(`[ConnectionManager] Failed to ensure neurons exist: source=${sourceExists}, target=${targetExists}`);\n                    // Fall back to the old method\n                    sourceNeuron.neuron.addConnection(targetIndex, connection.weight, connection.speed);\n                }\n            } else {\n                console.warn(`[ConnectionManager] Cannot use centralized system - invalid IDs`);\n                // Fall back to the old method\n                sourceNeuron.neuron.addConnection(targetIndex, connection.weight, connection.speed);\n            }\n        } else {\n            console.log(`[ConnectionManager] Using legacy connection method`);\n            // Fall back to the old method\n            sourceNeuron.neuron.addConnection(targetIndex, connection.weight, connection.speed);\n        }\n        \n        // REMOVED the refreshDCNeurons call entirely - it's no longer needed\n        // Our improved neuron.js code now handles connection changes without disruption\n        \n        // Fade in the connection\n        const weight = connection.weight ?? 0.5;\n        const baseOpacity = 0.1;\n        const maxOpacity = 1.0; // Slightly lower max opacity\n        const finalOpacity = baseOpacity + (weight * (maxOpacity - baseOpacity));\n        \n        gsap.to(arrow.material, {\n            opacity: finalOpacity,\n            duration: 0.3,\n            ease: \"power1.inOut\"\n        });\n        \n        gsap.to(waveformLine.material, {\n            opacity: finalOpacity,\n            duration: 0.3,\n            ease: \"power1.inOut\"\n        });\n        \n        // Visual feedback: flash both neurons green to indicate connection created\n        const flashNeuronGreen = (neuron) => {\n            if (!neuron || !neuron.material) return;\n            \n            // CRITICAL FIX: Don't block the neuron's internal updates\n            // REMOVED: setExternalAnimation call that was causing neurons to freeze\n            \n            // Kill any existing animations on this neuron\n            gsap.killTweensOf(neuron.scale);\n            gsap.killTweensOf(neuron.material.color);\n            \n            // Store original properties\n            const originalColor = neuron.material.color.clone();\n            const originalScale = neuron.scale.clone();\n            \n            // Create a timeline for the animation\n            gsap.timeline()\n                // First phase: scale up and turn bright cyan\n                .to(neuron.scale, {\n                    x: originalScale.x * 1.5, // Bigger scale increase (was 1.3)\n                    y: originalScale.y * 1.5,\n                    z: originalScale.z * 1.5,\n                    duration: 0.25, // Slightly longer duration\n                    ease: \"power3.out\" // Stronger easing\n                }, 0)\n                .to(neuron.material.color, {\n                    r: 0,\n                    g: 1.5, b: 1.5, // Brighter cyan (can exceed 1.0 for extra brightness in THREE.js)\n                    duration: 0.25\n                }, 0)\n                // Second phase: scale back and fade to original color\n                .to(neuron.scale, {\n                    x: originalScale.x,\n                    y: originalScale.y,\n                    z: originalScale.z,\n                    duration: 0.4, // Slightly longer for smoother return\n                    ease: \"elastic.out(1.1, 0.5)\" // Add elastic bounce when returning to normal size\n                }, 0.25)\n                .to(neuron.material.color, {\n                    r: originalColor.r,\n                    g: originalColor.g,\n                    b: originalColor.b,\n                    duration: 0.4\n                }, 0.25);\n        };\n        \n        // Create a particle explosion animation for the target neuron\n        const createParticleExplosion = (neuron) => {\n            if (!neuron || !neuron.position) return;\n            \n            // Create 8 particles in a burst around the neuron\n            const numParticles = 8;\n            const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);\n            \n            // Create bright cyan material for particles\n            const particleMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0, 1.5, 1.5), // Bright cyan\n                transparent: true,\n                opacity: 0.9\n            });\n            \n            for (let i = 0; i < numParticles; i++) {\n                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());\n                const angle = (i / numParticles) * Math.PI * 2;\n                const radius = 0.2;\n                \n                // Position around the neuron in a circle\n                particle.position.set(\n                    neuron.position.x + Math.cos(angle) * radius,\n                    neuron.position.y,\n                    neuron.position.z + Math.sin(angle) * radius\n                );\n                \n                // Set rotation to face camera\n                particle.rotation.x = -Math.PI / 2;\n                \n                // Add to scene\n                this.scene.add(particle);\n                \n                // Animate outward in a straight line\n                gsap.to(particle.position, {\n                    x: neuron.position.x + Math.cos(angle) * (radius * 4),\n                    z: neuron.position.z + Math.sin(angle) * (radius * 4),\n                    duration: 1,\n                    ease: \"power2.out\"\n                });\n                \n                // Fade out and remove\n                gsap.to(particle.material, {\n                    opacity: 0,\n                    duration: 1,\n                    ease: \"power2.out\",\n                    onComplete: () => {\n                        this.scene.remove(particle);\n                        particle.material.dispose();\n                        particle.geometry.dispose();\n                    }\n                });\n            }\n        };\n        \n        // Flash both neurons\n        flashNeuronGreen(sourceNeuron);\n        flashNeuronGreen(targetNeuron);\n        \n        // Add particle explosion on the target neuron only\n        createParticleExplosion(targetNeuron);\n        \n        // Selection ring has been removed - no bounce animation needed\n        \n        return connectionGroup;\n    }\n\n    validateConnections() {\n        for (const [group, connection] of this.connections) {\n            if (!connection.arrow || !connection.arrow.parent) {\n                console.warn('Invalid connection found:', connection);\n                this.connections.delete(group);\n                this.lastConnectionCount = this.connections.size;\n            }\n        }\n    }\n\n    disposeConnection(connection, connectionGroup) {\n        // Store the IDs of source and target neurons to clean up related signal particles\n        let sourceNeuronId = null;\n        let targetNeuronId = null;\n        \n        // Make sure to remove the connection from the source neuron\n        if (connection.source && connection.source.neuron && connection.target) {\n            sourceNeuronId = connection.source.neuron.id;\n            \n            const targetIndex = window.circles.indexOf(connection.target);\n            if (targetIndex !== -1) {\n                // Get target neuron ID if possible BEFORE removing the connection\n                if (connection.target.neuron) {\n                    targetNeuronId = connection.target.neuron.id;\n                }\n                \n                // Now remove the connection - this should also handle charge timeout cancellation\n                connection.source.neuron.removeConnection(targetIndex);\n                \n                // Create connection key\n                const connectionKey = `${sourceNeuronId}_${targetNeuronId}`;\n                \n                // Manually check and cancel any pending timeouts for this connection\n                if (window.Neuron && window.Neuron.pendingChargeDeliveries && \n                    window.Neuron.pendingChargeDeliveries.has(connectionKey)) {\n                    console.log(`Canceling pending charge delivery timeout for ${connectionKey}`);\n                    clearTimeout(window.Neuron.pendingChargeDeliveries.get(connectionKey));\n                    window.Neuron.pendingChargeDeliveries.delete(connectionKey);\n                }\n            }\n        }\n        \n        // Clean up any signal particles related to this connection\n        // Use the centralized static method for particle cleanup\n        if (window.Neuron && typeof window.Neuron.cleanupConnectionParticles === 'function') {\n            const removedCount = window.Neuron.cleanupConnectionParticles(sourceNeuronId, targetNeuronId);\n            console.log(`Cleaned up ${removedCount || 0} particles for connection from ${sourceNeuronId} to ${targetNeuronId}`);\n        }\n        \n        // Immediate cleanup of any particles in the scene that might match this connection\n        // This is a more aggressive approach to ensure no orphaned particles remain\n        if (window.Neuron && window.Neuron.allParticles && window.Neuron.allParticles.length > 0) {\n            console.log(`Checking ${window.Neuron.allParticles.length} particles for manual cleanup`);\n            \n            // Create a copy of the array to safely remove items while iterating\n            const particles = [...window.Neuron.allParticles];\n            \n            // Track removed particles\n            let manuallyRemoved = 0;\n            \n            // Check each particle\n            particles.forEach(particle => {\n                if (!particle || !particle.parent) return;\n                \n                // Check if this particle is part of the connection being removed\n                if (particle.sourceNeuronId === sourceNeuronId && particle.targetNeuronId === targetNeuronId) {\n                    // Cancel any timeout\n                    if (particle.timeoutId) {\n                        clearTimeout(particle.timeoutId);\n                    }\n                    \n                            // Remove from scene\n                                particle.parent.remove(particle);\n                            \n                    // Dispose resources\n                    if (particle.material) particle.material.dispose();\n                    if (particle.geometry) particle.geometry.dispose();\n                            \n                    // Remove from global array\n                            const index = window.Neuron.allParticles.indexOf(particle);\n                            if (index !== -1) {\n                                window.Neuron.allParticles.splice(index, 1);\n                        manuallyRemoved++;\n                            }\n                        }\n                    });\n            \n            if (manuallyRemoved > 0) {\n                console.log(`Manually removed ${manuallyRemoved} additional particles for connection ${sourceNeuronId} -> ${targetNeuronId}`);\n            }\n        }\n        \n        // Dispose of geometries and materials\n        if (connection.line) {\n            connection.line.geometry.dispose();\n            connection.line.material.dispose();\n        }\n        \n        if (connection.waveformLine) {\n            connection.waveformLine.geometry.dispose();\n            connection.waveformLine.material.dispose();\n        }\n        \n        if (connection.arrow) {\n            connection.arrow.geometry.dispose();\n            connection.arrow.material.dispose();\n        }\n        \n        // Remove from scene and connection map\n        this.scene.remove(connectionGroup);\n        this.connections.delete(connectionGroup);\n        \n        // Force a global orphaned particle cleanup after a short delay\n        // This catches any particles that might have been created after the connection was removed\n        setTimeout(() => {\n            if (window.Neuron && typeof window.Neuron.cleanupOrphanedParticles === 'function') {\n                window.Neuron.cleanupOrphanedParticles();\n            }\n        }, 100);\n    }\n\n    dispose() {\n        const componentId = 'connectionManager';\n        \n        // Use the eventManager if available\n        if (window.eventManager) {\n            window.eventManager.cleanupComponent(componentId);\n        } else {\n            // Fallback to direct event listener removal\n            const canvas = this.renderer.domElement;\n            canvas.removeEventListener('mousedown', this.handlePointerDown);\n            canvas.removeEventListener('mousemove', this.handlePointerMove);\n            canvas.removeEventListener('mouseup', this.handlePointerUp);\n            canvas.removeEventListener('wheel', this.handleWheel);\n            canvas.removeEventListener('mouseleave', () => this.hideWeightLabel());\n            canvas.removeEventListener('touchstart', this.handlePointerDown);\n            canvas.removeEventListener('touchmove', this.handlePointerMove);\n            canvas.removeEventListener('touchend', this.handlePointerUp);\n            canvas.removeEventListener('contextmenu', this.handleRightClick);\n        }\n        \n        // Use the timerManager if available\n        if (window.timerManager) {\n            window.timerManager.clearGroup(componentId);\n        } else {\n            // Clear any active timeouts\n            if (this.longPressTimeout) {\n                clearTimeout(this.longPressTimeout);\n                this.longPressTimeout = null;\n            }\n            \n            // Clear intervals\n            if (this.validationInterval) {\n                clearInterval(this.validationInterval);\n                this.validationInterval = null;\n            }\n        }\n        \n        // Clean up UI elements\n        this.hideWeightLabel();\n        \n        // Use resourceManager if available to dispose THREE.js resources\n        if (window.resourceManager) {\n            window.resourceManager.cleanupOwner(componentId);\n        } else {\n            // Fallback to direct disposal\n            // Dispose of geometries and materials\n            if (this.arrowGeometry) this.arrowGeometry.dispose();\n            if (this.arrowMaterial) this.arrowMaterial.dispose();\n            \n            // Clean up all connections\n            this.connections.forEach(this.disposeConnection.bind(this));\n        }\n    }\n\n    // Centralized method to select a connection\n    selectConnection(connection) {\n        // Deselect the currently selected connection if any\n        if (this.selectedConnection && this.selectedConnection !== connection) {\n            this.selectedConnection.arrow.material.color.setHex(0x00ffff); // Cyan for non-selected\n            this.selectedConnection.arrow.scale.setScalar(0.25);\n        }\n        \n        // Set new selection\n        this.selectedConnection = connection;\n        if (connection) {\n            this.selectedArrow = connection.arrow;\n            \n            // Update the global settings - don't override existing values\n            if (window.settings) {\n                window.settings.selectedConnection = connection;\n                \n                // Only set these if they're not already set to the correct values\n                // This prevents overriding the current values when selecting an already configured connection\n                if (window.settings.selectedWeight !== connection.weight) {\n                    window.settings.selectedWeight = connection.weight || 0.5;\n                }\n                \n                if (window.settings.selectedSpeed !== connection.speed) {\n                    window.settings.selectedSpeed = connection.speed || 0.5;\n                }\n                \n                // Force refresh Tweakpane\n                if (window.pane) {\n                    window.pane.refresh();\n                }\n            }\n            \n            // Update the arrow appearance to show it's selected\n            connection.arrow.material.color.setHex(0x00ff00); // Bright green for selected\n            connection.arrow.scale.setScalar(0.3);\n            connection.arrow.material.opacity = 1.0;\n            \n            // Force an update of this connection\n            const connectionGroup = Array.from(this.connections.entries())\n                .find(([_, conn]) => conn === connection)?.[0];\n            if (connectionGroup) {\n                this.updateConnection(connectionGroup);\n            }\n        }\n    }\n    \n    // Method to deselect current connection\n    deselectConnection() {\n        if (this.selectedConnection) {\n            this.selectedConnection.arrow.material.color.setHex(0x00ffff); // Cyan for non-selected\n            this.selectedConnection.arrow.scale.setScalar(0.25);\n            this.selectedConnection = null;\n            this.selectedArrow = null;\n            \n            // Reset connection settings\n            if (window.settings) {\n                window.settings.selectedConnection = null;\n                window.settings.selectedWeight = 0.5;\n                window.settings.selectedSpeed = 0.5;\n                \n                // Force refresh Tweakpane\n                if (window.pane) {\n                    window.pane.refresh();\n                }\n            }\n        }\n    }\n\n    // Handle right-click to delete connections\n    handleRightClick(event) {\n        // Prevent the default context menu\n        event.preventDefault();\n        \n        // Update mouse position and raycaster\n        this.updateMousePosition(event);\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Make intersection area much larger for better arrow detection\n        const originalLineThreshold = this.raycaster.params.Line ? this.raycaster.params.Line.threshold : 1;\n        if (this.raycaster.params.Line) {\n            // Significantly increase the threshold to make it easier to click\n            this.raycaster.params.Line.threshold = 15;\n        }\n        \n        // Get all arrows and waveform lines for better hit detection\n        const arrows = [];\n        const waveformLines = [];\n        \n        this.connections.forEach(connection => {\n            if (connection.arrow) arrows.push(connection.arrow);\n            if (connection.waveformLine) waveformLines.push(connection.waveformLine);\n        });\n        \n        // First check for intersections with arrows\n        let intersects = this.raycaster.intersectObjects(arrows, false);\n        \n        // If no arrows were hit, try the waveform lines too\n        if (intersects.length === 0) {\n            intersects = this.raycaster.intersectObjects(waveformLines, false);\n        }\n        \n        // Reset the raycaster threshold\n        if (this.raycaster.params.Line) {\n            this.raycaster.params.Line.threshold = originalLineThreshold;\n        }\n        \n        // Only proceed if we actually clicked on a connection element\n        if (intersects.length > 0) {\n            // Find the connection that was clicked\n            let connectionToDelete = null;\n            let connectionGroupToDelete = null;\n            const clickedObject = intersects[0].object;\n            \n            for (const [group, connection] of this.connections.entries()) {\n                if (connection.arrow === clickedObject || connection.waveformLine === clickedObject) {\n                    connectionToDelete = connection;\n                    connectionGroupToDelete = group;\n                    break;\n                }\n            }\n            \n            if (connectionToDelete && connectionGroupToDelete) {\n                // Store references to source/target for visual feedback\n                const source = connectionToDelete.source;\n                const target = connectionToDelete.target;\n                \n                // First, flash the neurons red to indicate deletion\n                if (source && target) {\n                    // Flash the source and target neurons in red\n                    const flashFeedback = (neuron) => {\n                        if (!neuron || !neuron.material) return;\n                        \n                        const originalColor = neuron.material.color.clone();\n                        gsap.timeline()\n                            .to(neuron.material.color, {\n                                r: 1,\n                                g: 0,\n                                b: 0,\n                                duration: 0.2\n                            })\n                            .to(neuron.material.color, {\n                                r: originalColor.r,\n                                g: originalColor.g,\n                                b: originalColor.b,\n                                duration: 0.2\n                            });\n                    };\n                    \n                    // Flash both neurons that are involved\n                    flashFeedback(source);\n                    flashFeedback(target);\n                }\n                \n                // IMPORTANT: Immediately make the connection visible and red\n                // This provides visual feedback without risking animation issues\n                if (connectionToDelete.arrow && connectionToDelete.arrow.material) {\n                    connectionToDelete.arrow.material.color.set(0xff0000);\n                    connectionToDelete.arrow.material.opacity = 1.0;\n                }\n                \n                if (connectionToDelete.waveformLine && connectionToDelete.waveformLine.material) {\n                    connectionToDelete.waveformLine.material.color.set(0xff0000);\n                    connectionToDelete.waveformLine.material.opacity = 1.0;\n                }\n                \n                // Play a sound for deletion feedback\n                if (window.soundManager && typeof window.soundManager.playSmallSound === 'function') {\n                    try {\n                        window.soundManager.playSmallSound(0.2, 0.8, 0.5);\n                    } catch (error) {\n                        console.warn('Error playing connection deletion sound:', error);\n                    }\n                }\n                \n                // Use a very short timeout to ensure the red visuals render before deletion\n                setTimeout(() => {\n                    // Now actually delete the connection\n                    if (connectionToDelete && connectionGroupToDelete) {\n                        // Check if this was the selected connection and deselect if needed\n                        if (this.selectedConnection === connectionToDelete) {\n                            this.selectedConnection = null;\n                            this.selectedArrow = null;\n                            \n                            // Update the UI\n                            if (window.settings) {\n                                window.settings.selectedConnection = null;\n                                window.settings.selectedWeight = 0.5;\n                                window.settings.selectedSpeed = 0.5;\n                                \n                                // Force refresh Tweakpane\n                                if (window.pane) {\n                                    window.pane.refresh();\n                                }\n                            }\n                        }\n                        \n                        // Do the actual disposal\n                        this.disposeConnection(connectionToDelete, connectionGroupToDelete);\n                        \n                        // Force a redraw to ensure changes are visible\n                        this.needsUpdate = true;\n                    }\n                }, 50); // Short delay to ensure the red flash is visible\n            }\n        }\n    }\n\n    // Handle long press on mobile for connection deletion\n    handleLongPress(connection) {\n        // Only proceed if the connection is valid\n        if (!connection || !connection.source || !connection.target) return;\n        \n        // Find the connection group\n        let connectionGroup = null;\n        for (const [group, conn] of this.connections.entries()) {\n            if (conn === connection) {\n                connectionGroup = group;\n                break;\n            }\n        }\n        \n        if (!connectionGroup) return;\n        \n        // Clear the timeout\n        this.longPressTimeout = null;\n        \n        // Get source and target\n        const source = connection.source;\n        const target = connection.target;\n        \n        // Visual feedback - pulse animation in red\n        const flashFeedback = (neuron) => {\n            if (!neuron || !neuron.material) return;\n            \n            const originalColor = neuron.material.color.clone();\n            const originalScale = neuron.scale.clone();\n            \n            gsap.timeline()\n                .to(neuron.scale, {\n                    x: originalScale.x * 1.3,\n                    y: originalScale.y * 1.3,\n                    z: originalScale.z * 1.3,\n                    duration: 0.2,\n                    ease: \"power2.out\"\n                }, 0)\n                .to(neuron.material.color, {\n                    r: 1,\n                    g: 0,\n                    b: 0,\n                    duration: 0.2\n                }, 0)\n                .to(neuron.scale, {\n                    x: originalScale.x,\n                    y: originalScale.y,\n                    z: originalScale.z,\n                    duration: 0.2,\n                    ease: \"power2.in\"\n                }, 0.2)\n                .to(neuron.material.color, {\n                    r: originalColor.r,\n                    g: originalColor.g,\n                    b: originalColor.b,\n                    duration: 0.2\n                }, 0.2);\n        };\n        \n        flashFeedback(source);\n        flashFeedback(target);\n        \n        // Play deletion sound\n        if (window.soundManager && typeof window.soundManager.playSmallSound === 'function') {\n            try {\n                window.soundManager.playSmallSound(0.2, 0.8, 0.5);\n            } catch (error) {\n                console.warn('Error playing connection deletion sound:', error);\n            }\n        }\n        \n        // Delete the connection\n        this.disposeConnection(connection, connectionGroup);\n        \n        // Deselect the connection if it was selected\n        if (this.selectedConnection === connection) {\n            this.selectedConnection = null;\n            this.selectedArrow = null;\n            \n            // Update UI\n            if (window.settings) {\n                window.settings.selectedConnection = null;\n                window.settings.selectedWeight = 0.5;\n                window.settings.selectedSpeed = 0.5;\n                \n                // Force refresh Tweakpane\n                if (window.pane) {\n                    window.pane.refresh();\n                }\n            }\n        }\n    }\n\n    // Diagnostic function to log information about the sound manager\n    logSoundManagerInfo() {\n        if (!window.soundManager) {\n            console.log('No soundManager available');\n            return;\n        }\n        \n        console.log('SoundManager inspection:');\n        \n        // Check oscillators\n        if (window.soundManager.oscillators) {\n            console.log('Oscillators available:', Object.keys(window.soundManager.oscillators).length);\n            \n            // Check first oscillator\n            const firstKey = Object.keys(window.soundManager.oscillators)[0];\n            if (firstKey) {\n                const osc = window.soundManager.oscillators[firstKey];\n                console.log('Sample oscillator structure:', Object.keys(osc));\n                \n                // Check if there's a method to get waveform\n                console.log('Has waveform property:', !!osc.waveform);\n            }\n        } else {\n            console.log('No oscillators property found');\n        }\n        \n        // Check analyzer\n        if (window.soundManager.waveformAnalyzer) {\n            console.log('WaveformAnalyzer available');\n            console.log('Analyzer methods:', Object.keys(window.soundManager.waveformAnalyzer));\n            \n            // Try to get a sample\n            try {\n                const sample = window.soundManager.waveformAnalyzer.getValue();\n                console.log('Sample waveform data:', sample ? `Length: ${sample.length}` : 'No data');\n                \n                if (sample && sample.length > 0) {\n                    console.log('First few values:', sample.slice(0, 5));\n                }\n            } catch (error) {\n                console.log('Error getting analyzer data:', error);\n            }\n        }\n        \n        // Check for direct methods\n        console.log('Has getWaveformForNeuron method:', typeof window.soundManager.getWaveformForNeuron === 'function');\n    }\n\n    // Method to change the waveform thickness\n    setWaveformThickness(thickness) {\n        if (thickness < 0.1) thickness = 0.1; // Minimum thickness\n        if (thickness > 2.0) thickness = 2.0; // Maximum thickness\n        \n        this.waveformThickness = thickness;\n        \n        // Update all connections with new thickness\n        this.connections.forEach((connection, connectionGroup) => {\n            // Only update if using tube geometry\n            if (connection.waveformLine && \n                connection.waveformLine.userData && \n                connection.waveformLine.userData.path) {\n                \n                // Create new tube geometry with updated thickness\n                const newTubeGeometry = new THREE.TubeGeometry(\n                    connection.waveformLine.userData.path,\n                    this.waveformResolution,\n                    this.waveformThickness,\n                    8,\n                    false\n                );\n                \n                // Update the geometry\n                connection.waveformLine.geometry.dispose();\n                connection.waveformLine.geometry = newTubeGeometry;\n            }\n        });\n        \n        console.log(`Waveform thickness set to: ${thickness}`);\n        return thickness;\n    }\n\n    /**\n     * Force updates for all connections involving a specific neuron\n     * @param {Object} neuron - The neuron that's being dragged\n     */\n    forceUpdateConnectionsForNeuron(neuron) {\n        if (!neuron || !neuron.neuron) return;\n        \n        // Set drag state to true to ensure immediate updates\n        this.isDraggingNeuron = true;\n        \n        // Track which connections we've updated\n        const updatedConnections = new Set();\n        \n        // Clear all position caches for connections involving this neuron\n        this.connections.forEach((connection, group) => {\n            if (connection.source === neuron || connection.target === neuron) {\n                // Clear cached positions for this connection\n                const connectionId = connection.source?.neuron?.id + \"_\" + connection.target?.neuron?.id;\n                if (connectionId) {\n                    this.arrowPositionCache.delete(connectionId);\n                }\n                \n                // Clear source/target position caches\n                if (connection.source?.neuron) {\n                    this.lastSourcePositions.delete(connection.source.neuron.id);\n                }\n                \n                if (connection.target?.neuron) {\n                    this.lastTargetPositions.delete(connection.target.neuron.id);\n                }\n                \n                // Force an immediate update of this connection\n                if (!updatedConnections.has(group)) {\n                    this.updateConnection(group);\n                    updatedConnections.add(group);\n                }\n            }\n        });\n        \n        // Force a waveform update too\n        if (this.frameCount % 2 !== 0) {\n            this.connections.forEach(connection => {\n                if (connection.source === neuron || connection.target === neuron) {\n                    this.updateConnectionWaveform(connection);\n                }\n            });\n        }\n        \n        // Request another update on the next frame\n        this.needsUpdate = true;\n    }\n\n    // Debug method to log neuron firing state\n    debugNeuronFiring() {\n        // Get all neurons\n        const neurons = window.circles || [];\n        \n        console.log(`----- Neuron Firing States (${neurons.length} neurons) -----`);\n        \n        let firingCount = 0;\n        neurons.forEach((neuron, index) => {\n            if (!neuron.neuron) return;\n            \n            const isFiring = neuron.neuron.isFiring;\n            if (isFiring) {\n                firingCount++;\n                console.log(`Neuron ${neuron.neuron.id}: FIRING`);\n            }\n        });\n        \n        console.log(`Total firing neurons: ${firingCount}/${neurons.length}`);\n        \n        // Check connections\n        console.log(`----- Connection Status (${this.connections.size} connections) -----`);\n        \n        let activeConnections = 0;\n        this.connections.forEach((connection) => {\n            const sourceNeuron = connection.source?.neuron;\n            const sourceId = sourceNeuron ? sourceNeuron.id : \"unknown\";\n            const isFiring = sourceNeuron ? sourceNeuron.isFiring : false;\n            \n            if (isFiring) {\n                activeConnections++;\n                const targetNeuron = connection.target?.neuron;\n                const targetId = targetNeuron ? targetNeuron.id : \"unknown\";\n                console.log(`Connection ${sourceId} -> ${targetId}: ACTIVE`);\n            }\n        });\n        \n        console.log(`Active connections: ${activeConnections}/${this.connections.size}`);\n    }\n\n    /**\n     * Ensure a neuron exists in the centralized system\n     * This is a helper method to avoid \"neuron not found\" errors\n     * @param {string} neuronId The ID of the neuron to ensure\n     * @param {Object} neuron The neuron object with properties\n     * @returns {boolean} True if the neuron exists or was created\n     */\n    ensureNeuronExists(neuronId, circle) {\n        if (!window.neuralSystem || !neuronId) return false;\n        \n        // Check if the neuron already exists\n        if (window.neuralEngine.getNeuron(neuronId)) {\n            return true;\n        }\n        \n        console.log(`[ConnectionManager] Creating missing neuron ${neuronId} in centralized system`);\n        \n        // Create the neuron in the centralized system\n        const baseProps = circle.neuron || {};\n        const neuron = window.neuralEngine.createNeuron({\n            id: neuronId,\n            mesh: circle,\n            position: {\n                x: circle.position.x,\n                y: circle.position.y,\n                z: circle.position.z\n            },\n            baseScale: baseProps.baseScale || 0.2,\n            maxScale: baseProps.maxScale || 1,\n            originalColor: baseProps.originalColor || 0x0000ff,\n            firingColor: baseProps.firingColor || 0xffff00,\n            presetColor: baseProps.presetColor || null,\n            presetName: baseProps.presetName || null,\n            dcInput: baseProps.dcInput || 0\n        });\n        \n        // Register with adapter\n        if (window.neuronAdapter) {\n            window.neuronAdapter.neuronMeshes.set(neuronId, circle);\n        }\n        \n        // Store neuronId on circle\n        circle.neuronId = neuronId;\n        \n        return true;\n    }\n}\n","import * as THREE from 'three';\n\nimport Logger from './utils/logger';\n\n/**\n * WorkerManager\n * Coordinates between simulation worker, audio worker, and main thread\n * Decouples UI operations from simulation and audio processing\n */\nexport class WorkerManager {\n  constructor(soundManager) {\n    this.soundManager = soundManager;\n    this.simulationWorker = null;\n    this.audioWorker = null;\n    this.isInitialized = false;\n    this.neuronState = new Map();\n    this.connectionState = new Map();\n    this.lastSyncTime = 0;\n    this.pendingAudioEvents = [];\n    this.stats = {\n      simulationFPS: 0,\n      audioEventsPerSecond: 0,\n      audioQueueLength: 0,\n      simulationQueueLength: 0\n    };\n    \n    // Debug logging\n    this.enableDebugLogging = false;\n    \n    // Initialize the workers\n    this.initialize();\n    \n    // Populate with existing neurons after a brief delay\n    setTimeout(() => this.initializeWithExistingNeurons(), 100);\n    \n    // Bind methods\n    this.handleSimulationMessage = this.handleSimulationMessage.bind(this);\n    this.handleAudioMessage = this.handleAudioMessage.bind(this);\n    this.processAudioEvents = this.processAudioEvents.bind(this);\n  }\n  \n  // Initialize all workers\n  initialize() {\n    try {\n      this.log('Initializing workers...');\n      \n      // Create simulation worker\n      this.simulationWorker = new Worker('/worker/simulationWorker.js');\n      this.simulationWorker.onmessage = this.handleSimulationMessage.bind(this);\n      \n      // Create audio worker\n      this.audioWorker = new Worker('/worker/audioWorker.js');\n      this.audioWorker.onmessage = this.handleAudioMessage.bind(this);\n      \n      // Initialize workers\n      this.simulationWorker.postMessage({ type: 'init' });\n      this.audioWorker.postMessage({ type: 'init' });\n      \n      this.isInitialized = true;\n      this.log('Workers initialized');\n      \n      // Set up periodic sync to keep workers in sync with main thread\n      this.syncInterval = setInterval(() => this.syncState(), 5000);\n      \n      // Handle audio events processing on main thread\n      this.processAudioEvents();\n    } catch (error) {\n      Logger.error('Failed to initialize workers:', error);\n      this.isInitialized = false;\n    }\n  }\n  \n  // Initialize with existing neurons from the scene\n  initializeWithExistingNeurons() {\n    if (!this.isInitialized) return;\n    \n    try {\n      if (window.circles && window.circles.length > 0) {\n        this.log(`Adding ${window.circles.length} existing neurons to simulation worker`);\n        \n        // Add all existing neurons to the simulation worker\n        window.circles.forEach(circle => {\n          if (circle.neuron) {\n            this.addNeuron(circle.neuron);\n          }\n        });\n        \n        // Add all existing connections to the simulation worker\n        if (window.connectionManager && window.connectionManager.connections) {\n          this.log(`Adding existing connections to simulation worker`);\n          \n          window.connectionManager.connections.forEach((connection, id) => {\n            if (connection.source && connection.target && \n                connection.source.neuron && connection.target.neuron) {\n              \n              this.addConnection({\n                id: id,\n                sourceId: connection.source.neuron.id,\n                targetId: connection.target.neuron.id,\n                weight: connection.weight || 0.5,\n                delay: connection.delay || 0,\n                speed: connection.speed || 0.5\n              });\n            }\n          });\n        }\n      }\n    } catch (error) {\n      Logger.error('Error initializing with existing neurons:', error);\n    }\n  }\n  \n  // Handle messages from simulation worker\n  handleSimulationMessage(event) {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'firingEvents':\n        this.handleFiringEvents(message.events);\n        break;\n        \n      case 'stateUpdate':\n        // Update local state with worker state\n        message.neurons.forEach(neuron => {\n          this.neuronState.set(neuron.id, neuron);\n        });\n        break;\n        \n      case 'syncComplete':\n        this.log(`Simulation sync complete: ${performance.now() - message.time}ms`);\n        break;\n    }\n  }\n  \n  // Handle messages from audio worker\n  handleAudioMessage(event) {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'playSound':\n        // Queue the sound event for processing\n        this.pendingAudioEvents.push(message.event);\n        break;\n        \n      case 'stats':\n        this.stats.audioQueueLength = message.queueLength;\n        this.stats.audioEventsPerSecond = message.totalProcessed;\n        break;\n    }\n  }\n  \n  // Handle firing events from simulation worker\n  handleFiringEvents(events) {\n    events.forEach(event => {\n      // Update visual state for neuron\n      if (window.circles) {\n        const neuronVisual = window.circles.find(c => c.neuron && c.neuron.id === event.neuronId);\n        if (neuronVisual) {\n          // Flash the neuron\n          this.flashNeuron(neuronVisual);\n          \n          // Create particle effects on main thread\n          event.connections.forEach(conn => {\n            const targetNeuron = window.circles.find(c => c.neuron && c.neuron.id === conn.targetId);\n            if (targetNeuron) {\n              this.createParticle(neuronVisual, targetNeuron, conn.weight, conn.speed);\n            }\n          });\n        }\n      }\n      \n      // Forward to audio worker with neuron sound parameters\n      let params = {};\n      if (this.soundManager && typeof this.soundManager.getNeuronSoundParameters === 'function') {\n        params = this.soundManager.getNeuronSoundParameters(event.neuronId) || {};\n      }\n      \n      this.audioWorker.postMessage({\n        type: 'neuronFired',\n        neuronId: event.neuronId,\n        timestamp: event.timestamp,\n        weight: event.connections.length > 0 ? event.connections[0].weight : 0.5,\n        speed: event.connections.length > 0 ? event.connections[0].speed : 0.5,\n        hasDC: event.hasDC,\n        parameters: params\n      });\n    });\n  }\n  \n  // Process audio events on main thread\n  processAudioEvents() {\n    const processFrame = () => {\n      if (this.pendingAudioEvents.length > 0) {\n        // Process a limited number of events per frame to maintain UI responsiveness\n        const maxEventsPerFrame = 5;\n        const eventsToProcess = this.pendingAudioEvents.splice(0, maxEventsPerFrame);\n        \n        eventsToProcess.forEach(event => {\n          if (this.soundManager && typeof this.soundManager.playNeuronFiring === 'function') {\n            this.soundManager.playNeuronFiring(\n              event.weight || 0.5,\n              event.speed || 0.5,\n              event.neuronId,\n              false,\n              event.hasDC\n            );\n          }\n        });\n      }\n      \n      requestAnimationFrame(processFrame);\n    };\n    \n    processFrame();\n  }\n  \n  // Flash a neuron visual in the 3D scene\n  flashNeuron(neuronVisual) {\n    if (!neuronVisual || !neuronVisual.material) return;\n    \n    const originalColor = neuronVisual.material.color.clone();\n    const flashColor = new THREE.Color(1, 1, 1);\n    \n    // Keep track of original color\n    if (!neuronVisual.originalColor) {\n      neuronVisual.originalColor = originalColor.clone();\n    }\n    \n    // Flash white, then return to original\n    neuronVisual.material.color.copy(flashColor);\n    \n    setTimeout(() => {\n      if (neuronVisual && neuronVisual.material) {\n        neuronVisual.material.color.copy(originalColor);\n      }\n    }, 50);\n  }\n  \n  // Create a particle to visualize neuron signal\n  createParticle(sourceNeuron, targetNeuron, weight = 0.5, speed = 0.5) {\n    // Make sure we have the scene\n    if (!window.scene) return;\n    \n    // Check if we have the optimized particle system\n    if (window.particleSystem && typeof window.particleSystem.createParticle === 'function') {\n      // Get source and target positions\n      const sourcePos = sourceNeuron.position.clone();\n      sourcePos.y = 0.05; // Raise slightly above the neuron\n      \n      const targetPos = targetNeuron.position.clone();\n      targetPos.y = 0.05;\n      \n      // Use the optimized particle system\n      window.particleSystem.createParticle(\n        sourcePos,\n        targetPos,\n        sourceNeuron.neuron.id,\n        targetNeuron.neuron.id,\n        weight,\n        speed\n      );\n      \n      Logger.debug(`[WorkerManager] Created particle via OptimizedParticleSystem`);\n    } else {\n      Logger.warn('[WorkerManager] OptimizedParticleSystem not available');\n    }\n  }\n  \n  // Update particles is no longer needed as the OptimizedParticleSystem handles its own updates\n  updateParticles(deltaTime) {\n    // Forward to optimized particle system if available\n    if (window.particleSystem && typeof window.particleSystem.update === 'function') {\n      window.particleSystem.update(deltaTime);\n    }\n  }\n  \n  // Add a neuron to the simulation\n  addNeuron(neuron) {\n    if (!this.isInitialized) return;\n    \n    const neuronData = {\n      id: neuron.id,\n      type: neuron.type || 'LIF',\n      threshold: neuron.threshold,\n      restingPotential: neuron.restingPotential,\n      currentPotential: neuron.currentPotential,\n      refractoryPeriod: neuron.refractoryPeriod,\n      dcInput: neuron.dcInput || 0,\n      decayRate: neuron.decayRate,\n      position: {\n        x: neuron.position ? neuron.position.x : 0,\n        y: neuron.position ? neuron.position.y : 0,\n        z: neuron.position ? neuron.position.z : 0\n      },\n      oscillatorFrequency: neuron.oscillatorFrequency || 10\n    };\n    \n    this.neuronState.set(neuron.id, neuronData);\n    \n    this.simulationWorker.postMessage({\n      type: 'addNeuron',\n      neuron: neuronData\n    });\n  }\n  \n  // Update a neuron's properties\n  updateNeuron(neuronId, properties) {\n    if (!this.isInitialized) return;\n    \n    // Update local state\n    if (this.neuronState.has(neuronId)) {\n      const neuron = this.neuronState.get(neuronId);\n      Object.assign(neuron, properties);\n    }\n    \n    // Send to worker\n    this.simulationWorker.postMessage({\n      type: 'updateNeuron',\n      neuronId,\n      properties\n    });\n  }\n  \n  // Remove a neuron from the simulation\n  removeNeuron(neuronId) {\n    if (!this.isInitialized) return;\n    \n    this.neuronState.delete(neuronId);\n    \n    this.simulationWorker.postMessage({\n      type: 'removeNeuron',\n      neuronId\n    });\n  }\n  \n  // Set DC input for a neuron\n  setDCInput(neuronId, value) {\n    if (!this.isInitialized) return;\n    \n    // Update local state\n    if (this.neuronState.has(neuronId)) {\n      const neuron = this.neuronState.get(neuronId);\n      neuron.dcInput = Math.max(0, Math.min(1, value));\n    }\n    \n    // Send to worker\n    this.simulationWorker.postMessage({\n      type: 'setDCInput',\n      neuronId,\n      value\n    });\n  }\n  \n  // Add a connection to the simulation\n  addConnection(connection) {\n    if (!this.isInitialized) return;\n    \n    try {\n      // Only send to the simulation worker - avoid any disruptions to the main thread\n      this.simulationWorker.postMessage({\n        type: 'addConnection',\n        connection: connection\n      });\n      \n      // Store in local state\n      this.connectionState.set(connection.id, connection);\n      \n      this.log(`Added connection from ${connection.sourceId} to ${connection.targetId}`);\n    } catch (error) {\n      Logger.error('Error adding connection to worker:', error);\n    }\n  }\n  \n  // Update a connection's properties\n  updateConnection(connectionId, properties) {\n    if (!this.isInitialized) return;\n    \n    // Update local state\n    if (this.connectionState.has(connectionId)) {\n      const connection = this.connectionState.get(connectionId);\n      Object.assign(connection, properties);\n    }\n    \n    // Send to worker\n    this.simulationWorker.postMessage({\n      type: 'updateConnection',\n      connectionId,\n      properties\n    });\n  }\n  \n  // Remove a connection from the simulation\n  removeConnection(connectionId) {\n    if (!this.isInitialized) return;\n    \n    this.connectionState.delete(connectionId);\n    \n    this.simulationWorker.postMessage({\n      type: 'removeConnection',\n      connectionId\n    });\n  }\n  \n  // Sync state between main thread and workers\n  syncState() {\n    if (!this.isInitialized) return;\n    \n    this.lastSyncTime = performance.now();\n    \n    // Send current state to simulation worker\n    this.simulationWorker.postMessage({\n      type: 'sync',\n      neurons: Array.from(this.neuronState.values()),\n      connections: Array.from(this.connectionState.values()),\n      time: this.lastSyncTime\n    });\n  }\n  \n  // Pause both workers\n  pause() {\n    if (!this.isInitialized) return;\n    \n    this.simulationWorker.postMessage({ type: 'pause' });\n    this.audioWorker.postMessage({ type: 'pause' });\n  }\n  \n  // Resume both workers\n  resume() {\n    if (!this.isInitialized) return;\n    \n    this.simulationWorker.postMessage({ type: 'resume' });\n    this.audioWorker.postMessage({ type: 'resume' });\n  }\n  \n  // Set simulation rate\n  setSimulationRate(rate) {\n    if (!this.isInitialized) return;\n    \n    this.simulationWorker.postMessage({\n      type: 'updateRate',\n      rate\n    });\n  }\n  \n  // Update audio settings\n  updateAudioSettings(settings) {\n    if (!this.isInitialized) return;\n    \n    this.audioWorker.postMessage({\n      type: 'updateSettings',\n      settings\n    });\n  }\n  \n  // Get current statistics\n  getStats() {\n    return this.stats;\n  }\n  \n  // Clean up resources\n  cleanup() {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n    \n    if (this.simulationWorker) {\n      this.simulationWorker.terminate();\n      this.simulationWorker = null;\n    }\n    \n    if (this.audioWorker) {\n      this.audioWorker.terminate();\n      this.audioWorker = null;\n    }\n    \n    this.isInitialized = false;\n    this.neuronState.clear();\n    this.connectionState.clear();\n    this.pendingAudioEvents = [];\n  }\n  \n  // Helper for logging\n  log(message) {\n    if (this.enableDebugLogging) {\n      Logger.debug(`[WorkerManager] ${message}`);\n    }\n  }\n} ","import * as Tone from 'tone';\nimport Logger from './utils/logger';\n\nimport * as THREE from 'three';\n\n/**\n * HarmonicSystem class\n * \n * Implements a proximity-based harmonic relationship system that allows\n * neurons to influence each other's musical characteristics based on\n * their spatial proximity and interaction over time.\n */\nexport class HarmonicSystem {\n    constructor(scene, soundManager) {\n        // Core references\n        this.scene = scene;\n        this.soundManager = soundManager;\n        \n        // Configuration\n        this.harmonyStrength = 0.5; // 0-1 scale of global harmonic influence\n        this.maxInfluenceDistance = 2.5; // Increased to 2.5 for wider range of green connections\n        this.minInfluenceDistance = 0.6; // Distance for maximum harmonic influence\n        this.learningRate = 0.1; // Dramatically increased from 0.02 to 0.1\n        this.forgetRate = 0.001; // Decreased forget rate so relationships stay longer\n        \n        // Relationships between neurons\n        this.relationships = new Map(); // Map of sourceId -> Map of targetId -> relationship\n        \n        // Musical system\n        this.currentTonalCenter = null; // The detected key/scale\n        this.leadingNeurons = []; // Neurons with strongest influence\n        this.activeNeurons = new Set(); // Currently active neurons\n        \n        // Scales for harmonic relationships\n        this.scales = {\n            'major': [0, 2, 4, 5, 7, 9, 11],\n            'minor': [0, 2, 3, 5, 7, 8, 10],\n            'pentatonic': [0, 2, 4, 7, 9],\n            'blues': [0, 3, 5, 6, 7, 10]\n        };\n        \n        // Visualization\n        this.relationshipVisuals = new Map(); // Visual representations of strong relationships\n        this.visualizationEnabled = true;\n        this.createHelperMaterials();\n        \n        // Debugging and monitoring\n        this.isDebugMode = false;\n        this.historyLength = 50; // Number of updates to keep in history\n        this.updateHistory = [];\n        \n        // Frame count for rate limiting\n        this.frameCount = 0;\n    }\n    \n    /**\n     * Initialize materials for relationship visualization\n     */\n    createHelperMaterials() {\n        this.harmonicLineMaterial = new THREE.LineBasicMaterial({\n            color: 0x00ffff, // Cyan instead of green for maximum visibility\n            transparent: true,\n            opacity: 1.0, // Fully opaque\n            linewidth: 3, // Even thicker lines\n            depthTest: false, // Ensure lines are visible over other objects\n            fog: false // Disable fog for clearer lines\n        });\n    }\n    \n    /**\n     * Update all harmonic relationships based on current neuron positions\n     */\n    update() {\n        if (!window.circles || !this.soundManager) return;\n        \n        // Get only neurons that exist and have positions\n        const neurons = window.circles.filter(circle => \n            circle && circle.neuron && circle.position);\n        \n        // Check DC speed - slow down harmonic processing at very high speeds\n        const dcSpeed = window.settings?.dcSpeedMultiplier || 0;\n        const isHighSpeed = dcSpeed > 5;\n        \n        // At high DC speeds, process updates less frequently to prevent overwhelming the system\n        if (isHighSpeed && this.frameCount % 2 !== 0) {\n            this.frameCount = (this.frameCount + 1) % 10000;\n            return; // Skip this update cycle\n        }\n        \n        // Count the frame for rate limiting at high speeds\n        this.frameCount = (this.frameCount + 1) % 10000;\n        \n        // Detect currently active neurons\n        this.updateActiveNeurons(neurons);\n        \n        // If too many neurons are active at high speeds, limit processing\n        if (isHighSpeed && this.activeNeurons.size > 10) {\n            Logger.debug(`%c[HARMONIC SYSTEM] Limiting processing due to ${this.activeNeurons.size} active neurons at DC speed ${dcSpeed}`, \"color: #ffaa00;\");\n            \n            // Skip the more intensive computations, but still update relationships\n            this.updateRelationships(neurons);\n            return;\n        }\n        \n        // Detect the current tonal center based on active neurons\n        this.detectTonalCenter();\n        \n        // Update relationship strengths based on proximity\n        this.updateRelationships(neurons);\n        \n        // Update neuron pitches based on relationships\n        this.applyHarmonicInfluence(neurons);\n        \n        // Update visualizations\n        if (this.visualizationEnabled) {\n            this.updateVisualizations();\n        }\n        \n        // Update debug information\n        this.updateDebugInfo();\n    }\n    \n    /**\n     * Track which neurons are currently active\n     */\n    updateActiveNeurons(neurons) {\n        // Clear existing active neurons that are no longer firing\n        for (const id of this.activeNeurons) {\n            const neuron = neurons.find(n => n.neuron.id === id);\n            if (!neuron || !neuron.neuron.isFiring) {\n                this.activeNeurons.delete(id);\n            }\n        }\n        \n        // Add newly firing neurons\n        neurons.forEach(neuron => {\n            if (neuron.neuron.isFiring) {\n                this.activeNeurons.add(neuron.neuron.id);\n            }\n        });\n    }\n    \n    /**\n     * Detect the current tonal center based on active neurons\n     */\n    detectTonalCenter() {\n        if (this.activeNeurons.size === 0) return;\n        \n        // Count occurrences of each pitch class\n        const pitchClassCounts = new Array(12).fill(0);\n        \n        // Get the pitch classes of all active neurons\n        for (const neuronId of this.activeNeurons) {\n            const neuronFreq = this.getNeuronFrequency(neuronId);\n            if (neuronFreq) {\n                // Convert frequency to pitch class (0-11)\n                const pitchClass = this.frequencyToPitchClass(neuronFreq);\n                if (pitchClass !== null) {\n                    pitchClassCounts[pitchClass]++;\n                }\n            }\n        }\n        \n        // Find the most common pitch class\n        let maxCount = 0;\n        let dominantPitchClass = 0;\n        \n        pitchClassCounts.forEach((count, pitchClass) => {\n            if (count > maxCount) {\n                maxCount = count;\n                dominantPitchClass = pitchClass;\n            }\n        });\n        \n        // Determine which scale best fits the active notes\n        let bestScaleFit = 0;\n        let bestScale = 'major';\n        \n        for (const [scaleName, scalePattern] of Object.entries(this.scales)) {\n            let scaleMatchCount = 0;\n            \n            // For each active neuron, check if it fits in the scale\n            for (const neuronId of this.activeNeurons) {\n                const neuronFreq = this.getNeuronFrequency(neuronId);\n                if (neuronFreq) {\n                    const pitchClass = this.frequencyToPitchClass(neuronFreq);\n                    if (pitchClass !== null) {\n                        // Calculate relative pitch class to the dominant\n                        const relativePitchClass = (pitchClass - dominantPitchClass + 12) % 12;\n                        \n                        // Check if this pitch class is in the scale\n                        if (scalePattern.includes(relativePitchClass)) {\n                            scaleMatchCount++;\n                        }\n                    }\n                }\n            }\n            \n            // Calculate the fit as a percentage of active notes\n            const scaleFit = this.activeNeurons.size > 0 ? \n                scaleMatchCount / this.activeNeurons.size : 0;\n            \n            if (scaleFit > bestScaleFit) {\n                bestScaleFit = scaleFit;\n                bestScale = scaleName;\n            }\n        }\n        \n        // Update the tonal center\n        this.currentTonalCenter = {\n            root: dominantPitchClass,\n            scale: bestScale,\n            confidence: bestScaleFit\n        };\n        \n        // If there's high confidence, identify leading neurons\n        if (bestScaleFit > 0.5) {\n            this.identifyLeadingNeurons();\n        }\n        \n        // Debug output\n        if (this.isDebugMode) {\n            Logger.debug(`Detected tonal center: ${Tone.Frequency(dominantPitchClass, \"midi\").toNote()} ${bestScale} (confidence: ${bestScaleFit.toFixed(2)})`);\n        }\n    }\n    \n    /**\n     * Identify which neurons have the most influence on the current tonality\n     */\n    identifyLeadingNeurons() {\n        // Reset leading neurons\n        this.leadingNeurons = [];\n        \n        if (!this.currentTonalCenter || this.activeNeurons.size === 0) return;\n        \n        // Calculate influence score for each active neuron\n        const neuronInfluence = [];\n        \n        for (const neuronId of this.activeNeurons) {\n            // Base influence - being active gives some influence\n            let influence = 1.0;\n            \n            // Check if the neuron is in the detected scale\n            const neuronFreq = this.getNeuronFrequency(neuronId);\n            if (neuronFreq) {\n                const pitchClass = this.frequencyToPitchClass(neuronFreq);\n                \n                if (pitchClass !== null) {\n                    // Calculate relative pitch class to the tonal center\n                    const relativePitchClass = (pitchClass - this.currentTonalCenter.root + 12) % 12;\n                    \n                    // Neurons on the root note have more influence\n                    if (relativePitchClass === 0) {\n                        influence += 3.0; // Root note\n                    } \n                    // Neurons on perfect fifth or fourth have more influence\n                    else if (relativePitchClass === 7 || relativePitchClass === 5) {\n                        influence += 2.0; // Perfect fifth or fourth\n                    }\n                    // Neurons on third have some influence\n                    else if (relativePitchClass === 4 || relativePitchClass === 3) {\n                        influence += 1.5; // Major or minor third\n                    }\n                    \n                    // Check if the note is in the current scale\n                    const scalePattern = this.scales[this.currentTonalCenter.scale];\n                    if (scalePattern.includes(relativePitchClass)) {\n                        influence += 1.0; // Note is in scale\n                    }\n                }\n            }\n            \n            // Add DC input value to influence - neurons with more DC input are more influential\n            const neuron = this.getNeuronById(neuronId);\n            if (neuron && neuron.neuron) {\n                influence += neuron.neuron.dcInput * 2.0;\n            }\n            \n            // Add to influence list\n            neuronInfluence.push({ id: neuronId, score: influence });\n        }\n        \n        // Sort by influence score (highest first)\n        neuronInfluence.sort((a, b) => b.score - a.score);\n        \n        // Take top 3 or fewer as leading\n        this.leadingNeurons = neuronInfluence.slice(0, 3).map(n => n.id);\n        \n        if (this.isDebugMode) {\n            Logger.debug(\"Leading neurons:\", this.leadingNeurons);\n        }\n    }\n    \n    /**\n     * Update the strength of all relationships based on neuron proximities\n     */\n    updateRelationships(neurons) {\n        // For each pair of neurons, update their relationship\n        for (let i = 0; i < neurons.length; i++) {\n            const sourceNeuron = neurons[i];\n            const sourceId = sourceNeuron.neuron.id;\n            \n            // Ensure source neuron has a relationship map\n            if (!this.relationships.has(sourceId)) {\n                this.relationships.set(sourceId, new Map());\n            }\n            \n            // Get existing relationships for this source\n            const sourceRelationships = this.relationships.get(sourceId);\n            \n            for (let j = 0; j < neurons.length; j++) {\n                // Skip self-relationships\n                if (i === j) continue;\n                \n                const targetNeuron = neurons[j];\n                const targetId = targetNeuron.neuron.id;\n                \n                // Calculate distance between neurons\n                const distance = sourceNeuron.position.distanceTo(targetNeuron.position);\n                \n                // Get or create relationship\n                let relationship;\n                if (sourceRelationships.has(targetId)) {\n                    relationship = sourceRelationships.get(targetId);\n                } else {\n                    relationship = {\n                        sourceId,\n                        targetId,\n                        strength: 0,           // 0-1 scale of harmonic influence\n                        learningTime: 0,       // cumulative time in proximity\n                        lastUpdateTime: Date.now()\n                    };\n                    sourceRelationships.set(targetId, relationship);\n                }\n                \n                // Update the relationship\n                this.updateRelationshipStrength(relationship, distance);\n            }\n            \n            // Clean up relationships for neurons that are no longer close\n            // or where the relationship has weakened significantly\n            for (const [targetId, relationship] of sourceRelationships.entries()) {\n                // If relationship is very weak, remove it\n                if (relationship.strength < 0.02) {\n                    sourceRelationships.delete(targetId);\n                    \n                    // Also remove any visualizations\n                    this.removeRelationshipVisualization(sourceId, targetId);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Update the strength of a single relationship based on distance\n     */\n    updateRelationshipStrength(relationship, distance) {\n        const now = Date.now();\n        const deltaTime = (now - relationship.lastUpdateTime) / 1000; // in seconds\n        relationship.lastUpdateTime = now;\n        \n        // Influence range: 0 at maxDistance, 1 at minDistance or closer\n        const distanceInfluence = Math.max(0, Math.min(1, \n            (this.maxInfluenceDistance - distance) / \n            (this.maxInfluenceDistance - this.minInfluenceDistance)\n        ));\n        \n        if (distance <= this.maxInfluenceDistance) {\n            // Inside influence range - strengthen relationship\n            relationship.learningTime += deltaTime * distanceInfluence;\n            \n            // Learning curve: faster initial learning, then slower approach to maximum\n            const learningCurve = 1 - Math.exp(-relationship.learningTime / 10);\n            \n            // Update strength based on distance and learning time\n            relationship.strength = Math.min(1, \n                relationship.strength + \n                (this.learningRate * distanceInfluence * learningCurve * deltaTime * this.harmonyStrength)\n            );\n        } else {\n            // Outside influence range - weaken relationship\n            relationship.strength = Math.max(0, \n                relationship.strength - (this.forgetRate * deltaTime)\n            );\n            \n            // Also decrease learning time\n            relationship.learningTime = Math.max(0, \n                relationship.learningTime - (this.forgetRate * deltaTime * 5)\n            );\n        }\n    }\n    \n    /**\n     * Apply harmonic adjustments to neurons based on relationships\n     */\n    applyHarmonicInfluence(neurons) {\n        // Skip if harmony strength is zero or no tonal center is detected\n        if (this.harmonyStrength <= 0 || !this.currentTonalCenter) return;\n        \n        for (const targetNeuron of neurons) {\n            const targetId = targetNeuron.neuron.id;\n            \n            // Skip neurons marked as \"harmony anchors\" (if we implement that feature)\n            if (targetNeuron.neuron.isHarmonyAnchor) continue;\n            \n            // Gather all influences on this target neuron\n            let totalInfluence = 0;\n            let targetAdjustments = [];\n            \n            for (const sourceNeuron of neurons) {\n                const sourceId = sourceNeuron.neuron.id;\n                \n                // Skip self-influence\n                if (sourceId === targetId) continue;\n                \n                // Get the relationship if it exists\n                const relationship = this.getRelationship(sourceId, targetId);\n                if (!relationship || relationship.strength <= 0) continue;\n                \n                // Calculate the suggested pitch adjustment\n                const adjustment = this.calculatePitchAdjustment(sourceNeuron, targetNeuron, relationship);\n                if (adjustment) {\n                    // Weight by relationship strength\n                    adjustment.influence *= relationship.strength;\n                    totalInfluence += adjustment.influence;\n                    \n                    targetAdjustments.push(adjustment);\n                }\n            }\n            \n            // If there are valid adjustments, apply them\n            if (targetAdjustments.length > 0 && totalInfluence > 0) {\n                // Normalize influences\n                targetAdjustments.forEach(adj => {\n                    adj.influence /= totalInfluence;\n                });\n                \n                // Apply combined adjustment\n                this.applyPitchAdjustment(targetNeuron, targetAdjustments);\n            }\n        }\n    }\n    \n    /**\n     * Calculate how a source neuron should influence a target neuron's pitch\n     */\n    calculatePitchAdjustment(sourceNeuron, targetNeuron, relationship) {\n        // Get information about both neurons\n        const sourceFreq = this.getNeuronFrequency(sourceNeuron.neuron.id);\n        const targetFreq = this.getNeuronFrequency(targetNeuron.neuron.id);\n        \n        if (!sourceFreq || !targetFreq) return null;\n        \n        // Convert frequencies to pitch classes (0-11 representing C to B)\n        const sourcePitchClass = this.frequencyToPitchClass(sourceFreq);\n        const targetPitchClass = this.frequencyToPitchClass(targetFreq);\n        \n        if (sourcePitchClass === null || targetPitchClass === null) return null;\n        \n        // Get current scale\n        const currentScale = this.scales[this.currentTonalCenter.scale] || this.scales.major;\n        \n        // Find closest notes in the scale relative to the source note\n        const relativeSourcePitchClass = (sourcePitchClass - this.currentTonalCenter.root + 12) % 12;\n        const relativeTargetPitchClass = (targetPitchClass - this.currentTonalCenter.root + 12) % 12;\n        \n        // Check if target is already in scale relative to source\n        const isTargetInScale = currentScale.includes(relativeTargetPitchClass);\n        \n        // If already in scale and source is a leading neuron, strengthen that choice\n        if (isTargetInScale && this.leadingNeurons.includes(sourceNeuron.neuron.id)) {\n            return {\n                influence: 1.0,\n                targetPitchClass: targetPitchClass, // Keep the same\n                adjustment: 0\n            };\n        }\n        \n        // If not in scale, find the closest note in scale\n        if (!isTargetInScale) {\n            // Find the closest note in the scale\n            let closestScaleNote = null;\n            let smallestDistance = 12;\n            \n            for (const scaleDegree of currentScale) {\n                // Calculate the absolute pitch class in the current key\n                const absolutePitchClass = (this.currentTonalCenter.root + scaleDegree) % 12;\n                \n                // Calculate distance (considering circular nature of pitch classes)\n                const distance = Math.min(\n                    Math.abs(targetPitchClass - absolutePitchClass),\n                    12 - Math.abs(targetPitchClass - absolutePitchClass)\n                );\n                \n                if (distance < smallestDistance) {\n                    smallestDistance = distance;\n                    closestScaleNote = absolutePitchClass;\n                }\n            }\n            \n            // Calculate the adjustment\n            if (closestScaleNote !== null) {\n                // Ensure we choose the closest direction (+/- semitones)\n                let adjustment = closestScaleNote - targetPitchClass;\n                if (adjustment > 6) adjustment -= 12;\n                if (adjustment < -6) adjustment += 12;\n                \n                // Source's influence is stronger based on relationship and being a leading neuron\n                const leaderBonus = this.leadingNeurons.includes(sourceNeuron.neuron.id) ? 2.0 : 1.0;\n                const influenceScore = relationship.strength * leaderBonus;\n                \n                return {\n                    influence: influenceScore,\n                    targetPitchClass: closestScaleNote,\n                    adjustment\n                };\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Apply a calculated pitch adjustment to a neuron\n     */\n    applyPitchAdjustment(targetNeuron, adjustments) {\n        if (!targetNeuron || !targetNeuron.neuron || adjustments.length === 0) return;\n        \n        const targetId = targetNeuron.neuron.id;\n        const currentFreq = this.getNeuronFrequency(targetId);\n        \n        if (!currentFreq) return;\n        \n        // Calculate the weighted adjustment in semitones\n        let totalAdjustment = 0;\n        adjustments.forEach(adj => {\n            totalAdjustment += adj.adjustment * adj.influence;\n        });\n        \n        // Only apply if there's a significant adjustment\n        if (Math.abs(totalAdjustment) < 0.25) return;\n        \n        // Round to nearest semitone if adjustment is large enough\n        const roundedAdjustment = Math.abs(totalAdjustment) >= 0.5 ? \n            Math.sign(totalAdjustment) * Math.round(Math.abs(totalAdjustment)) : totalAdjustment;\n        \n        // Calculate new frequency using equal temperament formula: f = f0 * 2^(n/12)\n        const newFreq = currentFreq * Math.pow(2, roundedAdjustment / 12);\n        \n        // Apply the new frequency to the neuron\n        this.updateNeuronFrequency(targetId, newFreq);\n    }\n    \n    /**\n     * Update the visualizations for strong relationships\n     */\n    updateVisualizations() {\n        // Skip custom visualization since we're now using connection waveforms\n        // for visual feedback on harmonic relationships\n        return;\n        \n        // Original code commented out below\n        /*\n        // Create/update visualizations for strong relationships\n        for (const [sourceId, relationships] of this.relationships.entries()) {\n            for (const [targetId, relationship] of relationships.entries()) {\n                // Drastically lowered threshold to show relationships immediately\n                if (relationship.strength > 0.05) {\n                    this.createOrUpdateRelationshipVisualization(sourceId, targetId, relationship.strength);\n                } else {\n                    this.removeRelationshipVisualization(sourceId, targetId);\n                }\n            }\n        }\n        */\n    }\n    \n    /**\n     * Create or update a visualization for a relationship\n     */\n    createOrUpdateRelationshipVisualization(sourceId, targetId, strength) {\n        const sourceNeuron = this.getNeuronById(sourceId);\n        const targetNeuron = this.getNeuronById(targetId);\n        \n        if (!sourceNeuron || !targetNeuron || !this.scene) return;\n        \n        const relationshipKey = `${sourceId}_${targetId}`;\n        \n        // Update existing visualization or create a new one\n        if (this.relationshipVisuals.has(relationshipKey)) {\n            const visual = this.relationshipVisuals.get(relationshipKey);\n            \n            // Update line positions\n            const positions = visual.geometry.attributes.position.array;\n            \n            positions[0] = sourceNeuron.position.x;\n            positions[1] = sourceNeuron.position.y + 0.2; // Raised higher above neurons\n            positions[2] = sourceNeuron.position.z;\n            \n            positions[3] = targetNeuron.position.x;\n            positions[4] = targetNeuron.position.y + 0.2; // Raised higher above neurons\n            positions[5] = targetNeuron.position.z;\n            \n            visual.geometry.attributes.position.needsUpdate = true;\n            \n            // Make lines always highly visible regardless of relationship strength\n            visual.material.opacity = 0.8 + (strength * 0.2); // Minimum 0.8 opacity\n        } else {\n            // Create a new line\n            const lineGeometry = new THREE.BufferGeometry();\n            const positions = new Float32Array(6);\n            \n            positions[0] = sourceNeuron.position.x;\n            positions[1] = sourceNeuron.position.y + 0.2; // Raised higher above neurons\n            positions[2] = sourceNeuron.position.z;\n            \n            positions[3] = targetNeuron.position.x;\n            positions[4] = targetNeuron.position.y + 0.2; // Raised higher above neurons\n            positions[5] = targetNeuron.position.z;\n            \n            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n            \n            // Create line with custom material that's always highly visible\n            const material = this.harmonicLineMaterial.clone();\n            material.opacity = 0.8 + (strength * 0.2); // Minimum 0.8 opacity\n            \n            const line = new THREE.Line(lineGeometry, material);\n            line.renderOrder = 1000; // Extremely high render order to ensure visibility\n            \n            // Add to scene\n            this.scene.add(line);\n            \n            // Store reference\n            this.relationshipVisuals.set(relationshipKey, line);\n            \n            // Debug log to verify line creation\n            Logger.info(`Created harmonic relationship line between neurons ${sourceId} and ${targetId}`);\n        }\n    }\n    \n    /**\n     * Remove a relationship visualization if it exists\n     */\n    removeRelationshipVisualization(sourceId, targetId) {\n        const relationshipKey = `${sourceId}_${targetId}`;\n        \n        if (this.relationshipVisuals.has(relationshipKey)) {\n            const visual = this.relationshipVisuals.get(relationshipKey);\n            \n            // Remove from scene\n            if (visual && visual.parent) {\n                visual.parent.remove(visual);\n            }\n            \n            // Dispose of resources\n            if (visual) {\n                if (visual.geometry) visual.geometry.dispose();\n                if (visual.material) visual.material.dispose();\n            }\n            \n            // Remove from map\n            this.relationshipVisuals.delete(relationshipKey);\n        }\n    }\n    \n    /**\n     * Helper method to get a neuron object by ID\n     */\n    getNeuronById(neuronId) {\n        if (!window.circles) return null;\n        \n        return window.circles.find(circle => \n            circle && circle.neuron && circle.neuron.id === neuronId);\n    }\n    \n    /**\n     * Get the frequency of a neuron from the sound manager\n     */\n    getNeuronFrequency(neuronId) {\n        if (!this.soundManager || !this.soundManager.neuronFrequencies) return null;\n        \n        const freqData = this.soundManager.neuronFrequencies.get(neuronId);\n        if (!freqData) return null;\n        \n        // Use custom frequency if set, otherwise use base frequency\n        return freqData.customFreq || freqData.baseFreq;\n    }\n    \n    /**\n     * Get an existing relationship or null if none exists\n     */\n    getRelationship(sourceId, targetId) {\n        if (!this.relationships.has(sourceId)) return null;\n        \n        return this.relationships.get(sourceId).get(targetId) || null;\n    }\n    \n    /**\n     * Convert a frequency to a pitch class (0-11 representing C to B)\n     */\n    frequencyToPitchClass(frequency) {\n        if (!frequency || frequency <= 0) return null;\n        \n        // Calculate MIDI note number: 69 + 12 * log2(f / 440)\n        const midiNote = Math.round(69 + 12 * Math.log2(frequency / 440));\n        \n        // Extract pitch class (0-11, where 0 is C, 1 is C#, etc.)\n        return midiNote % 12;\n    }\n    \n    /**\n     * Update a neuron's frequency through the sound manager\n     */\n    updateNeuronFrequency(neuronId, newFrequency) {\n        if (!this.soundManager || !this.soundManager.neuronFrequencies) return;\n        \n        const freqData = this.soundManager.neuronFrequencies.get(neuronId);\n        if (!freqData) return;\n        \n        // Only update if the change is significant enough\n        const currentFreq = freqData.customFreq || freqData.baseFreq;\n        const percentChange = Math.abs((newFrequency - currentFreq) / currentFreq);\n        \n        if (percentChange < 0.001) return; // Skip tiny changes\n        \n        // Update the custom frequency\n        freqData.customFreq = newFrequency;\n        \n        // Also update the sound manager's internal state if this is the selected neuron\n        if (this.soundManager.selectedNeuronId === neuronId) {\n            this.soundManager.updateSelectedSynthParam('note', newFrequency);\n        }\n        \n        // Add visual feedback when a note changes\n        const neuronCircle = this.getNeuronById(neuronId);\n        if (neuronCircle) {\n            // Flash the neuron briefly\n            const originalColor = neuronCircle.material.color.clone();\n            const originalScale = neuronCircle.scale.clone();\n            \n            // Flash to bright cyan to indicate harmonic adjustment\n            neuronCircle.material.color.set(0x00ffff);\n            neuronCircle.scale.multiplyScalar(1.5);\n            \n            // Return to original appearance after a moment\n            setTimeout(() => {\n                if (neuronCircle && neuronCircle.material) {\n                    neuronCircle.material.color.copy(originalColor);\n                    neuronCircle.scale.copy(originalScale);\n                }\n            }, 300);\n        }\n        \n        // Debug output\n        if (this.isDebugMode) {\n            const noteName = this.soundManager.getNoteNameFromFrequency \n                ? this.soundManager.getNoteNameFromFrequency(newFrequency) \n                : Tone.Frequency(newFrequency).toNote();\n                \n            Logger.debug(`Adjusted neuron ${neuronId} to frequency ${newFrequency.toFixed(2)}Hz (${noteName})`);\n        }\n    }\n    \n    /**\n     * Set the global harmonic influence strength\n     */\n    setHarmonyStrength(value) {\n        this.harmonyStrength = Math.max(0, Math.min(1, value));\n        \n        // Update visualizations when harmony strength changes\n        if (this.visualizationEnabled) {\n            // If harmony strength is 0, remove all visualizations\n            if (this.harmonyStrength <= 0) {\n                this.clearAllVisualizations();\n            } else {\n                this.updateVisualizations();\n            }\n        }\n    }\n    \n    /**\n     * Get current harmonic system status\n     */\n    getStatus() {\n        return {\n            activeNeurons: Array.from(this.activeNeurons),\n            leadingNeurons: this.leadingNeurons,\n            tonalCenter: this.currentTonalCenter,\n            relationships: {\n                total: Array.from(this.relationships.keys()).reduce((total, sourceId) => {\n                    return total + this.relationships.get(sourceId).size;\n                }, 0),\n                strong: Array.from(this.relationships.keys()).reduce((total, sourceId) => {\n                    const sourceRels = this.relationships.get(sourceId);\n                    return total + Array.from(sourceRels.values())\n                        .filter(rel => rel.strength > 0.5).length;\n                }, 0)\n            },\n            harmonyStrength: this.harmonyStrength\n        };\n    }\n    \n    /**\n     * Enable or disable debug mode\n     */\n    setDebugMode(enabled) {\n        this.isDebugMode = enabled;\n    }\n    \n    /**\n     * Toggle visualization of harmonic relationships\n     */\n    toggleVisualization(enabled) {\n        this.visualizationEnabled = enabled;\n        \n        // If disabled, clear all visualizations\n        if (!enabled) {\n            this.clearAllVisualizations();\n        }\n    }\n    \n    /**\n     * Remove all relationship visualizations\n     */\n    clearAllVisualizations() {\n        for (const [relationshipKey, visual] of this.relationshipVisuals.entries()) {\n            // Remove from scene\n            if (visual && visual.parent) {\n                visual.parent.remove(visual);\n            }\n            \n            // Dispose of resources\n            if (visual) {\n                if (visual.geometry) visual.geometry.dispose();\n                if (visual.material) visual.material.dispose();\n            }\n        }\n        \n        // Clear the map\n        this.relationshipVisuals.clear();\n    }\n    \n    /**\n     * Update debug information\n     */\n    updateDebugInfo() {\n        if (!this.isDebugMode) return;\n        \n        // Add current update to history\n        this.updateHistory.push({\n            time: Date.now(),\n            activeNeurons: this.activeNeurons.size,\n            tonalCenter: this.currentTonalCenter ? \n                `${Tone.Frequency(this.currentTonalCenter.root, \"midi\").toNote()} ${this.currentTonalCenter.scale}` : \n                'None',\n            leadingNeurons: this.leadingNeurons.length,\n            relationships: Array.from(this.relationships.keys()).reduce((total, sourceId) => {\n                return total + this.relationships.get(sourceId).size;\n            }, 0)\n        });\n        \n        // Trim history if too long\n        if (this.updateHistory.length > this.historyLength) {\n            this.updateHistory = this.updateHistory.slice(-this.historyLength);\n        }\n    }\n    \n    /**\n     * Clean up resources when system is no longer needed\n     */\n    cleanup() {\n        // Clear all visualizations\n        this.clearAllVisualizations();\n        \n        // Clear maps\n        this.relationships.clear();\n        this.relationshipVisuals.clear();\n        this.activeNeurons.clear();\n        this.leadingNeurons = [];\n        \n        // Dispose of materials\n        if (this.harmonicLineMaterial) {\n            this.harmonicLineMaterial.dispose();\n        }\n    }\n    \n    /**\n     * Check if a harmonic relationship exists between two neurons\n     * This can be called from other classes like ConnectionManager\n     * @param {number} sourceId - The source neuron's ID\n     * @param {number} targetId - The target neuron's ID\n     * @returns {Object|null} - The relationship object or null if none exists\n     */\n    getHarmonicRelationship(sourceId, targetId) {\n        // Check relationships in both directions with very low threshold for visual feedback\n        const directRelationship = this.getRelationship(sourceId, targetId);\n        if (directRelationship && directRelationship.strength > 0.01) { // Lowered threshold from 0.05\n            return directRelationship;\n        }\n        \n        // Also check the reverse direction\n        const reverseRelationship = this.getRelationship(targetId, sourceId);\n        if (reverseRelationship && reverseRelationship.strength > 0.01) { // Lowered threshold from 0.05\n            return reverseRelationship;\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Check if a harmonic relationship should exist between neurons at the given distance\n     * Used to show relationships based on proximity even before they've been established\n     * @param {number} distance - Distance between neurons\n     * @returns {boolean} - Whether these neurons are in harmonic proximity\n     */\n    isInHarmonicProximity(distance) {\n        // Use a slightly more aggressive distance threshold for visual feedback\n        return distance <= (this.maxInfluenceDistance * 1.1); // 10% buffer for better visualization\n    }\n} "],"names":["resourceManager","constructor","this","resources","geometries","Map","materials","textures","objects","meshes","shaders","renderers","pools","ownership","registerResource","type","resource","ownerId","resourceId","id","Date","now","Math","random","toString","substr","set","has","get","Set","add","getResource","disposeResource","addToPool","key","color","getHex","_resetResourceForPooling","push","_disposeByType","delete","typeMap","entries","resourceSet","size","getPooledResource","createFn","length","pop","cleanupOwner","forEach","resourceIds","createGeometry","geometryType","params","usePooling","THREE.BoxGeometry","THREE.SphereGeometry","THREE.PlaneGeometry","THREE.CircleGeometry","THREE.CylinderGeometry","THREE.BufferGeometry","geometry","createMaterial","materialType","undefined","THREE.Color","poolKey","THREE.MeshBasicMaterial","THREE.MeshStandardMaterial","THREE.MeshPhongMaterial","THREE.MeshLambertMaterial","THREE.LineBasicMaterial","material","dispose","prop","value","isTexture","parent","remove","Array","isArray","opacity","transparent","depthTest","needsUpdate","position","rotation","scale","visible","cleanup","Object","keys","from","clear","timerManager","timeouts","intervals","animationFrames","debounceTimers","throttleData","groupOwnership","setTimeout","groupId","callback","delay","timerId","timeoutId","clearTimeout","_trackOwnership","setInterval","intervalId","clearInterval","requestAnimationFrame","rafCallback","timestamp","rafId","cancelAnimationFrame","debounce","functionId","_clearDebounceTimer","throttle","limit","throttleInfo","lastExecution","clearGroup","frameId","registerComponent","componentId","component","_","eventManager","listeners","delegatedListeners","componentListeners","_handleDelegatedEvent","bind","addEventListener","target","eventType","handler","options","boundHandler","listenerRef","originalHandler","removeEventListener","index","indexOf","splice","addThrottledEventListener","handlerId","substring","event","call","addDebouncedEventListener","eventData","currentTarget","clientX","clientY","delegate","container","selector","document","delegationId","delegation","matches","contains","undelegate","delegationRef","cleanupComponent","delegations","toRemove","ref","stateManager","state","components","setState","getState","subscribe","filter","cb","name","getComponent","callComponentMethod","componentName","methodName","args","dispatchEvent","eventName","data","on","reactiveManager","observers","activeTimers","mutationObservers","resizeObservers","canvasNeedsUpdate","animationFrameRequested","requestRender","markCanvasForUpdate","initialize","startRenderLoop","setupResponsiveObservers","setupDomObservers","bodyResizeObserver","ResizeObserver","isMobile","window","innerWidth","uiManager","updateSynthPanelMobileView","observe","body","observeResize","element","Element","disconnect","observer","error","console","gridContainer","getElementById","gridObserver","MutationObserver","mutations","childList","subtree","attributes","grid","presetContainer","querySelector","presetObserver","presets","renderFunction","waveformCanvas","renderEnvelope","boundRenderFunction","soundManager","values","timer","neuronGridManager","wrapper","elementPool","activeElements","initialized","handleElementClick","updateNeuronGrid","update","parentElement","className","createElement","appendChild","ensureAnimationStyleExists","neurons","circles","pane","currentNeuronIds","circle","neuron","neuronId","dataset","updateElementAppearance","parentNode","removeChild","style","title","isFiring","classList","presetName","presetColor","r","floor","g","b","setProperty","backgroundColor","currentCharge","round","dcInput","toFixed","chargeValue","green","min","find","inputManager","selectNeuron","Logger","message","initializeManagers","cleanupAllManagers","URLSearchParams","location","search","TimerManager","rafCallbacks","intervalCallbacks","timeoutCallbacks","isRunning","lastFrameTime","frameDelta","frameCount","frameRates","averageFrameRate","frameRateHistory","lastPerformanceReport","performanceReportInterval","start","performance","stop","shift","reduce","sum","rate","callbackId","targetId","group","info","startsWith","fn","throttleKey","wait","debounceKey","getPerformanceMetrics","frameRate","activeTasks","raf","interval","timeout","ensureManagersInitialized","neuronEngine","connections","updateInterval","updateTimerId","lastUpdateTime","deltaTime","startTime","fps","isPaused","onEffectNeeded","onSoundNeeded","onUpdate","THRESHOLD","_update","pause","resume","elapsed","_updateNeurons","_processFiringNeurons","dt","chargeIncrement","shouldFire","_updateNeuronState","firingNeurons","_fireNeuron","lastFiredTime","_propagateSignals","debug","outgoingConnections","targetNeuron","warn","weight","synapticWeights","speed","synapticSpeeds","_createVisualParticle","_deliverSignal","sourceNeuron","max","pow","sourceId","c","workerManager","createParticle","Neuron","createAndAnimateSignalParticle","previousCharge","scaledWeight","createNeuron","mesh","x","y","z","baseScale","maxScale","originalColor","firingColor","isHarmonyAnchor","currentEnvelope","attack","sustain","release","removeNeuron","removeConnection","includes","createConnection","connectionKey","updateConnectionWeight","connection","updateConnectionSpeed","setDCInput","resetCharge","addCharge","amount","getNeuron","getAllNeurons","fireNeuron","resetNeuron","resetAllNeurons","getDCNeurons","NeuronAdapter","scene","chargeColorInterpolation","showScaleChanges","neuronMeshes","connectionLines","effectsManager","handleEffects","handleSounds","properties","updateNeuronVisuals","success","updateConnectionVisuals","line","getNeuronMesh","createFiringEffect","createSignalEffect","sourcesCount","avgWeight","avgSpeed","totalWeight","totalSpeed","playNeuronFiring","copy","multiplyScalar","dcScale","chargeRatio","targetScale","setScalar","setHex","baseColor","brighterColor","lerp","chargingColor","registerExistingNeurons","neuronAdapter","targetIndex","targetCircle","dcNeurons","neuralEngine","updateAllDCNeurons","applyCompatibilityPatches","OriginalNeuron","originalNeuron","createNeuronShim","patchMeshForNeuron","_neuronPatched","defineProperty","isNeuronShim","enumerable","configurable","originalCreateNeuron","children","child","THREE.Mesh","patchMeshNeuronProperty","fire","addConnection","reset","updateVisualState","setExternalAnimation","duration","isInRefractoryPeriod","initializeCentralizedNeuralSystem","engine","adapter","initializeCentralizedSystem","applyPatches","preventDefault","setupEventListeners","isEnabled","fixNeuralSystem","static","THREE.Vector3","particleGeometry","computeBoundingSphere","allParticles","pendingChargeDeliveries","lastParticleCleanupTime","cleanupOrphanedParticles","log","windowHasFocus","isAppActive","dcValue","dcInterval","dcParameters","usingRAF","Tone","context","restoreAllNeuronSounds","suspend","silenceAllNeurons","hidden","startPeriodicChecker","isScrolling","scrollTimeout","neuronCount","threshold","chargeRate","chargingInterval","refractionPeriod","scaleState","base","current","animation","animating","lastUpdate","currentAnimation","particleAnimations","externalAnimationActive","externalAnimationEndTime","inRefractoryPeriod","refractoryEndTime","lastFiringAttempt","minTimeBetweenFirings","lastColorUpdate","colorUpdateNeeded","currentTime","forceReset","chargePerInterval","intervalTime","chargeScale","cappedScale","previousTarget","newTarget","initialUpdate","timeSinceLastAttempt","connectionCount","totalDistance","dx","dz","sqrt","avgDistance","animateFiring","connectionId","particleSystem","sourcePos","targetPos","setHSL","particle","targetPosition","clone","sourcePosition","progress","sourceNeuronId","targetNeuronId","creationTime","distanceTo","preserveContinuity","previousDC","needsTimerRecreation","chargePerFrame","updateCharge","activeDCNeurons","CustomEvent","detail","charge","inRefractory","kill","timeSinceFiring","getNeuronState","isRefractory","weights","speeds","initialWeight","initialSpeed","hadDCInput","currentDCValue","cleanupConnectionParticles","touchArea","harmonyAnchorIndicator","selectedNeuronId","neuronFrequencies","neuronSoundOverrides","pendingRestorations","neuronBusAssignments","voicePriorities","silenceNeuron","createParticleExplosion","numParticles","count","particleSize","particleSpeed","particleColor","particleMaterial","i","angle","PI","radius","cos","sin","animDuration","distanceFactor","gsap","to","ease","onComplete","activeNeuronIds","INPUT_CONFIG","dragThreshold","doubleClickDelay","canvasDragSpeed","flashDuration","momentumMultiplier","momentumDuration","updateNeuronLabel","neuronLabelElement","display","innerHTML","NeuronEffect","poolSize","createEffect","getEffect","releaseEffect","effect","neuronMesh","ConnectionEffect","getParticle","releaseParticle","createSignalParticle","EffectsManager","createNeuronFiringEffect","FluidBackgroundEffect","camera","clock","THREE.Clock","colors","dark","light","shaderMaterial","THREE.ShaderMaterial","uniforms","time","resolution","THREE.Vector2","innerHeight","neuronPositions","Float32Array","neuronStrengths","colorDark","colorLight","vertexShader","fragmentShader","depthWrite","planeGeometry","plane","bgScene","THREE.Scene","bgCamera","THREE.OrthographicCamera","handleResize","existingFallback","updateNeurons","positions","strengths","pos","project","strength","render","renderer","getElapsedTime","_renderCount","originalAutoClear","autoClear","OptimizedParticleSystem","maxParticles","activeParticles","particlePool","neuronConnections","side","THREE.DoubleSide","actualSpeed","getObjectByProperty","lookAt","userData","uuid","removeOldestParticle","removeParticle","oldestTime","Infinity","oldestIndex","cappedDelta","particlesToRemove","t","arcHeight","arc","meshIds","meshId","m","clearAllParticles","activeIds","soundPresets","decay","pitchDecay","detune","oscillatorType","filterType","filterFrequency","filterQ","reverbSend","delaySend","volumeScaling","neuronVolume","useSustainedTone","vibratoFreq","vibratoDepth","tremoloFreq","tremoloDepth","note","eventSystem","handlers","originalHandlers","handleGlobalEvent","intercept","beforeFn","afterFn","originalMethod","result","shouldCallOriginal","modifiedArgs","beforeResult","apply","afterResult","restoreOriginal","appInitializer","initializeStateManager","initializeResourceManager","initializeTimerManager","initializeEventManager","initializeReactiveManager","initializeEventSystem","setupEventRelay","setupReactiveUI","exposeManagersGlobally","settings","randomSoundsTimerId","sceneManager","frustumSize","lastTime","isAnimating","animationFrameId","initScene","initCamera","initRenderer","initFluidBackground","setupLighting","initParticleSystem","initEffectsSystem","initCentralizedNeuralSystem","background","matrixAutoUpdate","aspect","updateMatrix","updateMatrixWorld","THREE.WebGLRenderer","antialias","powerPreference","precision","logarithmicDepthBuffer","setSize","setPixelRatio","sortObjects","setClearColor","domElement","ambientLight","THREE.AmbientLight","directionalLight","THREE.DirectionalLight","left","right","top","bottom","updateProjectionMatrix","startAnimation","animateCallback","_animate","animationId","stopAnimation","clampedDeltaTime","elapsedTime","updateFPSCounter","fluidBackground","addToScene","object","removeFromScene","getScene","getCamera","getRenderer","cleanupLegacyParticles","neuralSystem","hasExistingNeurons","existingIds","map","join","system","migratedNeurons","enableCentralizedNeuralSystem","removeAllForComponent","disposeSceneObjects","disposeMaterial","lightMap","bumpMap","normalMap","specularMap","envMap","Pane","expanded","neuronHoverLabel","startButtonContainer","backgroundWaveformCanvas","tutorialActive","tutorialStep","tutorialOverlay","setupStyles","createUIElements","networkStarted","positionNeuronLabel","masterLimiter","Tone.Limiter","setupBackgroundWaveform","fontLink","rel","href","head","fontAwesomeLink","textContent","createStartButton","createNeuronLabel","createNeuronHoverLabel","startButton","async","Tone.start","setupInitialNetwork","setupNeuronLabelEvents","pointerEvents","padding","borderRadius","zIndex","fontFamily","fontSize","textShadow","hoverLabelTimer","updateNeuronHoverLabel","currentHoveredNeuron","chargePercent","getPresetName","colorStyle","noteInfo","getNeuronSynthParams","noteFreq","noteObj","musicalNotes","abs","freq","navigator","maxTouchPoints","tweakpaneRect","getBoundingClientRect","vector","screenX","screenY","labelX","labelY","tempDiv","visibility","width","labelWidth","offsetWidth","labelHeight","offsetHeight","offsetX","offsetY","LABEL_OFFSET_X","isDragging","draggedNeuron","selectedSynthFolder","panel","isVisible","e","padStart","screenWidth","transform","tweakpanePanel","panelRect","updateNeuronLabelPosition","enforcePanelWidth","querySelectorAll","minWidth","tab","hasWidthObserver","page","toggleSynthPanelMobile","hideSynthPanelOnMobile","synthPanel","backdrop","initTweakpane","backgroundWaveformAnimationFrame","existingBackground","startTutorial","showTutorialStep","step","clearTutorialUI","tutorialSteps","content","nextLabel","skipLabel","highlight","endTutorial","currentStep","overlay","maxWidth","textAlign","header","marginBottom","buttonsContainer","justifyContent","gap","nextButton","nextTutorialStep","addHighlight","highlightInfo","height","border","boxShadow","rect","showNotification","notification","circleGeometry","touchGeometry","neuronMaterial","THREE.FrontSide","touchMaterial","selectedNeuron","selectedConnection","selectedWeight","selectedSpeed","volume","volumeNormalization","selectedPitchDecay","selectedDetune","selectedNeuronVolume","selectedAttack","selectedDecay","selectedSustain","selectedRelease","selectedNote","selectedNoteIndex","selectedOscillatorType","selectedAttackCurve","selectedUseSustainedTone","harmonyStrength","harmonyDebug","selectedFilterType","selectedFilterFrequency","selectedFilterQ","selectedReverbSend","selectedDelaySend","selectedTremoloFreq","selectedTremoloDepth","selectedVibratoFreq","selectedVibratoDepth","previewSounds","spatialAudioEnabled","addNeuron","createNewNeuron","masterCompressor","ratio","knee","updateNeuronGridDisplay","firstChild","gridWrapper","flexWrap","neuronElement","CELL_SIZE","cursor","margin","boxSizing","transition","slider","stopPropagation","control","paneElement","lineHeight","currentLeft","parseInt","currentTop","originalX","originalY","globalControls","addFolder","updateSynthFolderDisplay","placeholderMsg","noteSelectionContainer","marginLeft","marginRight","flexDirection","alignSelf","noteButtonsContainer","gridTemplateRows","gridTemplateColumns","overflow","activeNoteButton","createNoteButton","button","noteIndex","frequency","octave","match","bgColor","borderColorTop","borderColorBottom","borderTop","borderLeft","borderBottom","borderRight","original","originalBorderTop","originalBorderBottom","updateSelectedSynthParam","fontWeight","getDarkerButtonColor","hex","replace","darkColor","veryDarkColor","scanlines","backgroundImage","click","brightenColor","slice","brighterBg","notesPerRow","ceil","rowNotes","rowIndex","updateActiveNoteButton","buttons","buttonFreq","parseFloat","insertBefore","containerParent","alignItems","marginTop","nextSibling","presetButtonGrid","activePresetButton","soundTabs","addTab","pages","soundControlsTabs","addBinding","label","ev","getOscillatorTypes","oscillatorTypes","acc","forceRenderEnvelope","getEnvelopeCurves","curveOptions","curve","indicatorGeometry","THREE.RingGeometry","indicatorMaterial","indicator","getFilterTypes","filterTypes","setPreviewSounds","setSpatialAudio","defaultPresets","createPresetButton","preset","textTransform","letterSpacing","borderColor","textColor","glowColor","getLighterColor","getDarkerColor","styleSheet","originalBorderLeft","originalBorderRight","originalText","glow","applyPreset","activeStyleSheet","lightenColor","hoveredBgColor","deactivatePresetOnChange","activePreset","visualizerContainer","waveformContainer","CanvasRenderingContext2D","prototype","roundRect","radii","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","drawEnvelopePath","ctx","totalTime","attackX","decayX","releaseX","sustainY","fillStyle","fillRect","strokeStyle","lineWidth","gridY","stroke","gridX","fill","font","fillText","canvas","getContext","clearRect","drawVisualizations","visualizationAnimationFrame","getComputedStyle","waveformAnalyzer","waveform","getValue","hasSignal","sliceWidth","startVisualizations","stopVisualizations","setupSpectrumAnalyzer","Tone.Analyser","Tone.Destination","connect","setupAudioVisualizer","playTestTone","Tone.context","originalPreviewSetting","InputManager","toggleSynthPanel","originalToggleSynthPanel","show","refresh","selectedCircle","isDesktop","grandchild","fontStyle","displayValue","setVolumeNormalization","updateSynthControls","highlightPresetButton","allButtons","foundButton","darkerColor","keyframes","glowColorBright","unhighlightActivePreset","applyAndRememberPreset","lastSelectedPreset","JSON","parse","stringify","isColor","adjustVolumeForInstrumentType","toLowerCase","targetColor","setRGB","renderOrder","createDirectExplosion","soundParams","envelope","oscillator","Q","effects","modulation","refreshSoundControls","existingGridContainer","connectionManager","logSoundManagerInfo","arrowPositionCache","lastSourcePositions","lastTargetPositions","lastSourceDC","lastTargetDC","lastConnectionSpeed","lastConnectionWeight","raycaster","THREE.Raycaster","Line","mouse","isDraggingArrow","isDraggingNeuron","selectedArrow","isDraggingBeforeStart","lastTapTime","doubleTapDelay","lastTapPosition","tapDistanceThreshold","longPressTimeout","longPressDelay","isLongPressing","longPressStartPosition","longPressThreshold","updateThreshold","arrowsCache","lastConnectionCount","cachedRect","lastRectUpdate","rectUpdateInterval","waveformResolution","waveformHeight","waveformThickness","defaultWaveform","generateDefaultWaveform","activeOpacity","inactiveOpacity","fadeDuration","setupGeometry","validationInterval","validateConnections","lastDoubleClickTime","isCreatingNeuron","scrollingConnections","points","getWaveformForNeuron","fullWaveform","getDirectWaveform","oscillators","arrowShape","THREE.Shape","arrowGeometry","THREE.ExtrudeGeometry","steps","depth","bevelEnabled","computeBoundingBox","arrowMaterial","handlePointerDown","handlePointerMove","handlePointerUp","handleWheel","handleRightClick","passive","hideWeightLabel","touchAction","updateMousePosition","touches","touch","checkProximityConnection","otherNeuron","distance","sourceToTargetConnection","targetToSourceConnection","targetToSourceGroup","source","triggerVisualFeedback","timeline","sourceIndex","disposeConnection","connectionGroup","updateConnection","playSmallSound","originalScale","updateConnectionProperties","arrow","lerpVectors","conn","weightLabel","showWeightLabel","shouldUpdateArrow","lastSourcePos","lastTargetPos","sourceDC","targetDC","lastWeight","lastSpeed","updateArrowsCache","Boolean","getWorldPosition","clientWidth","clientHeight","isTouch","handleLongPress","pointer","getTime","tapDistance","setFromCamera","originalThreshold","arrows","intersects","intersectObjects","mouseX","mouseZ","sourceScreen","targetScreen","dragResult","calculateDragPosition","worldPos","direction","subVectors","normalize","percentage","normalizedSpeed","selectConnection","delta","deltaY","currentWeight","newWeight","handleDoubleClick","THREE.Plane","intersectionPoint","ray","intersectPlane","mouseY","screenVector","mouseVector","screenVectorLength","rawPercentage","MIN_VISUAL","MAX_VISUAL","updateAllConnections","timeDelta","problematicConnection","problematicConnectionGroup","updateConnectionWaveform","waveformLine","isActive","neuronDistance","nearColor","farColor","normDist","lerpColors","lastActiveTime","timeSinceActive","fadeFactor","isInstantConnection","directWaveform","stepSize","scaleFactor","phase","baseAmplitude","animatedPhase","waveValue","bump","dirX","dirZ","perpX","perpZ","path","displacement","newTubeGeometry","THREE.TubeGeometry","array","minOpacity","targetOpacity","minPosition","maxPosition","baseOpacity","isHarmonic","harmonicSystem","isInHarmonicProximity","relationship","getHarmonicRelationship","harmonyColor","normalColor","restrictedPosition","tempPos","atan2","randomSpeed","THREE.Group","THREE.Line","setAttribute","THREE.Float32BufferAttribute","waveformPoints","waveformPath","THREE.CatmullRomCurve3","tubeGeometry","isConnectionArrow","raycast","sourceExists","ensureNeuronExists","targetExists","finalOpacity","flashNeuronGreen","killTweensOf","removedCount","particles","manuallyRemoved","deselectConnection","originalLineThreshold","waveformLines","connectionToDelete","connectionGroupToDelete","clickedObject","flashFeedback","firstKey","osc","sample","setWaveformThickness","thickness","forceUpdateConnectionsForNeuron","updatedConnections","debugNeuronFiring","firingCount","activeConnections","baseProps","isRightClickDragging","dragPlane","dragOffset","lastPosition","velocity","lastMousePosition","canvasDragVelocity","maxDragDistance","initialTouchPosition","touchTargetNeuron","touchSelectionConfirmed","neuronSelectionThreshold","lastTouchDistance","isMultiTouch","debugTouchAreas","ui","synthFolder","neuronLabel","refreshFunctions","initializeUI","mobileControls","createMobileControls","lastClickTime","lastClickPosition","clickDistanceThreshold","vector3Pool","onMouseDownBound","onMouseDown","onMouseMoveBound","onMouseMove","onMouseUpBound","onMouseUp","onMouseLeaveBound","onMouseLeave","onTouchStartBound","onTouchStart","onTouchMoveBound","onTouchMove","onTouchEndBound","onTouchEnd","onWheelBound","onWheel","onDoubleClickBound","onDoubleClick","handleRightClickBound","lastAudioTime","weightContainer","createSliderContainer","speedContainer","labelElement","labelText","webkitAppearance","appearance","outline","updateTouchPosition","touchX","touchY","getTouchDistance","dy","getIntersectionPoint","newSpeed","midpoint","Mesh","selectedObject","isHitArea","parentCircle","touchWorldPosition","tapPosition","timeDiff","isClickingOnArrow","deselectNeuron","sub","currentDistance","currentDC","newDC","touchScale","lastMidpoint","newPosition","getVector3","wasDraggingNeuron","tween","getTweenById","hoverLabel","touchStartTime","isDragOperation","startPosition","flatMap","obj","deltaX","scaleX","scaleY","worldDelta","hoverObject","connectionExists","otherOriginalColor","wasJustAClick","lastDCChangeTime","getNeuronSoundParameters","previewDebounceTimeout","handleOutsideClick","findOutgoingConnections","showTouchDebug","oldDebug","debugEl","toggleTouchAreaVisibility","releaseVector3","v","newState","soundControls","getUIElement","parts","split","part","particleIntersects","deleteSignalParticle","touchAreas","neuronToDelete","deleteNeuron","createRedParticleExplosion","hasEmissive","emissive","originalEmissive","onStart","circleMaterial","neuronColor","assignFrequencyRange","paramToUse","lastSelectedNeuronParams","randomPresetIndex","randomPreset","attackCurve","decayCurve","releaseCurve","ensureAudioContext","baseFrequency","spatialAudioPanners","spatialAudioNodes","activeVoices","maxVoices","voiceTimeout","lastPlayTime","minTimeBetweenNotes","neuronLastPlayTime","lastPlayedNotes","recentSoundTypes","bass","lastPlayed","isPlaying","hihat","stats","totalOscillators","activeOscillators","oscillatorsCreated","oscillatorsDisposed","lastStatsTime","peakOscillatorCount","playPreviewSounds","melodicPattern","currentPatternIndex","lastFreqIndex","melodyDirection","frequencyRanges","low","mid","high","veryHigh","ultra","initializeAudioBuses","envelopeCurves","oscillatorBank","pendingOscillators","_cleanupScheduled","initializeOscillatorBank","commonTypes","commonFrequencies","Tone.Frequency","toFrequency","_createOscillator","cleanupUnusedOscillators","_getOrCreateOscillator","oscData","lastUsed","Tone.Noise","Tone.Oscillator","gain","Tone.Gain","activeNeurons","cleanupCount","total","freqMap","createSimplePanner","pan","splitter","Tone.Split","merger","Tone.Merge","leftGain","rightGain","leftDelay","Tone.Delay","rightDelay","input","output","allNodes","updatePanPosition","panValue","maxDelay","delayTime","updatePosition","newPan","node","calculateSpatialPosition","neuronPos","cameraPos","relativeX","normalizedPan","enabled","buses","bus","spatialPanner","originalDestination","finalMixer","updateNeuronSpatialPosition","panner","busId","logPerformanceStats","originalApproach","currentCount","savedOscillators","savingsPercent","startPerformanceMonitoring","intervalMs","_perfMonitoringInterval","getOscillatorStats","getClosestFrequency","targetFreq","semitone","log2","then","Tone.Transport","catch","toDestination","Tone.Compressor","hiHatFilter","Tone.Filter","rolloff","hiHatCompressor","hiHatSplitter","hiHatWet","hiHatDry","isHiHatSound","createAudioBus","eq","reverb","wet","feedback","highPerc","hiHat","useParallelCompression","organ","compression","useOrganism","Tone.EQ3","synths","createSynthsForBuses","fallback","Tone.Reverb","preDelay","generate","err","Tone.FeedbackDelay","compressor","saturation","Tone.Distortion","distortion","chorus","Tone.Chorus","spread","lastErr","connectionError","fallbackBus","fallbackOutputNode","Tone.PolySynth","Tone.Synth","maxPolyphony","destinationNode","isHighQuality","highQuality","polyphony","Tone.MembraneSynth","octaves","partials","busError","emergencyTone","getBusForNeuron","isSelected","hasDC","isOrganSound","hasOrganEnvelope","hasOrganOscillator","createNoisyHiHat","noise","highpass","midScoopEQ","peakEQ","Tone.AmplitudeEnvelope","Tone.now","triggerAttackRelease","canPlaySound","isIsolated","calculateNeuronPriority","priority","trackActiveVoice","neuronTimeSinceLastPlay","isBassSound","trackSoundTypeActivity","applyNeuronParametersToBus","isSustainedSound","isPadSound","volumeFactor","quantizedFreq","noteDuration","noteTime","synthToUse","baseSynth","octaveSynth","fifthSynth","airSynth","managePolyphonyOverflow","octaveFreq","fifthFreq","octaveVelocity","fifthVelocity","organActiveVoices","synth","_activeVoices","isApproachingLimit","baseErr","airGain","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","useMembrane","setMembraneSynthParams","hardness","baseVolume","adjustedVolume","setTonalSynthParams","isSynthLead","setSustainSynthParams","filterFreq","q","tremolo","vibrato","bassNote","baseFreq","range","freqIndex","customFreq","ranges","notesInRange","noteInRange","overrides","freqData","baseParams","Number","defaultParams","getDefaultSynthParams","paramName","filterParamName","selected","settingName","charAt","toUpperCase","triggerPreviewSound","pitch","tempGain","setVolume","gainValue","factor","testSound","originalVolume","_lastNeuronSoundState","refreshDCNeurons","activeNotes","sort","a","noteEntry","triggerRelease","simulationWorker","audioWorker","isInitialized","neuronState","connectionState","lastSyncTime","pendingAudioEvents","simulationFPS","audioEventsPerSecond","audioQueueLength","simulationQueueLength","enableDebugLogging","initializeWithExistingNeurons","handleSimulationMessage","handleAudioMessage","processAudioEvents","Worker","onmessage","postMessage","syncInterval","syncState","handleFiringEvents","events","queueLength","totalProcessed","neuronVisual","flashNeuron","parameters","processFrame","maxEventsPerFrame","flashColor","updateParticles","neuronData","restingPotential","currentPotential","refractoryPeriod","decayRate","oscillatorFrequency","updateNeuron","assign","setSimulationRate","updateAudioSettings","getStats","terminate","maxInfluenceDistance","minInfluenceDistance","learningRate","forgetRate","relationships","currentTonalCenter","leadingNeurons","scales","major","minor","pentatonic","blues","relationshipVisuals","visualizationEnabled","createHelperMaterials","isDebugMode","historyLength","updateHistory","harmonicLineMaterial","linewidth","fog","dcSpeed","dcSpeedMultiplier","isHighSpeed","updateActiveNeurons","updateRelationships","detectTonalCenter","applyHarmonicInfluence","updateVisualizations","updateDebugInfo","n","pitchClassCounts","neuronFreq","getNeuronFrequency","pitchClass","frequencyToPitchClass","maxCount","dominantPitchClass","bestScaleFit","bestScale","scaleName","scalePattern","scaleMatchCount","relativePitchClass","scaleFit","root","confidence","identifyLeadingNeurons","toNote","neuronInfluence","influence","getNeuronById","score","sourceRelationships","j","learningTime","updateRelationshipStrength","removeRelationshipVisualization","distanceInfluence","learningCurve","exp","totalInfluence","targetAdjustments","getRelationship","adjustment","calculatePitchAdjustment","adj","applyPitchAdjustment","sourceFreq","sourcePitchClass","targetPitchClass","currentScale","relativeTargetPitchClass","isTargetInScale","closestScaleNote","smallestDistance","scaleDegree","absolutePitchClass","leaderBonus","adjustments","currentFreq","totalAdjustment","roundedAdjustment","sign","newFreq","updateNeuronFrequency","createOrUpdateRelationshipVisualization","relationshipKey","visual","lineGeometry","newFrequency","neuronCircle","noteName","getNoteNameFromFrequency","setHarmonyStrength","clearAllVisualizations","getStatus","tonalCenter","strong","sourceRels","setDebugMode","toggleVisualization","directRelationship","reverseRelationship","originalFire","timeOffset","originalSetDCInput","originalAddNeuron","initialSetup","dc","setup","createdConnections","connectionData","THREE","_originalUpdateNeuronGrid","findMatchingPreset","matchedPreset","attackMatch","decayMatch","sustainMatch","releaseMatch","oscTypeMatch","stopRandomSounds","isOverArrow","capture","helpButton","createHelpButton"],"mappings":"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"}